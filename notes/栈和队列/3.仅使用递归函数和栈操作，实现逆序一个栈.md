# 仅使用递归函数和栈操作，实现逆序一个栈



[toc]

## 1. 题目描述



**【题目】：**

​	仅使用递归函数和栈操作，实现逆序一个栈

**【要求】：**

​	只能使用递归函数实现，不能使用其他数据结构

**【示例】：**

​	一个栈依次压入 1，2，3，4，5，从栈顶到栈底分别是 5，4，3，2，1， 逆序后，从栈顶到栈底应该为 1，2，3，4，5

## 2. 思路分析

拿到题目，首先使用递归函数，并且只能使用栈结构，那么，思路就应该是：**先将栈的数据从栈底到栈顶的顺序取出来，取出后，在分别压入到原始栈中**。



这里需要用到**两次递归**，分别是：

- 将栈 stack 的栈底元素返回，并且移除。（每次调用，都会取出栈底元素并且移除，直到 stack 为空）
- 将返回的栈底元素，逆序压入到 stack 中。（利用递归，当最后一次取出栈底元素时，栈为空，然后依次压入）



**第一个递归函数**，返回 stack 栈底元素，并且移除，伪代码为：

```python
def getAndRemoveLastElement(stack):
    res = stack.Pop()
    
    # 如果为空，则 res 就是最后一个栈底元素
    if stack.isEmpty():
        return res
    # 否则，递归，将所有的元素 Pop 出来，取最后一个
    else:
        last = getAndRemoveLastElement(stack)
        # 取出栈底元素后，其他元素再依次压入 stack
        stack.Push(res)
        return last
```



如果从栈顶到栈底的数据依次为 3，2，1，`getAndRemoveLastElement`函数的整个过程为：

![逆序栈之第一个递归函数](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E9%80%86%E5%BA%8F%E6%A0%88%E4%B9%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0.PNG)

第二个递归函数，逆序整个栈。也就是利用 `getAndRemoveLastElement`函数获取到栈底元素，在按照从栈顶到栈底的逆序压入 stack。伪代码为：

```python
def reverse(stack):
    if stack.isEmpty():
        return
    
    cur_bottom = getAndRemoveLastElement(stack)
    reverse(stack)
    stack.Push(cur_bottom)
```



如果从栈顶到栈底的数据依次为 3，2，1，`reverse`函数的整个过程为：

![逆序栈之第二个递归函数](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E9%80%86%E5%BA%8F%E6%A0%88%E4%B9%8B%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0.PNG)

## 3. Golang 代码

```go
package stackAndQueue

import (
	"fmt"
	"program-algorithm/lib"
)

/*
【题目】：仅使用递归函数和栈操作，实现逆序一个栈
【要求】：只能使用递归函数实现，不能使用其他数据结构
【示例】：一个栈依次压入 1，2，3，4，5，从栈顶到栈底分别是 5，4，3，2，1， 逆序后，从栈顶到栈底应该为 1，2，3，4，5
 */

func getAndRemoveLastElement(stack *lib.StackByLinkList) interface{} {
	res, err := stack.Pop()
	if err != nil {
		fmt.Println(err.Error())
		return nil
	}
	if stack.IsEmpty() {
		return res
	} else {
		last := getAndRemoveLastElement(stack)
		stack.Push(res)
		return last
	}
}

func Reverse(stack *lib.StackByLinkList) {
	if stack.IsEmpty()  {
		return
	}

	cur_bottom := getAndRemoveLastElement(stack)
	Reverse(stack)
	stack.Push(cur_bottom)
}

func ReverseTest() {
	stack := lib.MakeStackByLinkList()
	stack.Push(1)
	stack.Push(2)
	stack.Push(3)
	stack.Push(4)
	stack.Push(5)
	stack.Show()

	Reverse(stack)

	stack.Show()
}
```

