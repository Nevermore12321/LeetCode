[toc]



# 由两个栈组成的队列



## 1. 题目描述

**【题目】：**

​	用两个栈实现队列的基本操作，支持 add，poll、peek 等



【注意】：

​	栈为先进后出，队列为先进先出



## 2. 思路



同样还是使用两个栈：

- **stackPush** - 正常压入数据，但是出栈时，先进后出，与队列的顺序相反 
- **stackPop** - 将 stackPush 的数据出栈后，在压入 stackPop 栈，此时 stackPop 栈中的出栈顺序就是队列的先进先出顺序，队列取数据，只从 stackPop 弹出



![两个栈实现队列](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.PNG)



**注意两个问题**：

- 如果 stackPush 要往 stackPop 中压入数据时，必须一次性全部压入。否则会出现乱序。
- 如果 stackPop 栈不为空，那么 stackPush 不能往其中压入数据



**步骤**：

- add 给队列添加的数据，直接先压入 stackPush 
- poll 从队列取数据时，直接从 stackPop 栈中出栈即可：
  - 当 stackPop 栈为空时，可以直接将 stackPush 的数据，全部倒序压入 stackPop 栈
  - 当 stackPop 栈不为空时，直接从 stackPop 中取数据



### 3. Golang 代码



```go	
package stackAndQueue

import (
	"fmt"
	"program-algorithm/lib"
)

/*
【题目】：用两个栈实现队列的基本操作，支持 add，poll、peek 等
【要求】：
*/

type TwoStackQueue struct {
	stackPush *lib.StackByLinkList
	stackPop  *lib.StackByLinkList
}

func MakeTwoStackQueue() *TwoStackQueue {
	stack := new(TwoStackQueue)

	stackPush := lib.MakeStackByLinkList()
	stackPop := lib.MakeStackByLinkList()

	stack.stackPush = stackPush
	stack.stackPop = stackPop

	return stack
}

func (tsq *TwoStackQueue) Add(data interface{}) {
	tsq.stackPush.Push(data)
}

func (tsq *TwoStackQueue) Poll() interface{} {
	if tsq.stackPop.IsEmpty() && tsq.stackPush.IsEmpty() {
		fmt.Println("this queue is empty")
		return nil
	} else if tsq.stackPop.IsEmpty() {
		for !tsq.stackPush.IsEmpty() {
			value, err := tsq.stackPop.Pop()
			if err != nil {
				fmt.Println(err.Error())
				return nil
			}
			tsq.stackPop.Push(value)
		}
	}
	popValue, err := tsq.stackPop.Pop()
	if err != nil {
		fmt.Println(err.Error())
		return nil
	}
	return popValue
}

func (tsq *TwoStackQueue) Peek() interface{} {
	if tsq.stackPop.IsEmpty() && tsq.stackPush.IsEmpty() {
		fmt.Println("this queue is empty")
		return nil
	} else if tsq.stackPop.IsEmpty() {
		for !tsq.stackPush.IsEmpty() {
			value, err := tsq.stackPush.Pop()
			if err != nil {
				fmt.Println(err.Error())
				return nil
			}
			tsq.stackPop.Push(value)
		}
	}

	peekValue := tsq.stackPop.Peek()
	return peekValue
}

func TwoStackQueueTest() {
	stack := MakeTwoStackQueue()

	stack.Add(1)
	stack.Add(2)
	stack.Add(3)
	stack.Add(4)
	stack.Add(5)

	fmt.Println(stack.Peek())
	fmt.Println(stack.Poll())
	fmt.Println(stack.Peek())
	fmt.Println(stack.Poll())
	fmt.Println(stack.Peek())
	fmt.Println(stack.Poll())

}
```

