[toc]



# emptyDir

当 Pod 指定到某个节点上时，首先创建的是一个 emptyDir 卷，并且只要 Pod 在该节点上运行，卷就一直存在。

注意：   

> - 当 Pod 因为某些原因被从节点上删除时，emptyDir 卷中的数据也会永久删除。  
> - 类似 docker run  -v /xxx 这种形式  
> - 在物理机中的目录时随机生成的一个目录对应。这个目录不是永久存储，pod删除，该目录就会不存在。


emptyDir 的一些用途：

- 缓存空间，例如基于磁盘的归并排序。
- 为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。
- 在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。


格式：

```
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume1
    emptyDir: {}
  - name: cache-volume2
    emptyDir: {}
```


# hostPath

hostPath 卷能将主机节点文件系统上的文件或目录挂载到您的 Pod 中。

hostPath 的一些用法有：

- 运行一个需要访问 Docker 引擎内部机制的容器；请使用 hostPath 挂载 /var/lib/docker 路径。
- 在容器中运行 cAdvisor 时，以 hostPath 方式挂载 /sys。
- 允许 Pod 指定给定的 hostPath 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。


注意：

> - 具有相同配置的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。
> - 调度到新的node节点上时，调度机制将无法考虑由 hostPath 使用的资源。
> - 基础主机上创建的文件或目录只能由 root 用户写入。


模板：

```
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: test-volume
    hostPath:
      # directory location on host
      path: /data
      # this field is optional
      type: Directory
```


# 网络卷 NFS

nfs 卷能将 NFS (网络文件系统) 挂载到您的 Pod 中。

注意：
nfs 卷可以被预先填充数据，并且这些数据可以在 Pod 之间"传递"。


1. 安装 NFS，并启动服务

    - 在一台新的 server 上安装 nfs ，作为网路卷的server

    ```
     yum install -y nfs-utils
     systemctl start rpcbind.service
     systemctl start nfs-server.service
    ```

    - 需要在所有的 kubernetes 节点上 安装 nfs-utils 作为客户端

2. 创建网络卷目录，并且配置

    - 配置格式：`目录 host(权限)`
    - rw: 可读可写
    - async : 异步
    - no_root_squash : 表示通过root权限来读写文件夹
    - 使得配置文件生效：`exportfs -arv`
    - 注意： 需要关闭防火墙

```
mkdir /root/vdisk
vim /etc/exports
/root/vdisk 10.113.0.0/16(rw,async,no_root_squash)

[root@localhost ~]# exportfs -arv
exporting 10.113.0.0/16:/root/vdisk

```

3. 在 k8s 集群上 创建 yaml文件，并使用 nfs 网络卷，模板为：

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    aa: bb
  name: nginx-nfs
  namespace: gsh
spec:
  volumes:
  - name: nfs-volume
    nfs:
      path: /root/vdisk
      server: 10.113.69.123
  containers:
  - image: nginx
    imagePullPolicy: IfNotPresent
    name: nginx
    ports:
    - containerPort: 80
    volumeMounts:
    - name: nfs-volume
      mountPath: /xx
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```


# 持久卷（重要）

## PersistentVolume， PV

持久卷（PersistentVolume，PV）是集群中的一块存储，可以由管理员事先供应

PersistentVolume，也就是PV：

- 是管理员创建好的，相当于一块磁盘目录
- 可以由任何命名空间中的用户，通过 PersistentVolumeClaim 与之匹配，然后使用
- PV 是全局的，所有命名空间可见的
- PV 不管后端是用什么存储的，例如 NFS、ISCSI 等
- PV 和 pod 一样，也是 kubernetes 中的一种资源
- 通过 pv 和 pvc ，用户无需知道后面用什么存储卷，只需要使用即可，增强了安全性
- PV 创建好后，需要时Available 状态才能使用


**PersistentVolume各个阶段的状态名称**：

- Available（可用）: 卷是一个空闲资源，尚未绑定到任何申领；
- Bound（已绑定）: 该卷已经绑定到某申领；
- Released（已释放）: 所绑定的申领已被删除，但是资源尚未被集群回收；
- Failed（失败）: 卷的自动回收操作失败。

**PersistentVolume 创建模板**：

```
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0003
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: slow
  mountOptions:
    - hard
    - nfsvers=4.1
  nfs:
    path: /tmp
    server: 172.17.0.2
```

**说明**：

- capacity : PV 卷确定的存储容量
- volumeMode : 卷模式
    - Filesystem（文件系统）: 卷会被 Pod 挂载（Mount） 到某个目录
    - Block（块）: 将卷作为原始块设备来使用。 这类卷以块设备的方式交给 Pod 使用，其上没有任何文件系统。
- accessModes : 访问模式
    - ReadWriteOnce : 卷可以被一个节点以读写方式挂载；
    - ReadOnlyMany : 卷可以被多个节点以只读方式挂载；
    - ReadWriteMany : 卷可以被多个节点以读写方式挂载。
- persistentVolumeReclaimPolicy : 回收策略 
    - Retain -- -不回收数据, pod pv 删除后，不会删除卷中目录的内容
        - 但是删除pvc之后，pv依然不可用
        - pv状态长期保持为 Released
    - Recycle -- 会删除数据 (rm -rf /thevolume/*)
        - 删除pvc之后，pv可复用
        - pv状态由Released变为Available
    - Delete -- 诸如 AWS EBS、GCE PD、Azure Disk 或 OpenStack Cinder 卷这类关联存储资产也被删除
- storageClassName : PV 的类名
    - 特定类的 PV 卷只能绑定到请求该类存储卷的 PVC 申领。 
    - 未设置 storageClassName 的 PV 卷没有类设定，只能绑定到那些没有指定特定 存储类的 PVC 申领。
- mountOptions : 挂载选项 
    - 管理员可以指定持久卷被挂载到节点上时使用的附加挂载选项
- 最后就是使用的网络卷的设置，这里使用的是 NFS 




## PersistentVolumeClaim，PVC

PersistentVolumeClaim，也就是PVC，是用户根据特定存储容量和特定访问模式需求创建的

概念分析：

- PersistentVolumeClaim ，pvc 是用户在某一个特定的namespace下创建的
- kuberentes会将 PVc 与 与之匹配的 pv 绑定在一起，这样在pod中，在使用此pvc就可以挂在到pv所对应的卷中
- pv 与 pvc 是 一对一的映射关系，也就是一个pv只能与一个pvc绑定，而且是双向绑定
- 如果pvc找不到匹配的 PV 卷，PVC 处于未绑定状态，当与之匹配的 PV 卷可用时，PVC 才会会被绑定
- 流程：
    - 管理源 创建 pv 与 真实的卷绑定
    - 用户创建 pvc 与 管理员创建的 pv 绑定
    - 用户创建 pod 中使用 pvc 挂在到真实的卷


**PersistentVolume 创建模板**：

```
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
      storage: 5Gi
  storageClassName: slow
  selector:
    matchLabels:
      release: "stable"
    matchExpressions:
      - {key: environment, operator: In, values: [dev]}
```

**说明**：

- accessModes : 访问模式，必须与 PV 保持一致
- volumeMode : 卷模式， 必须与PV保持一致
- resources : 申请的资源大小，在这里，是申请的 卷的大小
    - 注意： 这里申请的 卷的大小，一定要小于等于 pv 中设置的卷大小
- storageClassName : 设置要匹配的PV的类名，也就是想和哪个pv匹配，需要设置和pv一致的类名
    - 如果没有设置  storageClassName 类名，则该pvc匹配的是没有设置类名的 PV 卷
- selector : 选择器，设置选择器来进一步过滤卷pv集合
    - 只有标签与selector相匹配的卷能够绑定
    - matchLabels : PV 卷必须包含带有此值的标签
    - matchExpressions : 通过设定键（key）、值列表和操作符（operator） 来构造的需求。合法的操作符有 In、NotIn、Exists 和 DoesNotExist。


## pod 中的使用

注意： 在pod中直接使用 PersistentVolumeClaim（PVC）即可，即在 vloumes 中选择要使用的pvc


**pod 使用pvc的模板**

```
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim
```

**说明**：

- persistentVolumeClaim : 使用 pvc 来作为 挂在卷
    - claimName : 选择哪个pvc作为挂载卷，也就是pvc的name