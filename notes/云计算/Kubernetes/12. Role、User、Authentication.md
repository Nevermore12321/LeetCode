[toc]


# 用户管理

用户登录有两种方式：
- 使用 kubeconfig 文件登录方式
    - 注意：kubeconfig指的是认证文件，这个名称可以修改
    - 例如：/etc/kubernetes/admin.conf 就是 kubeconfig 文件
- 使用用户名和密码 --token 登录方式(已废弃)

## kubeconfig 文件方式

默认读取的kuebeconfig文件在 ~/.kube/config 文件

- 使用 kubeconfig 文件来组织有关集群、用户、命名空间和身份认证机制的信息。
- kubectl 命令行工具使用 kubeconfig  文件来查找选择集群所需的信息，并与集群的 API 服务器进行通信。


**kubeconfig 文件格式**
```
apiVersion: v1
clusters:                               # 多集群配置，下面list可以有多个
- cluster:                              # 第一个集群信息
    certificate-authority-data: ...     # 集群的证书
    server: https://10.113.71.253:6443  # 集群的 apiServer Ip
  name: kubernetes                      # 集群名称
contexts:                               # 多集群配置上下文，下面list也可以有多个
- context:                              # 第一个上下文信息
    cluster: kubernetes                 # 该 上下文 对应的是哪个 cluster
    namespace: efk-logger               # 默认的命名空间
    user: kubernetes-admin              # 使用哪个用户登录
  name: kubernetes-admin@kubernetes     # 上下文的名称
current-context: kubernetes-admin@kubernetes    # 当前使用哪个上下文
kind: Config
preferences: {}
users:                                  # 多用户信息配置，下面list也可以有多个
- name: kubernetes-admin                # 用户名称
  user:                                 # 用户的信息详情
    client-certificate-data: ...        # 用户的证书
    client-key-data: ...                # 用户的key

```


**kubeconfig 文件的使用**
1. 将 生成好的kubeconfig 文件拷贝到其他机器上，需要安装 kubectl 来使用
2. 默认情况下，kubectl 在 $HOME/.kube 目录下查找名为 config 的文件
3. 第一种方式可以命令选项指定 kubeconfig 文件： `kubectl --kubeconfig=/path/to/kubeconfig get nodes`
4. 第二种方式可以通过环境变量的方式指定 kubeconfig 文件： `export KUBECONFIG=/path/to/kubeconfig`, 之后可以直接使用 kubectl 。



## 手动创建 kubeconfig 文件

要创建 kubeconfig 文件需要一个私钥，以及集群CA授权颁发的证书。

我们不能直接使用私钥生成公钥，而必须用私钥生成证书请求文件csr，然后根据证书请求文件向CA(权威机构)申请证书，CA审核之后会办法证书。

### 1. 申请证书

1. 创建私钥，假如名称为 john.key
    - `openssl genrsa -out john.key 2048`
```
[root@k8s-master learn-k8s]# mkdir role
[root@k8s-master learn-k8s]# cd role/

[root@k8s-master role]# openssl genrsa -out john.key 2048
Generating RSA private key, 2048 bit long modulus
...............................................................................+++
.................................................................................................+++
e is 65537 (0x10001)
[root@k8s-master role]# ls
john.key

```

2. 利用刚生成的 john.key 生成证书请求文件 john.csr
    - `openssl req -new -key john.key -out john.csr -subj "/CN=john/O=cka2020"`
    - 注意：CN的值 john ，就是我们后面要授权的用户
```
[root@k8s-master role]# openssl req -new -key john.key -out john.csr -subj "/CN=john/O=cka2020"
[root@k8s-master role]# ls
john.csr  john.key

```
3. 对证书请求文件 john.csr 进行 base64 编码
    - `cat john.csr | base64 | tr -d "\n"`
```
[root@k8s-master role]# cat john.csr | base64 | tr -d "\n"
LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1pqQ0NBVTRDQVFBd0lURU5NQXNHQTFVRUF3d0VhbTlvYmpFUU1BNEdBMVVFQ2d3SFkydGhNakF5TURDQwpBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU11WjA3eHQrU0tIZkQ0cTR6RlpEN0tlCkl3MkxjTld1Mk10QVJSL21xQVFUZWw3VkZvM3hkWkkwcU1KMGZEVWxSbHJjdmpaYUxRN3JpZFJlTTBlNWx1YVMKVkgvQS9DeCs3ak5kMUx3QnJxWWdPVU5RdUhOZjZ4UEhoODlCZXZodG5xQi9EQUErVSt4MnlIUCtwc3llN01pVQpWNXZRS2lJTW8veS9kM2g3K0NBSmMyODI5ay9wSnFyTHpuWVI4dExHS0V3d1pKVWpPZk5FNWF0cnJIdmhTMkhzCkxOdU0xVG1FTEJ5Ui96WEhEemVUUWhJYlBHL0tHZUhlcXRqWEMxd2dINk5zOEh1YUNGSzZFMDlWTW5YRlBCajAKZUIyaHNPR1dPSlQyb0FTZmZ1OEowMmYydXR1TkFhSzh4cFMvNjQzSDU3a05DLzNpaVFtcDZFQzlObERpeU1jQwpBd0VBQWFBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQ2ZWV2F0VlV2UHpKZ3QxbmxubHZucWM4eTcycnErCmNjbVk1T3J4bVNEZ1V6dzlTaVIyK3BKeDhXYk1UVlR0SkJjamV2azQ3OWo0NHdUdWtKNi9rL2VCeVVLZm1KSnUKaXJ0QXFiMm83QTE1M3doaU1CNXh3RldmQkVIMXJDZU4xOUdnU01yZDh5RnhVUHRnNW1kMU1XaHFMWVVvOE1BawpZSEQyOU9uRHpEMW12SjdTcFd0cG42SXVBd1kvMzRsTG9ySVBiQVFOM09TY29WZXdSQWJHZ0dhN1JzdFQxeGEvCjlkd3NMcnhuYU9XUzBmY0wwcTFJNlp1VDkwSVdLMmM4cVNzcXZ3Wnp4OTBwOTBiOTFWRlVoaXhWcTZqVjVWNDcKMyszSWVmNVEwVHFrandlUVlXY0x0NnlXUmNDOFZFdkZtdGo3WWZxMzFiN3prcll1MnZXSE9XREkKLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg==
```
4. 编写申请证书请求文件的yaml文件，并且创建 csr
    - 创建证书签名请求对象发送到 Kubernetes API
    - 注意：name 为 john 用户，request 就是第三部中 base64 编码的结果，
    - 注意：因为 apiversion 是 v1beta1 版本，因此不需要加 signerName
    - 创建 csr 后，可以看到，csr 的状态是pending，还没有经过 apiserver审批
```
[root@k8s-master role]# cat csr.yaml
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: john
spec:
  groups:
  - system:authenticated
  #signerName: kubernetes.io/legacy-aa                # 将这行注释掉，因为apiVerison 为 v1beta1
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1pqQ0NBVTRDQVFBd0lURU5NQXNHQTFVRUF3d0VhbTlvYmpFUU1BNEdBMVVFQ2d3SFkydGhNakF5TURDQwpBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU11WjA3eHQrU0tIZkQ0cTR6RlpEN0tlCkl3MkxjTld1Mk10QVJSL21xQVFUZWw3VkZvM3hkWkkwcU1KMGZEVWxSbHJjdmpaYUxRN3JpZFJlTTBlNWx1YVMKVkgvQS9DeCs3ak5kMUx3QnJxWWdPVU5RdUhOZjZ4UEhoODlCZXZodG5xQi9EQUErVSt4MnlIUCtwc3llN01pVQpWNXZRS2lJTW8veS9kM2g3K0NBSmMyODI5ay9wSnFyTHpuWVI4dExHS0V3d1pKVWpPZk5FNWF0cnJIdmhTMkhzCkxOdU0xVG1FTEJ5Ui96WEhEemVUUWhJYlBHL0tHZUhlcXRqWEMxd2dINk5zOEh1YUNGSzZFMDlWTW5YRlBCajAKZUIyaHNPR1dPSlQyb0FTZmZ1OEowMmYydXR1TkFhSzh4cFMvNjQzSDU3a05DLzNpaVFtcDZFQzlObERpeU1jQwpBd0VBQWFBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQ2ZWV2F0VlV2UHpKZ3QxbmxubHZucWM4eTcycnErCmNjbVk1T3J4bVNEZ1V6dzlTaVIyK3BKeDhXYk1UVlR0SkJjamV2azQ3OWo0NHdUdWtKNi9rL2VCeVVLZm1KSnUKaXJ0QXFiMm83QTE1M3doaU1CNXh3RldmQkVIMXJDZU4xOUdnU01yZDh5RnhVUHRnNW1kMU1XaHFMWVVvOE1BawpZSEQyOU9uRHpEMW12SjdTcFd0cG42SXVBd1kvMzRsTG9ySVBiQVFOM09TY29WZXdSQWJHZ0dhN1JzdFQxeGEvCjlkd3NMcnhuYU9XUzBmY0wwcTFJNlp1VDkwSVdLMmM4cVNzcXZ3Wnp4OTBwOTBiOTFWRlVoaXhWcTZqVjVWNDcKMyszSWVmNVEwVHFrandlUVlXY0x0NnlXUmNDOFZFdkZtdGo3WWZxMzFiN3prcll1MnZXSE9XREkKLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg==
  usages:
  - client auth

//  创建 csr
[root@k8s-master role]# kubectl apply -f csr.yaml
Warning: certificates.k8s.io/v1beta1 CertificateSigningRequest is deprecated in v1.19+, unavailable in v1.22+; use certificates.k8s.io/v1 CertificateSigningRequest
certificatesigningrequest.certificates.k8s.io/john created
[root@k8s-master role]# kubectl get csr
NAME   AGE   SIGNERNAME                     REQUESTOR          CONDITION
john   5s    kubernetes.io/legacy-unknown   kubernetes-admin   Pending
```
5. 通过 kubernetes的master，apiserver 通过 john 的csr 请求
    - `kubectl certificate approve john`
    - 注意：一旦 k8s 通过 csr 的审批，目前还有一种撤销审批的方式
```
[root@k8s-master role]# kubectl certificate approve john
certificatesigningrequest.certificates.k8s.io/john approved

[root@k8s-master role]# kubectl get csr
NAME   AGE   SIGNERNAME                     REQUESTOR          CONDITION
john   37m   kubernetes.io/legacy-unknown   kubernetes-admin   Approved,Issued

```
6. 查看通过审批的john的证书, 并导出
    - 查看证书：` kubectl get csr john -o jsonpath={.status.certificate}`
    - 将 上述 输出 经过 base64解码后，重定向到文件：`kubectl get csr john -o jsonpath={.status.certificate} | base64 -d > john.crt`
    - john.crt 就是最后想要的 用户证书
```
[root@k8s-master role]# kubectl get csr john -o jsonpath={.status.certificate} | base64 -d
-----BEGIN CERTIFICATE-----
MIIDBjCCAe6gAwIBAgIQV5hq3QQUqRo46ymHF3dDCDANBgkqhkiG9w0BAQsFADAV
MRMwEQYDVQQDEwprdWJlcm5ldGVzMB4XDTIwMTAyNTA1MzUzOFoXDTIxMTAyNTA1
MzUzOFowITEQMA4GA1UEChMHY2thMjAyMDENMAsGA1UEAxMEam9objCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMuZ07xt+SKHfD4q4zFZD7KeIw2LcNWu
2MtARR/mqAQTel7VFo3xdZI0qMJ0fDUlRlrcvjZaLQ7ridReM0e5luaSVH/A/Cx+
7jNd1LwBrqYgOUNQuHNf6xPHh89BevhtnqB/DAA+U+x2yHP+psye7MiUV5vQKiIM
o/y/d3h7+CAJc2829k/pJqrLznYR8tLGKEwwZJUjOfNE5atrrHvhS2HsLNuM1TmE
LByR/zXHDzeTQhIbPG/KGeHeqtjXC1wgH6Ns8HuaCFK6E09VMnXFPBj0eB2hsOGW
OJT2oASffu8J02f2utuNAaK8xpS/643H57kNC/3iiQmp6EC9NlDiyMcCAwEAAaNG
MEQwEwYDVR0lBAwwCgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAfBgNVHSMEGDAW
gBT4sNWunBUlVJXSMG+FRHamQEG1JzANBgkqhkiG9w0BAQsFAAOCAQEARDl7PgWg
xzxoLnSigfMaZwbKio8dwHWyZMVD31bH5TUnKGdCinRfsIBSdzcB1Ctc4RcNkZCS
DwZ12ixTKj+toHo8P/A6S1LiQ+wax+MEanKM7D+lGjXKujXU+tOzYpL534UVq/6o
nfDi54DHta9IonHwE894n2uIhlUrtMITfTbdspUjrG7jid5gExsVchoKEwGJfNOI
LRVr5hYqI/Rl+2m974BrAuIC54rwNE+dVqQXdv3iivf2qcqrQrt8YS6MadrUJVjg
DRYRY46j6m7++vJ5vFACkH2hjBi/alnjcQv6aTEcKvZsa17UCPDibfkDbeNL+jV/
2YOWdKQI9nHuxw==
-----END CERTIFICATE-----
[root@k8s-master role]#


//  base64 解码后，重定向到文件
[root@k8s-master role]# kubectl get csr john -o jsonpath={.status.certificate} | base64 -d > john.crt
```
7. 给当前 john 用户 配置权限
    - 权限管理，下一节说明
    - 当前知识配置一个admin权限用作测试，命令：`kubectl create clusterrolebinding test --clusterrole=cluster-admin --user=john`
    - 注意：clusterrolebinding 就是将一个用户绑定至一个role
    - 注意：当前用户就是 --user 所指出的用户
    - 注意：绑定到的role就是 --clusterrole 所指定的role
```
[root@k8s-master role]# kubectl create clusterrolebinding test --clusterrole=cluster-admin --user=john
clusterrolebinding.rbac.authorization.k8s.io/test created

[root@k8s-master role]# kubectl get clusterrolebindings.rbac.authorization.k8s.io  | grep test
NAME                                                   ROLE                                                                               AGE
test                                                   ClusterRole/cluster-admin                                                          23s
```



### 2. 创建 kubeconfig 文件

1. kubeconfig 模板文件，可以通过 `kubectl config view` 来生成，进行修改
    - clusters 字段，表示集群的信息
    - users 字段，表示指定用户
    - contexts 字段，表示指定上下文，包括用户默认所在的命名空间等信息
```
[root@k8s-master role]# cat mykubeconfig
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://10.113.71.253:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    namespace: gsh
    user: kubernetes-admin
  name: kubernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes
kind: Config
preferences: {}
users:
- name: kubernetes-admin
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED

//  将特定字段删掉，就可以看到kuebconfig的模板文件
[root@k8s-master role]# cat mykubeconfig
apiVersion: v1
clusters: null
contexts: null
current-context: ""
kind: Config
preferences: {}
users: null
[root@k8s-mast

```
2. 拷贝 CA 证书
    - 目录在 /etc/kubernetes/pki/ca.crt, 拷贝到当前john目录下
```
[root@k8s-master role]# cp /etc/kubernetes/pki/ca.crt ./
```
3. 设置集群字段
    - `kubectl config --kubeconfig=./mykubeconfig set-cluster cluster1 --server=https://10.113.71.253:6443 --certificate-authority=ca.crt --embed-certs=true`
    - `--embed-certs=true` 表示是否将证书内容写入到kubeconfig文件中
    - `--server=` 表示 apiserver 的地址
    - `--certificate-authority` 表示 ca 证书的位置
    - `set-cluster` 表示设置一个 cluster 集群的信息
```
[root@k8s-master role]# kubectl config --kubeconfig=./mykubeconfig set-cluster cluster1 --server=https://10.113.71.253:6443 --certificate-authority=ca.crt --embed-certs=true
Cluster "cluster1" set.
[root@k8s-master role]# cat mykubeconfig
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJd01Ea3lNREUxTlRnd04xb1hEVE13TURreE9ERTFOVGd3TjFvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBS1M0CmVnUEhaOFZhTytJSVVFamZLVEVHWnlIcDg0MW5kMEZoK0ZvYm9kL3hzS3BRQTlnNndmZ1lhazJpQVgzRlZSa20KdVk1dm80WVdOZFBqdXA3SEhOUkYwQTBaQXRMY2VXUGVZNE1oVEFsZGlkZzFKZEdFV2IyQXJCRWE0b3B5OHA1eQowc0VOejluUnF2a0VTcENtV0VkZStXU253bzhxUGNOZGsvam05Vm9BcDNmWVpIU0JTMGk1bHdvZ1FsektFbmhOCklENDA5SmFGQ0dyS3BWUGVTblBlU083bnJOQ256R2QrTDdJYWYya0lWaXVoeGJSek9MeWhZb3NTejgrakJ1eEcKZEZlRWY5TkhSbmtMVnptOGE5Vzl5ei93bFJPbXF6NFMxelVkRDc4K3krQ2dXUDlRSTJoSUFva29LRFlPWTBGSwovZHNuRm00RHJDK3QrSkhpdVFrQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZQaXcxYTZjRlNWVWxkSXdiNFZFZHFaQVFiVW5NQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBTWMrenFYaEdSY1VDWjhjYkk3MFA5WnBxODVxSERNUUN3VGFpRFB0WE9VY2FlU0oxWQpPVTlnYk9kYVNvdUxHVDdIMXBIQ0FOckRONUFKWUh5RitNVnJRSzU4WG1VNXNJVW5RTlc5ZkI5Y1JYSlJqRFV2CnREaXcwbk14TDl1RWE0RjJySGxoeDBhWUNhNmdjdFB1UzdFLzBaWGx0b1Z4NjZ5blE0RkgyWW5ydnpEWE9EcHYKYURxMkMwWXhJSFhKVWEvZTE3QlFkS01lNVh3T092LzNGTEFyWW4vTWdDeGtRMzlVTlFGZ21wcTFVcDl3SWY5cApDMlBENnFSdFlnd3ZMS1NOQWJuNHhOTjgwMXVPa1NndUhWb0FueE9naG4vcnYyQ3A1U3N2OXFtNVl5SlpJN3dtCk5CVXNXTGNSbWxDa0xqU1hiOHIrQ09vUUJqRi9zMER0TU91QQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
    server: https://10.113.71.253:6443
  name: cluster1
contexts: null
current-context: ""
kind: Config
preferences: {}
users: null

```
4. 设置用户字段
    - `kubectl config --kubeconfig=./mykubeconfig set-credentials john --client-certificate=./john.crt --client-key=./john.key --embed-certs=true`
    - `set-credentials` 字段，表示设置用户
    - `--client-certificate` 字段，表示john用户的证书
    - `--client-key` 字段，表示john用户的私钥
```
[root@k8s-master role]# kubectl config --kubeconfig=./mykubeconfig set-credentials john --client-certificate=./john.crt --client-key=./john.key --embed-certs=true
User "john" set.
[root@k8s-master role]# cat mykubeconfig
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJd01Ea3lNREUxTlRnd04xb1hEVE13TURreE9ERTFOVGd3TjFvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBS1M0CmVnUEhaOFZhTytJSVVFamZLVEVHWnlIcDg0MW5kMEZoK0ZvYm9kL3hzS3BRQTlnNndmZ1lhazJpQVgzRlZSa20KdVk1dm80WVdOZFBqdXA3SEhOUkYwQTBaQXRMY2VXUGVZNE1oVEFsZGlkZzFKZEdFV2IyQXJCRWE0b3B5OHA1eQowc0VOejluUnF2a0VTcENtV0VkZStXU253bzhxUGNOZGsvam05Vm9BcDNmWVpIU0JTMGk1bHdvZ1FsektFbmhOCklENDA5SmFGQ0dyS3BWUGVTblBlU083bnJOQ256R2QrTDdJYWYya0lWaXVoeGJSek9MeWhZb3NTejgrakJ1eEcKZEZlRWY5TkhSbmtMVnptOGE5Vzl5ei93bFJPbXF6NFMxelVkRDc4K3krQ2dXUDlRSTJoSUFva29LRFlPWTBGSwovZHNuRm00RHJDK3QrSkhpdVFrQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZQaXcxYTZjRlNWVWxkSXdiNFZFZHFaQVFiVW5NQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBTWMrenFYaEdSY1VDWjhjYkk3MFA5WnBxODVxSERNUUN3VGFpRFB0WE9VY2FlU0oxWQpPVTlnYk9kYVNvdUxHVDdIMXBIQ0FOckRONUFKWUh5RitNVnJRSzU4WG1VNXNJVW5RTlc5ZkI5Y1JYSlJqRFV2CnREaXcwbk14TDl1RWE0RjJySGxoeDBhWUNhNmdjdFB1UzdFLzBaWGx0b1Z4NjZ5blE0RkgyWW5ydnpEWE9EcHYKYURxMkMwWXhJSFhKVWEvZTE3QlFkS01lNVh3T092LzNGTEFyWW4vTWdDeGtRMzlVTlFGZ21wcTFVcDl3SWY5cApDMlBENnFSdFlnd3ZMS1NOQWJuNHhOTjgwMXVPa1NndUhWb0FueE9naG4vcnYyQ3A1U3N2OXFtNVl5SlpJN3dtCk5CVXNXTGNSbWxDa0xqU1hiOHIrQ09vUUJqRi9zMER0TU91QQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
    server: https://10.113.71.253:6443
  name: cluster1
contexts: null
current-context: ""
kind: Config
preferences: {}
users:
- name: john
  user:
    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCakNDQWU2Z0F3SUJBZ0lRVjVocTNRUVVxUm80NnltSEYzZERDREFOQmdrcWhraUc5dzBCQVFzRkFEQVYKTVJNd0VRWURWUVFERXdwcmRXSmxjbTVsZEdWek1CNFhEVEl3TVRBeU5UQTFNelV6T0ZvWERUSXhNVEF5TlRBMQpNelV6T0Zvd0lURVFNQTRHQTFVRUNoTUhZMnRoTWpBeU1ERU5NQXNHQTFVRUF4TUVhbTlvYmpDQ0FTSXdEUVlKCktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU11WjA3eHQrU0tIZkQ0cTR6RlpEN0tlSXcyTGNOV3UKMk10QVJSL21xQVFUZWw3VkZvM3hkWkkwcU1KMGZEVWxSbHJjdmpaYUxRN3JpZFJlTTBlNWx1YVNWSC9BL0N4Kwo3ak5kMUx3QnJxWWdPVU5RdUhOZjZ4UEhoODlCZXZodG5xQi9EQUErVSt4MnlIUCtwc3llN01pVVY1dlFLaUlNCm8veS9kM2g3K0NBSmMyODI5ay9wSnFyTHpuWVI4dExHS0V3d1pKVWpPZk5FNWF0cnJIdmhTMkhzTE51TTFUbUUKTEJ5Ui96WEhEemVUUWhJYlBHL0tHZUhlcXRqWEMxd2dINk5zOEh1YUNGSzZFMDlWTW5YRlBCajBlQjJoc09HVwpPSlQyb0FTZmZ1OEowMmYydXR1TkFhSzh4cFMvNjQzSDU3a05DLzNpaVFtcDZFQzlObERpeU1jQ0F3RUFBYU5HCk1FUXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUhBd0l3REFZRFZSMFRBUUgvQkFJd0FEQWZCZ05WSFNNRUdEQVcKZ0JUNHNOV3VuQlVsVkpYU01HK0ZSSGFtUUVHMUp6QU5CZ2txaGtpRzl3MEJBUXNGQUFPQ0FRRUFSRGw3UGdXZwp4enhvTG5TaWdmTWFad2JLaW84ZHdIV3laTVZEMzFiSDVUVW5LR2RDaW5SZnNJQlNkemNCMUN0YzRSY05rWkNTCkR3WjEyaXhUS2ordG9IbzhQL0E2UzFMaVErd2F4K01FYW5LTTdEK2xHalhLdWpYVSt0T3pZcEw1MzRVVnEvNm8KbmZEaTU0REh0YTlJb25Id0U4OTRuMnVJaGxVcnRNSVRmVGJkc3BVanJHN2ppZDVnRXhzVmNob0tFd0dKZk5PSQpMUlZyNWhZcUkvUmwrMm05NzRCckF1SUM1NHJ3TkUrZFZxUVhkdjNpaXZmMnFjcXJRcnQ4WVM2TWFkclVKVmpnCkRSWVJZNDZqNm03Kyt2SjV2RkFDa0gyaGpCaS9hbG5qY1F2NmFURWNLdlpzYTE3VUNQRGliZmtEYmVOTCtqVi8KMllPV2RLUUk5bkh1eHc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
    client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb2dJQkFBS0NBUUVBeTVuVHZHMzVJb2Q4UGlyak1Wa1BzcDRqRFl0dzFhN1l5MEJGSCthb0JCTjZYdFVXCmpmRjFralNvd25SOE5TVkdXdHkrTmxvdER1dUoxRjR6UjdtVzVwSlVmOEQ4TEg3dU0xM1V2QUd1cGlBNVExQzQKYzEvckU4ZUh6MEY2K0cyZW9IOE1BRDVUN0hiSWMvNm16SjdzeUpSWG05QXFJZ3lqL0w5M2VIdjRJQWx6YnpiMgpUK2ttcXN2T2RoSHkwc1lvVERCa2xTTTU4MFRscTJ1c2UrRkxZZXdzMjR6Vk9ZUXNISkgvTmNjUE41TkNFaHM4CmI4b1o0ZDZxMk5jTFhDQWZvMnp3ZTVvSVVyb1RUMVV5ZGNVOEdQUjRIYUd3NFpZNGxQYWdCSjkrN3duVFovYTYKMjQwQm9yekdsTC9yamNmbnVRMEwvZUtKQ2Fub1FMMDJVT0xJeHdJREFRQUJBb0lCQUV0VWh2clkxYXpvNUJjOApWd01US0xPMXZ0SnNIVHR5amRQbDI2Mko4ZkJRSko2aHlNNkw0Q3hRUDRCekNPSEJBTjd0ZlpNdW1pMURDS1FDCmxvYWJMREh6UWtCaWJ1c25xNHBsMVNnYWx6dndBRC9meGQ4cVJoZnpZMVJUcmVQczZ4d0c1YkhSWGN2SHh6TGoKcldOWUNkUE16djFmYjdkWlpmTkdCRFlYNkI0eHQ4VldGOWRoOWxxLzdSdlowNm1uTzB0bDJ5eENqejRpaC9CNApSZ3dnbU1WUEs4SE9MeTVhSjhrTGhoTzRKVEJwSS9CMm4xNGxBdjIzU0hrSWNNWnRQVC94UDViNS9scGF6cW5DClMweldpUy9xTGJLMlZVeVZhdys5Y1RMM2hlZ0ptMlFVZW5XRHRFbFlWaW5ZWHJPbzRWd255anpKK1Vna1JRQWMKZ3MyV09ZRUNnWUVBOGFVRkJYUmNqeHJqNHB5NW0wdlhTbjd5TElMWC9jeDUySHZQRjdCblpyS01WRE81RzdXTgp4TlcxY0pEcXJQWlMxVnBVM0dJcXZKQlBML3M5Ym5tc2p6QXQyYmVDQzFTZWt2M29nSnhHRXNlV2lqdDB0SFM4CnFSVlZRbkpFbzYxdjZIblpTeVNIQ25VOEN4cnJqL0svN3hqWVpuZ2FTRG5nR25pb083VW1xMWtDZ1lFQTE3STcKRjZiVHBiT21vbjlTUkJCOUlWZXBhaUpkaHFOd01UZ09Na1J3SU8xMEd3Z0IxR2tYQmwzaVpPMnZSYk9MWVRiYwphOVBPSk1raDlDWE4zL1ZPbmIyQXpkL0hzY2JibzJmTDZhL3NPSWwvWnB4SXhnQjFUMEVLSzlIeU0xcHdFdEhvCkVwNUx0Z0ZkbWhkSGptaUhNMFhTR1JuTUV3TC9UQ3c4ZWNpb01SOENnWUF1VHBCU3hrVENpOFdsOUtEQStOeXUKQXZ2SHVkOUlYTG53MlhFTE9odm1tMHEzREI1cUIvVytCYkk2ZXhydHdGcUpWa0V5NW9FSUY2T0ZMMkZMWFhmTApETkdNaWxVYWRNSGFxMXUxNGJ5djlwMkxxZThvY2NLQnFIdnBPdHFhZnk4VjN0dmNRWWk3WVZIN1V0SlhpSTV0CmRGWnI5SkljeXpKK0FDZEZJZWJpS1FLQmdGMXcyY2FpUDlmdDNzZFFqdXZybExtb0J6MXlTNy95OTd4cXcwT2wKZ0VuVGRGUHRnUlZxdlUzRnlEamUrdW9nSU1acGhNMjFnUDFRb01QcXlLZzMxZW5oMlhYV2R1VWQ5N0p2V2RnUApuUzdVNmZzaXd5Zjd0Tll6bjl0aDVTRzRFUXNtSWZwRzF4ZXV1Y1R5UnM1N20rNXJWZHdIMys5d2dmYVd4MUFlCnpEWVRBb0dBWklBQUM1UStYaGZqY253UjhNUTE4dEk2KzQ1RmpLa2JLbWdqbGM3NU1CWWpUajlrN3FSTTdSOVgKVEZWbGE3a1c1aTlidDVjYkhVRGpJV1V0V21MMnhZcWVqODFqZEQvVjNPbmdyL1h4NTZkNCtDMXJQQ3QxRjl4dwpHNWJxMzNGbzc4dDEwN0tuVlFWeUZYU29Xb1EwT3RDVXRGNHp3NXlydkpWeTZwMldhbFk9Ci0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==

```
5. 设置上下文信息
    - `kubectl config --kubeconfig=./mykubeconfig set-context context1 --cluster=cluster1 --namespace=gsh --user=john`
    - `set-context` 字段，表示设置 上下文 字段
    - `--cluster` 字段，表示该上下文对应的是哪个集群
    - `--namespace` 字段，表示该上下文 对应的是哪个 命名空间
    - `--user` 字段，表示该上下文 对应的是哪个用户
```
[root@k8s-master role]# kubectl config --kubeconfig=./mykubeconfig set-context context1 --cluster=cluster1 --namespace=gsh --user=john
Context "context1" created.
[root@k8s-master role]# cat mykubeconfig
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTi....
    server: https://10.113.71.253:6443
  name: cluster1
contexts:
- context:
    cluster: cluster1
    namespace: gsh
    user: john
  name: context1
current-context: ""
kind: Config
preferences: {}
users:
- name: john
  user:
    client-certificate-data: LS0tLS1CRUdJTi....
    client-key-data: LS0tLS1CRUd....

```
6. 设置当前上下文，也就是`current-context`字段，设置为 context1，最终的 kubeconfig文件为：
```
[root@k8s-master role]# cat mykubeconfig
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTi....
    server: https://10.113.71.253:6443
  name: cluster1
contexts:
- context:
    cluster: cluster1
    namespace: gsh
    user: john
  name: context1
current-context: "context1"
kind: Config
preferences: {}
users:
- name: john
  user:
    client-certificate-data: LS0tLS1CRUdJTi....
    client-key-data: LS0tLS1CRUd....
```
7. 至此，kubeconfig 文件就设置好了， 可以拷贝到其他机器上来通过kubectl来访问集群。




### 3. 验证 kubeconfig 文件

1. 将 设置好的 kubeconfig 文件拷贝到其他机器上
2. 安装 kubectl
3. 两种方式验证：
    - 通过kubectl命令选项方式指定kubeconfig文件 `kubectl get nodes --kubeconfig=/root/kubeconfig/mykubeconfig`
    - 通过环境变量的形式：`export KUBECONFIG=/root/kubeconfig/mykubeconfig`






# 权限管理

## 了解授权authorization

在 /etc/kubernetes/manifests/kube-apiserver.yaml 中有 --authorization-mode=` 选项，用来设置授权模式，有以下几种授权模式:  
- `--authorization-mode=AlwaysAllow` : 允许所有请求
- `--authorization-mode=AlwaysDeny` : 拒绝所有请求
- `--authorization-mode=ABAC` : Attribute-Based Access Control,
    - 基于属性的访问控制（ABAC）模式允许您使用本地文件配置策略。
    - 不够灵活放弃
- `--authorization-mode=RBAC` : Role Based Access Control
    - 基于角色的访问控制（RBAC）模式允许您使用 Kubernetes API 创建和存储策略。
- `--authorization-mode=Node` :专门授权由 kubelet 发出的 API 请求。
    - Node授权器主要用于各个node上的kubelet访问apiserver时使用的，其他一般均由RBAC授权器来授权

## Role 和 RoleBinding 


在 RBAC API 中，一个角色包含一组相关权限的规则。权限是纯粹累加的（不存在拒绝某操作的规则）。 角色可以用 Role 来定义到某个命名空间上， 或者用 ClusterRole 来定义到整个集群作用域。

也就是说：
- kubernetes 的权限不是直接绑定在用户上的
- 而实 某些权限先赋予 Role 和 ClusterRole
- 然后 Role 和 ClusterRole 在通过 RoleBinding 和 ClusterRoleBinding 绑定在用户上


### Role

一个 Role 只可以用来对某一命名空间中的资源赋予访问权限。

例如：john用户实在 ns1 命名空间中创建的角色，并且有get、create、delete等权限，但是 john用户只能在该 ns1 中进行这些操作，如果在ns2中则没有任何权限。

下面的 Role 示例定义到名称为 "gsh"的命名空间，可以用来授予对该命名空间中的 Pods 的读取权限：
```
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: gsh
  name: pod-reader
rules:
- apiGroups: [""] # "" 指定核心 API 组
  resources: ["pods", "services"]
  verbs: ["get", "watch", "list"]
```

说明：
- metadata 中的 namespace 指定该 role 创建在哪个命名空间下，也就指明了只能对 该命名空间 中资源的限制
- resources : 表示对该命名空间下的哪些资源进行限制
- verbs : 表示权限的具体行为
- apiGroups : 不同的资源都有不同的apiVersion
    - 例如：app/v1 ，其中 app 表示 apiGroup，v1表示 version
    - 如果 apiGroups 为空，那么只能匹配 v1 的资源
    - 注意：apiGroups 设置了以后，apiGroups 可能包括很多资源，这就需要在 resources 中定义具体的 资源了。
- role 也可以通过命令行创建：`kubectl create role -h`




### RoleBinding

**RoleBinding**
- 角色绑定（RoleBinding）是将Role中定义的权限赋予一个或者一组用户。
- RoleBinding 包含若干主体（用户，组和服务账户）的列表和对这些主体所获得的角色的引用。
- 可以使用 RoleBinding 在指定的命名空间中执行授权， 或者在集群范围的命名空间使用 ClusterRoleBinding 来执行授权。



一个 RoleBinding 可以引用同一的命名空间中的 Role 。 

下面的例子 RoleBinding 将 "pod-reader" 角色授予在 "default" 命名空间中的用户 "john"； 这样，用户 "john" 就具有了读取 "default" 命名空间中 pods 的权限。

```
apiVersion: rbac.authorization.k8s.io/v1
# 此角色绑定使得用户 "john" 能够读取 "gsh" 命名空间中的 Pods
kind: RoleBinding
metadata:
  name: read-pods
  namespace: gsh
subjects:
- kind: User
  name: john            # 名称区分大小写
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role            #必须是 Role 或者 ClusterRole
  name: pod-reader      # 这里的名称必须与你想要绑定的 Role 或 ClusterRole 名称一致
  apiGroup: rbac.authorization.k8s.io
```

注意：
- RoleBing 目的就是将 subjects 中的类型 与 roleRef 中定义的 角色绑定在一起
- subjects : 表示role需要绑定在什么对象上，其中kind有三种类型：
    - User
    - Group
    - ServiceAccount
- roleRef : 表示实际创建绑定到哪个role。
    - kind 可以是 Role 或 ClusterRole
    - name 将引用你要指定的 Role 或 ClusterRole 的名称。
    - 该例子中，就是将 pod-reader 的role绑定在 john 用户上。
- RoleBinding 也可以引用 ClusterRole。对 ClusterRole 所定义的、位于 RoleBinding 命名空间内的资源授权
- RoleBinding 也可以通过命令行创建：`kubectl create rolebinding -h`

示例：
- 因为已经在 10.113.71.132 机器上 添加了kubeconfig 文件，而之前手动创建 kubeconfig文件时，是将 john 用户于 cluster-admin 绑定的，因此具有所有权限，现在删掉之前的 clusterrolebinding，新建role和john绑定

```
[root@k8s-master role]# cat test-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: gsh
  name: pod-reader
rules:
- apiGroups: [""] # "" 指定核心 API 组
  resources: ["pods", "services"]
  verbs: ["get", "watch", "list"]
  
[root@k8s-master role]# cat test-rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: gsh
subjects:
- kind: User
  name: john            # 名称区分大小写
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role            #必须是 Role 或者 ClusterRole
  name: pod-reader      # 这里的名称必须与你想要绑定的 Role 或 ClusterRole 名称一致
  apiGroup: rbac.authorization.k8s.io

//  apply 以后
[root@k8s-master learn-k8s]# kubectl get role
NAME         CREATED AT
pod-reader   2020-10-25T12:48:03Z
[root@k8s-master learn-k8s]# kubectl get rolebindings.rbac.authorization.k8s.io
NAME        ROLE              AGE
read-pods   Role/pod-reader   6m25s


//  再次到 10.113.71.132 上，使用拷贝过来的 kubeconfig 文件创建资源时，就没有权限
[root@k8s-node-2 kubeconfig]# kubectl apply -f nginx.yaml
Error from server (Forbidden): error when creating "nginx.yaml": pods is forbidden: User "john" cannot create resource "pods" in API group "" in the namespace "gsh"

```



## ClusterRole 和 ClusterRoleBinding

### ClusterRole

ClusterRole 可以授予的权限和 Role 相同， 但是因为 ClusterRole 属于集群范围。

也就是说，ClusterRole 是在整个集群范围内的，而 Role 则是限制在某个 命名空间下。

可以赋予的权限有：
- 集群范围资源 （比如 nodes）
- 非资源端点（比如 "/healthz"）
- 跨命名空间访问的有名字空间作用域的资源
    - 如 Pods，比如运行命令kubectl get pods --all-namespaces 时需要此能力


下面的 ClusterRole 示例可用来对某特定命名空间下的 Secrets 的读取操作授权， 或者跨所有命名空间执行授权（取决于它是如何绑定的）:
```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  # 此处的 "namespace" 被省略掉是因为 ClusterRoles 是没有命名空间的。
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]
```


### ClusterRoleBinding

ClusterRoleBinding 和 RoleBinding 的用法一致


ClusterRoleBinding 可用来在集群级别或对所有命名空间执行授权。

下面的例子允许 "manager" 组中的任何用户读取任意命名空间中 "secrets"。
```
apiVersion: rbac.authorization.k8s.io/v1
# 这个集群角色绑定允许 "manager" 组中的任何用户读取任意命名空间中 "secrets"。
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager # 名称区分大小写
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

## 注意：
- 不能修改绑定对象所引用的 Role 或 ClusterRole 。 
- 试图改变绑定对象的 roleRef 将导致验证错误。
- 想要 改变现有绑定对象中 roleRef 字段的内容，必须删除并 重新创建绑定对象。


# ServiceAccount

kubernetes 中有两种用户：
- user account : 是 kubectl 用来远程登录使用的
- service account : 表示 某个 pod 以哪个 ServiceAccount 运行，可以给 ServiceAccount 一定的权限，那么这个 pod 中的进程就对kubernetes集群有相关的集群。

注意：
- 用户账户是针对人而言的。 服务账户是针对运行在 pod 中的进程而言的。
- 没创建一个 ServiceAccount，都会自动创建一个 secret 与之对应
- 创建一个 ServiceAccount，是没有任何权限的，与 用户 user 对应，必须将 ServiceAccount 和 一个 有一些权限的 role 或 clusterrole 绑定。


**创建 sa 的方法有两种：**
- 命令行方式：`kubectl create sa 名称`
- yaml 文件形式，模板为：
```
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: admin
  namespace: kube-system
```


**将sa与role绑定**
- 命令行方式：`kubectl create clusterrolebinding 名称 --clusterrole=pod-reader --serviceaccount=命名空间:sa名称`
- yaml 文件格式创建，模板为：
```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: ServiceAccount
  name: sa名称
  namespace: sa所在的命名空间
roleRef:
  kind: ClusterRole
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```


**将某个pod设置sa**
- 命令行方式设置：`kubectl set serviceaccount deployment 控制器名称 sa名称`。注意：只能对控制器设置，不能对pod设置
- yaml 文件形式，模板为:
    - 在 1.6 以上版本中，你可以通过在服务账户上设置 automountServiceAccountToken: false 来实现不给服务账号自动挂载 API 凭据：
- 绑定了 sa 的 pod 就有了 对集群管理的一些权限
```
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  serviceAccountName: build-robot
  automountServiceAccountToken: false
  ...
```