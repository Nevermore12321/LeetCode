[toc]



#  网络策略(NetworkPolicy) 简介


## 网络策略

> 网络策略（NetworkPolicy）是一种关于 Pod 间及与其他网络端点间所允许的通信规则的规范。

**NetworkPolicy 资源使用 标签 选择 Pod，并定义选定 Pod 所允许的通信规则**。

注意：
- <u>网络策略通过网络插件 来实现</u>。
- <u>网络策略也就相当于防火墙</u>
- 要使用网络策略，用户必须使用支持 NetworkPolicy 的网络解决方案。例如 calico 
- 创建一个资源对象，而没有控制器来使它生效的话，是没有任何作用的。



## 隔离和非隔离的 Pod

1. **非隔离 Pod**
    - 默认情况下，Pod 是非隔离的，它们接受任何来源的流量。
2. **隔离 Pod**
    - <u>Pod 可以通过相关的网络策略进行隔离。</u>
    - 只有满足特定规则的客户端才能访问特定的 Pod
    - 一旦命名空间中有网络策略选择了特定的 Pod， 该 Pod 会拒绝网络策略所不允许的连接。 （命名空间下其他未被网络策略所选择的 Pod 会继续接收所有的流量）
    - 隔离隔离是双向的，有 ingress 和 egress
3. **网络策略不会冲突，它们是累积的**。 
    - 如果任何一个或多个策略选择了一个 Pod,  则该 Pod 受限于这些策略的 ingress/egress 规则的并集。因此评估的顺序并不会影响策略的结果。


# NetworkPolicy 资源

## NetworkPolicy 创建

通过 yaml 文件创建 NetworkPolicy 资源，yaml 文件模板为：
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
    - namespaceSelector:
        matchLabels:
          project: myproject
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 6379
  egress:
  - to:
    - ipBlock:
        cidr: 10.0.0.0/24
    ports:
    - protocol: TCP
      port: 5978
```

说明：
- `podSelector` : 
    - 每个 NetworkPolicy 都包括一个 podSelector 
    - 对该策略所应用的一组 Pod 进行选择。
    - <u>空的 podSelector 选择命名空间下的所有 Pod。</u>
- `policyTypes` : 
    - 每个 NetworkPolicy 都包含一个 policyTypes 列表，其中包含 Ingress 或 Egress 或两者兼具。
    - policyTypes 字段表示给定的策略是否应用于进入所选 Pod 的入口流量或者来自所选 Pod 的出口流量，或两者兼有。
    - 如果 NetworkPolicy 未指定 policyTypes 则默认情况下始终设置 Ingress，如果 NetworkPolicy 有任何出口规则的话则设置 Egress。
- `ingress` : 
    - 每个 NetworkPolicy 可包含一个 ingress 规则的白名单列表。
    - 每个规则都允许同时匹配 from 和 ports 部分的流量。也就是同时满足
- `egress` : 
    - 每个 NetworkPolicy 可包含一个 egress 规则的白名单列表。
    - 每个规则都允许匹配 to 和 port 部分的流量。也就是同时满足
- `ingress.from` 或 `egress.to` 中，可以指定选择器:  
    - `podSelector` : 表示选择哪些 Pod 允许作为入口源或出口目的地。
    - `namespaceSelector` : 选择特定的命名空间，允许作为入口或出口
    - `ipBlock` : 这将选择特定的 IP CIDR 范围以用作入口源或出口目的地。 

注意：
- 如果是 list，**条件表示或**，即 Pod 有标签，或 namespace 有标签，例如：
```yaml
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          user: alice
    - podSelector:
        matchLabels:
          role: client
```
- 如果是 在同一目录下, **条件表示与**，即 Pod 有标签，并且该 Pod 所在的 namespace 也有标签。
```yaml
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          user: alice
      podSelector:
        matchLabels:
          role: client
```

- 默认策略
    - 如果没有策略，则允许所有数据包通过
    - 如果定义了一个策略，但是没有任何规则，则是拒绝所有的协议（icmp,tcp,udp）及所有的客户端全部拒绝了
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
spec:
  podSelector: {}   # 给所有 pod 添加规则
  policyTypes:
  - Ingress         # 没有指明规则，表示拒绝所有
```



## NetworkPolicy 实际例子


1. 创建 两个 pod ，标签分别为 name=pod1 和 name=pod2
```shell
[root@k8s-master network]# kubectl run pod1 --image=nginx --image-pull-policy=IfNotPresent --labels="name=pod1"
pod/pod1 created
[root@k8s-master network]# kubectl run pod2 --image=nginx --image-pull-policy=IfNotPresent --labels="name=pod2"
pod/pod2 created

[root@k8s-master network]# kubectl get pods --show-labels
NAME   READY   STATUS    RESTARTS   AGE   LABELS
pod1   1/1     Running   0          27s   name=pod1
pod2   1/1     Running   0          11s   name=pod2

```

2. 为两个 pod 分别创建两个  svc
```shell
[root@k8s-master network]# kubectl expose pod pod1 --name=svc1 --port=80 --type=NodePort
service/svc1 exposed
[root@k8s-master network]# kubectl expose pod pod2 --name=svc2 --port=80 --type=NodePort
service/svc2 exposed

[root@k8s-master network]# kubectl get svc
NAME   TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
svc1   NodePort   10.99.188.8    <none>        80:31388/TCP   26s
svc2   NodePort   10.108.62.66   <none>        80:30668/TCP   16s

```

3. 新创建 busybox pod 来访问 这两个svc，两个 svc 都可以访问, 测试 pod 的标签为 run=test 
```shell
[root@k8s-master network]# kubectl run pod-test --image=nginx --labels="run=test" --image-pull-policy=IfNotPresent
pod/pod-test created
[root@k8s-master network]# kubectl get pods
NAME       READY   STATUS    RESTARTS   AGE
pod-test   1/1     Running   0          3s
pod1       1/1     Running   0          12m
pod2       1/1     Running   0          12m

[root@k8s-master network]# kubectl exec -it pod-test -- bash
root@pod-test:/# curl svc1
pod1
root@pod-test:/# curl svc2
pod2
root@pod-test:/#

```

4. 创建网络策略资源，对 pod1 做限制
```shell
[root@k8s-master network]# cat network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: my-policy
spec:
  podSelector:
    matchLabels:
      name: pod1                # 该策略应用到 pod1 上
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: admin           # 访问 pod1 必须有 role=admin 的标签
    ports:
    - protocol: TCP
      port: 80


//  创建 网络策略
[root@k8s-master network]# kubectl apply -f network-policy.yaml
networkpolicy.networking.k8s.io/my-policy created
[root@k8s-master network]# kubectl get networkpolicies.networking.k8s.io
NAME        POD-SELECTOR   AGE
my-policy   name=pod1      18s


//  再次进入到 测试 pod pod-test 中验证，发现 pod1 不能访问，pod2 正常访问
[root@k8s-master network]# kubectl exec -it pod-test -- bash
root@pod-test:/# curl svc2
pod2
root@pod-test:/# curl svc1
curl: (7) Failed to connect to svc1 port 80: Connection refused

```

5. 给 测试 pod pod-test 添加标签 role=admin
```shell
//  添加标签
[root@k8s-master network]# kubectl label pod pod-test role=admin
pod/pod-test labeled
[root@k8s-master network]# kubectl get pods --show-labels
NAME       READY   STATUS    RESTARTS   AGE   LABELS
pod-test   1/1     Running   0          20m   role=admin,run=pod-test
pod1       1/1     Running   0          33m   name=pod1
pod2       1/1     Running   0          33m   name=pod2

// 再次进入 pod-test 中测试，svc1 svc2 都可以访问了
[root@k8s-master network]# kubectl exec -it pod-test -- bash
root@pod-test:/#
root@pod-test:/# curl svc1
pod1
root@pod-test:/# curl svc2
pod2


```