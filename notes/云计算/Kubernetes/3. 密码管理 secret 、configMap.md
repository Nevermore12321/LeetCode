[toc]



# Secret

## secret 概念
- Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象.
- secret 可以被用户创建在不同的namespace下
- secret 可以作为volume挂载到一个或多个容器上
- secret 还可以作为容器的环境变量使用
- secret 创建的内容都是经过 base64 编码后得到的

**secret 类型**：
1. Opaque : base64 编码格式的secret，用来存储密码、密钥等。都是通过base64编码和解码得到，加密行很弱
2. kubernetes.io/dockerconfigjson : 用来存储私有 docker registry 的认证信息
3. kubernetes.io/service-account-token : 用于被 serviceaccount 引用。serviceaccount 创建时 kubernetes 会默认创建对应的 secret 。pod 如果使用了serviceaccount，对应的 secret 会自动挂载到Pod的目录：/run/secret/kubernetes.io/serviceaccount



## 使用命令行创建 secret

1. 查看 创建 secret 的命令帮助
```
kubectl create secret generic --help
```
2. 通过变量的形式创建
    - `--from-literal` 选项
    - `kubectl create secret generic mysecret1 --from-literal=name1=gsh1 --from-literal=name2=gsh2`
```
[root@k8s-master pv-pvc]# kubectl create secret generic mysecret1 --from-literal=name1=gsh1 --from-literal=name2=gsh2
secret/mysecret1 created
[root@k8s-master pv-pvc]# kubectl get secrets
NAME                  TYPE                                  DATA   AGE
mysecret1             Opaque                                2      29s

```

3. 通过文件的形式创建
    - `--from-file` 选项
    - `kubectl create secret generic mysecret2 --from-file=./username.txt --from-file=./password.txt`
    - 这里创建的 key-value 值，key 为 文件名，value 为 文件内容的base64编码结果
```
[root@k8s-master secret]# echo -n 'admin' > ./username.txt
[root@k8s-master secret]# echo -n '1f2d1e2e67df' > ./password.txt

[root@k8s-master secret]# kubectl create secret generic mysecret2 --from-file=./username.txt --from-file=./password.txt
secret/mysecret2 created
[root@k8s-master secret]# kubectl get secrets
NAME                  TYPE                                  DATA   AGE
default-token-scvns   kubernetes.io/service-account-token   3      8d
mysecret1             Opaque                                2      26m
mysecret2             Opaque                                2      4s

[root@k8s-master secret]# kubectl get secrets mysecret2 -o yaml | head -5
apiVersion: v1
data:
  password.txt: MWYyZDFlMmU2N2Rm
  username.txt: YWRtaW4=
kind: Secret

```
4. 通过变量文件形式创建
    - `--from-file` 选项
    - `kubectl create secret generic mysecret3 --from-env-file=./env.txt`
    - 变量文件 格式 需要为 key=value
```
[root@k8s-master secret]# cat env.txt
envKey=envValue
[root@k8s-master secret]# kubectl create secret generic mysecret3 --from-env-file=./env.txt
secret/mysecret3 created

[root@k8s-master secret]# kubectl get secrets mysecret3 -o yaml | head -5
apiVersion: v1
data:
  envKey: ZW52VmFsdWU=
kind: Secret
metadata:

```

## 使用yaml文件创建 secret

**模板为**：
```
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
stringData:
  username1: administrator
```

注意：   
- data 下 的 value 值 需要经过 base64 编码
- stringData 下的 value 值 可以直接自定义字符串



## pod 中使用 secret

pod 中使用secret 有两种方式：
1. 以卷的方式来挂载
    - 主要用于传递配置文件
2. 以变量的方式来挂载
    - 主要用于给pod传递环境变量


1. 以卷的方式挂载

**将生成的 secret 以volume挂载到pod中，模板为**：
```
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: nginx
    volumeMounts:
    - name: myvolume
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: myvolume
    secret:
      secretName: mysecret1
```

说明：
- 就是将 mysecret1 的value 映射到 /etc/foo/ 目录 中
- 目录下会有 secret 中定义的key作为文件名，value作为文件内容
- 这种方式可以作为配置文件，直接传入到 pod 中
- readOnly = true， 表示为只读
- 也可以只挂载 secret 中的一个 key-value，方法：
    - 在 `mountPath: "/etc/foo"` 这里指定具体的key名称：`mountPath: "/etc/foo/username"`


**将 Secret 键名映射到特定路径，模板为**：
```
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
      - key: password
        path: my-group/my-password
```
说明：
- username Secret 存储在 /etc/foo/my-group/my-username 文件中而不是 /etc/foo/username 中。
- password Secret 存储在 /etc/foo/my-group/my-password 文件中而不是 /etc/foo/password 中。
- items 只定义了两个 key-value，因此只挂载这两个，其余不挂载



2. 以环境变量的方式挂载

**通过环境变量的方式挂载，模板为：**
```
apiVersion: v1
kind: Pod
metadata:
  name: secret-env-pod
spec:
  containers:
  - name: mycontainer
    image: redis
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
  restartPolicy: Never
```


说明：
- 修改 Pod 定义，为每个要使用 Secret 的容器添加对应 Secret 键的环境变量。 使用 Secret 键的环境变量应在 env[x].valueFrom.secretKeyRef 中指定 要包含的 Secret 名称和键名。





# configMap

用来将非机密性的数据保存到健值对中，使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。


configMap 的使用方法与 Secret 一致，但是 configMap不会经过base64的编码和解码

## 使用命令行创建 configMap

1. 查看创建configMap的命令帮助
```
kubectl create configmap --help
```
2. 使用选项，与 secret 一样，这里不在赘述
    - `--from-file` 通过文件
    - `--from-env-file` 通过配置文件
    - `--from-literal` 通过 变量
3. 例子：
```
kubectl create configmap myconfig1 --from-env-file=./env.txt
kubectl create configmap myconfig2 --from-literal=k1=v1
kubectl create configmap myconfig3 --from-file=./username.txt
```

## pod 使用 configMap
1. volume
2. env环境变量

模板为:
```
apiVersion: v1
kind: Pod
metadata:
  name: configmap-demo-pod
spec:
  containers:
    - name: demo
      image: game.example/demo-game
      env:
        - name: PLAYER_INITIAL_LIVES # 请注意这里和 ConfigMap 中的键名是不一样的
          valueFrom:
            configMapKeyRef:
              name: myconfig2           # 这个值来自 ConfigMap
              key: player_initial_lives # 需要取值的键
        - name: UI_PROPERTIES_FILE_NAME
          valueFrom:
            configMapKeyRef:
              name: myconfig3
              key: ui_properties_file_name
      volumeMounts:
      - name: config
        mountPath: "/config"
        readOnly: true
  volumes:
    - name: config
      configMap:
        name: myconfig1
```