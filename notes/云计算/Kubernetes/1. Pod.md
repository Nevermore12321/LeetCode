[toc]


# Pod 简单介绍

- Pod 是最小的调度单位，Pod里面包含的是容器
- Pod 中可以有一个容器，也可以有多个容器
- pod 是最终对外提供服务的
- 所有的资源都是以命名空间进行隔离的


# Pod 的创建

## 1. 通过命令的方式创建
`kubectl run`
常用的选项：
```bash
kubectl run NAME --image=image [--env="key=value"] [--port=port] [--labels="aa=bb"] [--dry-run=server|client] [--overrides=inline-json] [--image-pull-policy=IfNotPresent]
[--command] -- [COMMAND] [args...] [options]
```
其中：
- `--image` 必须，pod的镜像
- `--env` 可选，表示传入容器的环境变量
- `--port` 可选，表示使用的port端口
- `--dry-run`
     - client: 仅仅打印输出，但并不实际创建pod，检查yaml文件的格式是否正确
     - server: 实际创建
- `--overrides` 可选， 表示覆盖的 pod 的json文件，例如：`--overrides='{ "apiVersion": "v1", "spec": { ... } }'`
- `--image-pull-policy` 可选，镜像下载策略：
    - Always： 不管本地有没有镜像，都要去下载
    - IfNotPresent： 如果本地有，则优先使用本地镜像，如果没有镜像，就去下载
    - Never：从不去下载镜像
- `--command` 可选，表示执行的命令
- `--labels` 可选，添加 标签




示例：
```
[root@k8s-master ~]# kubectl run nginx --image=nginx --port=80 --image-pull-policy=IfNotPresent --env="name=gsh" --labels="aa=bb"
pod/nginx created
[root@k8s-master ~]# kubectl get pods
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          5s

```


## 2. 以yaml文件的方式创建

可以通过 dry-run 和 -o yaml 生成一个简单的模板
```
[root@k8s-master learn-k8s]# kubectl run nginx --image=nginx --port=80 --image-pull-policy=IfNotPresent --env="name=gsh" --labels="aa=bb" --dry-run=client -o yaml > nginx.yaml
[root@k8s-master learn-k8s]# cat nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    aa: bb
  name: nginx
spec:
  containers:
  - env:
    - name: name
      value: gsh
    image: nginx
    imagePullPolicy: IfNotPresent
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

```

注意： 
- yaml缩进是两个空格
- 以驼峰格式命名，并且key的首字母小写，value的首字母大写
- apiVersion不同的资源使用不通的apiVersion，可以使用此命令查看所有的apiVersion: `kubectl api-version`
- 如果不知道yaml中的属性，可以使用此命令查看：`kubectl explain pod`
- 如果查看 pod下的具体某个属性下的具体属性，可以使用：`kubectl explain pod.spec.containers`


示例：
```
[root@k8s-master learn-k8s]# cat nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    aa: bb
  name: nginx
  namespace: gsh
spec:
  containers:
  - env:
    - name: name
      value: gsh
    image: nginx
    imagePullPolicy: IfNotPresent
    command:
    - sh
    - -c
    - echo OK && sleep 1000
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

[root@k8s-master learn-k8s]# kubectl apply -f nginx.yaml
pod/nginx created
[root@k8s-master learn-k8s]# kubectl get pods
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          3s
[root@k8s-master learn-k8s]# kubectl logs nginx
OK

```

注意： 
- command 就是代替 容器的默认 执行命令
- command 与 args 相同含义，可以用 args 替换




# Pod 的常用命令

1. 查看 Pod 分配在了哪个节点上
    - `kubectl get pods -o wide`
```
[root@k8s-master ~]# kubectl get pods -o wide
NAME    READY   STATUS    RESTARTS   AGE   IP          NODE         NOMINATED NODE   READINESS GATES
nginx   1/1     Running   43         12h   10.10.2.5   k8s-node-2   <none>           <none>

```

2. 查看pod 的属性
    - `kubectl describe pod nginx`
```
[root@k8s-master ~]# kubectl describe pod nginx
Name:         nginx
Namespace:    gsh
Priority:     0
Node:         k8s-node-2/10.113.71.132
Start Time:   Thu, 10 Sep 2020 22:40:42 +0800
Labels:       aa=bb
Annotations:  <none>
Status:       Running
IP:           10.10.2.5
IPs:
  IP:  10.10.2.5
Containers:
  nginx:
...
```

3. 在pod中执行shell命令
    - `kubectl exec nginx -- shell 命令`
    - 注意: 如果 pod 中有多个容器，想默认 exec 进入到 第一个容器，称为主容器，后面的称为sidecar
    - 如果想进入指定容器，可以使用 -c 选项 `kubectl exec nginx -c 荣启铭 -- shell 命令`
```
[root@k8s-master ~]# kubectl exec nginx -- echo ok
ok
```

4. 以 伪终端的形式 进入到 pod中执行shell命令
    - ` kubectl exec -it nginx -- /bin/bash`
    - 进入指定的容器： ` kubectl exec -it nginx -c 容器名 -- /bin/bash`
```
[root@k8s-master ~]# kubectl exec -it nginx -- /bin/bash
root@nginx:/# pwd
/

```

5. 拷贝文件到 pod中，或者从pod中拷贝文件出来
    - `kubectl cp 本机文件名 Pod名:Pod目录` -> 从本机拷贝到容器
    - `kubectl cp Pod名:Pod文件目录 本机目录` -> 从容器拷贝到本地
```
[root@k8s-master learn-k8s]# kubectl cp nginx.yaml nginx:/tmp
[root@k8s-master learn-k8s]# kubectl exec nginx -- ls /tmp
nginx.yaml

```

6. 查看pod的log 输出
    - `kubectl logs pod名·
```
[root@k8s-master learn-k8s]# kubectl logs nginx
OK

```

# Pod 的删除
1. `kubectl delete pod nginx` -> 直接删除某个pod
2. `kubectl delete -f nginx.yaml` -> 从创建的 yaml 文件 直接删除所有指定的资源

优雅的删除Pod：
- kubectl 删除pod 其实是发送一个 SIGTERM 信号给容器，让容器关闭进程
- k8s 里默认设置了30s的时间等待容器 关闭进程，也就是等待30s后，在删除容器，如果容器中的进程30s内没有关闭，则会强制关闭
- 如果在30s内，容器已经关闭进程，则会直接删除容器，可以通过容器的 lifecycle 来控制容器的关闭




操作：
- 可以通过 kubectl delete 命令后加上 --grace-period 选项，例如:
```
[root@k8s-master learn-k8s]# kubectl delete -f nginx.yaml --grace-period=0
pod "nginx" deleted

```
- 也可以通过在配置文件中加入，spec 下的 terminationGracePeriodSeconds 属性，来配置等待时间，默认30s


# Pod 的生命周期

Pod 的生命周期，有两个 hook，分别是：
- postStart: 
    - 表示当容器启动起来后，就运行的一些操作
    - postStart 这个进程，和主进程是同时进行的，也就是异步的。
- preStop:  
    - 表示当容器关闭之前，运行的一些操作
    - 如果 preStop 没有完成，Pod 是不会被删除的



使用方法：
- 在yaml文件中添加lifecycle
- 属性位置： pod.spec.containers.lifecycle
- postStart 和 preStop 下又有两种方法，分别是
    - exec：执行命令
    - httpGet：使用发送http消息来访问某个地址
    - tcpSocket：使用发送tcp消息来访问某个地址


示例：

```
[root@k8s-master learn-k8s]# cat nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    aa: bb
  name: nginx
  namespace: gsh
spec:
  containers:
  - env:
    - name: name
      value: gsh
    image: nginx
    imagePullPolicy: IfNotPresent
    lifecycle:
      postStart:
        exec:
          command:
          - /bin/sh
          - -c
          - sleep 5 ; echo $(date) >> /a.txt
      preStop:
        exec:
          command:
          - /bin/sh
          - -c
          - /usr/sbin/nginx -s quit
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}



[root@k8s-master learn-k8s]# kubectl apply -f nginx.yaml
pod/nginx created

[root@k8s-master learn-k8s]# kubectl get pods
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          30s

# 可以看到 postStart 的命令执行了
[root@k8s-master learn-k8s]# kubectl exec nginx -- cat /a.txt
Fri Sep 11 06:56:07 UTC 2020

```

# pod 的端口暴露

例如：
```
ports:
- protocol: TCP
  hostPort: 80
  targetPort: 9376
```

说明：
- targetPort : 这个是容器中监听的端口，也就是 9376
- hostPort : 这个是讲容器的端口映射到物理机的端口，也就是将容器的 9376 映射到物理机的 80 端口（与服务中的port相同）


# pod 的重启策略

在yaml文件中的 pod.spec.restartPolicy 字段，有三种情况：
- Always ： Pod里的进程执行完了，不管正常或者异常，都回重新执行
- OnFailure ： pod里的进程执行完了，如果异常退出，则会重新执行，如果正确退出，则不会重启
- Never ： 完全不会重启



# init 初始化容器

初始化容器的步骤：
- 一个容器A依赖其他容器，可以为A设置多个依赖容器A1，A2，A3
- A1,A2,A3 要按照顺序启动，A1没有启动启动起来的话，A2,A3是不会启动的，直到所有的容器全部启动完毕，主容器A才会启动。
- 这里可以把A1，A2，A3 设置为初始化容器


注意：  
> 初始化容器失败，则会一直重启，后续的初始化容器不会执行，pod不会创建。
> 只有所有的初始化容器执行完毕，才会创建普通容器，Pod 才会创建。


使用方法：
- pod.spec.initContainers 属性，来定义初始化容器
- 注意：容器中可以修改本机的内核属性的，但是必须设置 
```
spec:
  initContainers:
    - image: alpine
    ...
    securityContext:
      privileged: true
```


示例：
```
[root@k8s-master learn-k8s]# cat nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    aa: bb
  name: nginx
  namespace: gsh
spec:
  initContainers:
  - image: alpine:latest
    name: initc1
    imagePullpolicy: IfNotPresent
    command:
    - /bin/sh
    - -c
    - /sbin/sysctl -w "vm.swappiness=0"
    securityContext:
      privileged: true
    resources: {}
  containers:
  - env:
    - name: name
      value: gsh
    image: nginx
    imagePullPolicy: IfNotPresent
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

```


**初始化容器的规则**
1. 它们总是运行到完成。
2. 每个都必须在下一个启动之前成功完成。
3. 如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的
restartPolicy 为 Never，它不会重新启动。
4. Init 容器支持应用容器的全部字段和特性，但不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完
成。
5. 如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。 每个 Init 容器必须运行成功，下一个
才能够运行。
6. 因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。 特别地，被写到
EmptyDirs 中文件的代码，应该对输出文件可能已经存在做好准备。
7. 在 Pod 上使用 activeDeadlineSeconds，在容器上使用 livenessProbe，这样能够避免 Init 容器一直失败。 这就
为 Init 容器活跃设置了一个期限。
8. 在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误。
9. 对 Init 容器 spec 的修改，被限制在容器 image 字段中。 更改 Init 容器的 image 字段，等价于重启该 Pod。




# 静态 Pod


- 静态pods是直接由特定节点上的kubelet进程来管理，不通过主控节点上的API服务器。
- 静态pod不关联任何replication controller，它由kubelet进程自己来监控，当pod崩溃时重启该pod。
- 对于静态pod没有健康检查。静态pod始终绑定在某一个kubelet，并且始终运行在同一个节点上。


方法：
- 在node节点上，找到kubelet的配置选项， --pod-manifest-path 选项，该选项指定的是 静态pod 的yaml文件存放的地址，步骤：
    - `systemctl status kubelet` -> 查看 kubelet 的配置文件地址
    - 修改配置文件，在Environment 中添加 `--pod-manifest-path=静态pod目录`
    - `systemctl daemon-reload`
    - `systemctl restart kubelet`
    - 在指定的目录下创建 pod 的yaml 文件，则 kubelet 会自动创建该pod，可以在master上查看，但是不由master管理，
    - 直接修改该yaml文件，保存后，会自动重建


# Pod 的调度

当创建一个 pod 时，scheduler 会根据自己的算法来决定pod在那个节点上运行。  
调度的三个对象有：
1. 带调度的pod列表
    - 也就是新创建的所有的pod列表
2. 可用的node列表
    - 也就是可以将pod创建在哪些node节点的列表
3. 调度算法
    - 主机过滤（label过滤）
    - 主机打分


**调度过程**
- 主机过滤算法，是去除掉一些不符合要求的节点，然后剩下的节点都符合主机过滤算法的要求。
- 主机过滤后，将所有的可用的node节点通过主机打分算法，每个节点根据cpu使用率、mem使用率等等参数打分，最终pod会调度在分值高的节点上。



## 1. 查看和指定node节点的标签

1. 查看node节点的标签
    - `kubectl get nodes --show-labels`
```
[root@k8s-master ~]# kubectl get nodes --show-labels
NAME         STATUS   ROLES    AGE   VERSION   LABELS
k8s-master   Ready    master   28h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/master=
k8s-node-1   Ready    <none>   28h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-1,kubernetes.io/os=linux
k8s-node-2   Ready    <none>   28h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-2,kubernetes.io/os=linux
k8s-node-3   Ready    <none>   28h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-3,kubernetes.io/os=linux

```

2. 为某个 node 节点添加标签
    - `kubectl label nodes node名称 标签名=标签值`
    - `kubectl label node --al 标签名=标签值` -> 为所有node添加标签
    - `kubectl label nodes node名称 标签名=标签值 --overwrite` -> 修改标签
```
[root@k8s-master ~]# kubectl label nodes k8s-node-1 disktype=ssd
node/k8s-node-1 labeled
[root@k8s-master ~]# kubectl get nodes --show-labels
NAME         STATUS   ROLES    AGE   VERSION   LABELS
k8s-master   Ready    master   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/master=
k8s-node-1   Ready    <none>   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,disktype=ssd,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-1,kubernetes.io/os=linux
k8s-node-2   Ready    <none>   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-2,kubernetes.io/os=linux
k8s-node-3   Ready    <none>   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-3,kubernetes.io/os=linux

```

3. 为某个 node 节点删除标签
    - `kubectl label nodes 节点名 标签名-`
```
[root@k8s-master ~]# kubectl label nodes k8s-node-1 disktype-
node/k8s-node-1 labeled
[root@k8s-master ~]# kubectl get nodes --show-labels
NAME         STATUS   ROLES    AGE   VERSION   LABELS
k8s-master   Ready    master   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/master=
k8s-node-1   Ready    <none>   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-1,kubernetes.io/os=linux
k8s-node-2   Ready    <none>   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-2,kubernetes.io/os=linux
k8s-node-3   Ready    <none>   29h   v1.19.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node-3,kubernetes.io/os=linux

```

## 2. 将 pod 调度到指定的node节点（标签选择）

方法：
- 在node节点上可以定义一些 label，例如在node1指定 disktype 为 ssd 的标签
```
kubectl label nodes k8s-node-1 disktype=ssd
```
- 在定义pod的yaml文件中，添加 nodeSelector 选择在指定label的node节点上调度pod，位置在pod.spec.nodeSelector 
```
[root@k8s-master learn-k8s]# cat nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    aa: bb
  name: nginx
  namespace: gsh
spec:
  nodeSelector:
    disktype: ssd
  containers:
  - env:
    - name: name
      value: gsh
    image: nginx
    imagePullPolicy: IfNotPresent
    lifecycle:
      postStart:
        exec:
          command:
          - /bin/sh
          - -c
          - sleep 5 ; echo $(date) >> /a.txt
      preStop:
        exec:
          command:
          - /bin/sh
          - -c
          - /usr/sbin/nginx -s quit
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

```
- 如果有多个node满足指定的标签，那就会在打分高的node上调度
- 如果没有node满足指定的标签，那就会报错


## 3. 将 pod 调度到指定的node节点（主机亲和性）

节点亲和通过 pod.spec 的 **affinity** 字段指定，有三种分别是
- nodeAffinity
- podAffinity
- podAntiAffinity



**注意**：  
两种类型的相同点在于后半部分： IgnoredDuringExecution。  
也就是说，如果某一个 Pod 所在的 Node 的 label 发生了变化，导致一些已经运行在该 Node 上的 Pod 不符合运行条件，那么这些 Pod 也不会受到影响。


### a. nodeAffinity

指定 node 的亲和性，也就是对node进行匹配和计算，有两个node亲和性策略：
- `requiredDuringSchedulingIgnoredDuringExecution` : 硬策略
    - 指定了将 pod 调度到一个节点上必须满足的规则
- `preferredDuringSchedulingIgnoredDuringExecution` : 软策略
    - 指定调度器将尝试执行但不能保证的偏好 

affinity.nodeAffinity 下路径以及说明：
- `requiredDuringSchedulingIgnoredDuringExecution` : 硬策略
    - `nodeSelectorTerms` : 必填，node选择的具体策略，列表
         - `matchExpressions` : 通过标签进行匹配
         - `matchFields` : 通过node 其他filed匹配
- `preferredDuringSchedulingIgnoredDuringExecution` : 软策略
    - `weight` : 设置该条件的权重，1-100
    - `preference` : 
         - `matchExpressions` : 通过标签进行匹配
         - `matchFields` : 通过node 其他filed匹配


`matchExpressions` 和  `matchFields` 下的属性有：
- `key` : label 或 field 的key名称，必填
- `operator` : 匹配的方法，有一下几种情况：
    - In：label 的值在某个列表中
    - NotIn：label 的值不在某个列表中
    - Gt：label 的值大于某个值
    - Lt：label 的值小于某个值
    - Exists：某个 label 存在
    - DoesNotExist：某个 label 不存在
- `values` : 列表，通过上面 operator 方法，匹配下面的值

示例：
1. 创建一个 deployment ，并且有在node亲和性nodeAffinity上有硬策略和软策略
2. 在 node-1 上 有标签 disktype=ssd
3. 硬策略是：kubernetes.io/hostname 必须是 node-1 和 node-2
4. 软策略是： 优先选择 disktype=ssd标签的 node
5. 结果应该是，优先在node-1上创建
```
[root@k8s-master learn-k8s]# cat web.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: web
  name: web
spec:
  replicas: 6
  selector:
    matchLabels:
      app: web
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: web
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: {}
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                - k8s-node-1
                - k8s-node-2
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            preference:
              matchExpressions:
              - key: disktype
                operator: In
                values:
                - ssd
status: {}
```

创建deployment，查看结果, 可以看到优先在 node-1 上创建
```
[root@k8s-master learn-k8s]# kubectl get pods -o wide
NAME                   READY   STATUS    RESTARTS   AGE   IP           NODE         NOMINATED NODE   READINESS GATES
web-7d77dd7b66-8zmwr   1/1     Running   0          25s   10.10.2.10   k8s-node-2   <none>           <none>
web-7d77dd7b66-dtb7v   1/1     Running   0          25s   10.10.1.6    k8s-node-1   <none>           <none>
web-7d77dd7b66-fcrls   1/1     Running   0          25s   10.10.1.8    k8s-node-1   <none>           <none>
web-7d77dd7b66-hk6kj   1/1     Running   0          25s   10.10.1.4    k8s-node-1   <none>           <none>
web-7d77dd7b66-s5snq   1/1     Running   0          25s   10.10.1.7    k8s-node-1   <none>           <none>
web-7d77dd7b66-zks7s   1/1     Running   0          25s   10.10.1.5    k8s-node-1   <none>           <none>

```


### a. podAffinity 和 podAntiAffinity

pod 的亲和性，也就是 基于 Pod 的 label 制定调度策略，而不是 Node 的 label。

用法与 nodeAffinity 相同


## 4. 调度，警戒线 cordon

如果把某个节点设置了cordon(警戒线)，则这个节点会被为不可调度，在创建新的pod的时候，是暴怒会在调度到这个node节点上的。

使用方法：
- 将某个节点设置为 cordon：
    - `kubectl cordon k8s-node-1`
    - 设置完后，该节点就会变成不可调度状态
    ```
    [root@k8s-master learn-k8s]# kubectl cordon k8s-node-1
    node/k8s-node-1 cordoned
    [root@k8s-master learn-k8s]# kubectl get nodes
    NAME         STATUS                     ROLES    AGE   VERSION
    k8s-master   Ready                      master   44h   v1.19.0
    k8s-node-1   Ready,SchedulingDisabled   <none>   44h   v1.19.0
    k8s-node-2   Ready                      <none>   43h   v1.19.0
    k8s-node-3   Ready                      <none>   43h   v1.19.0
    ```
- 然后再调度pod的时候，就会不在 该节点上
- 但不会影响 已经在该节点上构建好的 pod
- 将某个节点，取消 cordon
    - `kubectl uncordon k8s-node-1`


## 5. 调度，node驱逐：drain

如果 node 需要升级或者排错，这时候就需要将 该 node 上的所有pod安全的驱逐到其他node上，这就是 drain 的作用，用于节点的维护。


如果一个节点被设置为drain，则此节点不再被调度pod，
且此节点上已经运行的pod会被驱逐(evicted)到其他节点


方法：
- 将节点设为 drain 
    - `kubectl drain $NODENAME --ignore-daemonsets`
    - 可以看到该节点上的 pod 都为 evicted
    - 选项--ignore-daemonsets 表示Ignore DaemonSet-managed pods.
    ```
    [root@k8s-master learn-k8s]# kubectl drain k8s-node-1 --ignore-daemonsets
    node/k8s-node-1 cordoned
    WARNING: ignoring DaemonSet-managed Pods: kube-system/kube-flannel-ds-amd64-hdps7, kube-system/kube-proxy-6k5hr
    evicting pod gsh/web-6ff5d8dd4d-4ffn9
    evicting pod gsh/web-6ff5d8dd4d-g6n54
    evicting pod kube-system/coredns-f9fd979d6-wtqgs
    evicting pod gsh/web-6ff5d8dd4d-bgw2w
    pod/web-6ff5d8dd4d-g6n54 evicted
    pod/coredns-f9fd979d6-wtqgs evicted
    pod/web-6ff5d8dd4d-4ffn9 evicted
    pod/web-6ff5d8dd4d-bgw2w evicted
    node/k8s-node-1 evicted
    
    ```
- 将节点取消 不可调度状态，使用 uncordon
    - `kubectl uncordon k8s-node-1`


## 6. 调度： node的污点taint 及 pod的容忍性tolerations

1. 问题： kubeadm 安装的kubernetes集群中，master节点为什么不能调度pod？
    - 回答：master节点，被打上了污点taint，为不可调度，因此pod不往master节点上调度。而worker节点是没有污点的，因此可以调度pod。
    ```
    [root@k8s-master learn-k8s]# kubectl describe node k8s-master | grep Taints
    Taints:             node-role.kubernetes.io/master:NoSchedule
    [root@k8s-master learn-k8s]# kubectl describe node k8s-node-1 | grep Taints
    Taints:             <none>
    ```
2. 给一个node添加污点的方法:
    - `kubectl taint node <nodeName> keyName=valueName:NoSchedule`
    - 一般 key=value:NoSchedule 后加上 NoSchedule 表示该节点有污点不可调度
    - node节点加上污点后，如果pod不设置能够容忍 tolerations ，那么pod不会往该node上调度。
    ```
    [root@k8s-master learn-k8s]# kubectl taint node k8s-node-1 keyx=values:NoSchedule
    node/k8s-node-1 tainted
    [root@k8s-master learn-k8s]# kubectl describe node k8s-node-1 | grep Taints
    Taints:             keyx=values:NoSchedule
    
    [root@k8s-master learn-k8s]# kubectl get pods -o wide
    NAME                   READY   STATUS    RESTARTS   AGE   IP           NODE         NOMINATED NODE   READINESS GATES
    web-6ff5d8dd4d-2bq77   1/1     Running   0          25s   10.10.2.25   k8s-node-2   <none>           <none>
    web-6ff5d8dd4d-6vrpd   1/1     Running   0          25s   10.10.2.29   k8s-node-2   <none>           <none>
    web-6ff5d8dd4d-9mk7n   1/1     Running   0          25s   10.10.2.26   k8s-node-2   <none>           <none>
    web-6ff5d8dd4d-lc5wc   1/1     Running   0          25s   10.10.2.27   k8s-node-2   <none>           <none>
    web-6ff5d8dd4d-r8b8h   1/1     Running   0          25s   10.10.2.28   k8s-node-2   <none>           <none>
    web-6ff5d8dd4d-vwzb5   1/1     Running   0          25s   10.10.2.24   k8s-node-2   <none>           <none>
    
    ```
3. 将pod添加容忍性tolerations
    - 在pod的yaml文件中，添加 tolerations 的属性，位置为：pod.spec.tolerations
    - tolerations 下的定义方法，类似 matchExpressions 的定义方法，也是通过，key、operator、value、effect
    - effect就表示 定义 taint时，keyName:valueName:NoSchedule 冒号后面的值
    ```
    [root@k8s-master learn-k8s]# cat web.yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      creationTimestamp: null
      labels:
        app: web
      name: web
    spec:
      replicas: 6
      selector:
        matchLabels:
          app: web
      strategy: {}
      template:
        metadata:
          creationTimestamp: null
          labels:
            app: web
        spec:
          containers:
          - image: nginx
            name: nginx
            resources: {}
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                - matchExpressions:
                  - key: kubernetes.io/hostname
                    operator: In
                    values:
                    - k8s-node-1
                    - k8s-node-2
          tolerations:
          - key: keyx
            operator: Equal
            value: values
            effect: NoSchedule
    status: {}
    
    
    [root@k8s-master learn-k8s]# kubectl get pods -o wide
    NAME                   READY   STATUS    RESTARTS   AGE   IP           NODE         NOMINATED NODE   READINESS GATES
    web-7887db8758-8hq4d   1/1     Running   0          13s   10.10.1.19   k8s-node-1   <none>           <none>
    web-7887db8758-966sh   1/1     Running   0          13s   10.10.2.30   k8s-node-2   <none>           <none>
    web-7887db8758-9xjq2   1/1     Running   0          13s   10.10.1.18   k8s-node-1   <none>           <none>
    web-7887db8758-c2jkv   1/1     Running   0          13s   10.10.1.17   k8s-node-1   <none>           <none>
    web-7887db8758-nf9sw   1/1     Running   0          13s   10.10.2.31   k8s-node-2   <none>           <none>
    web-7887db8758-tql2v   1/1     Running   0          13s   10.10.2.32   k8s-node-2   <none>           <none>
    
    ```
4. 删除节点的污点
    -  `kubectl taint node <nodeName> keyNmae-`
    -  取消的方法，类似取消label 的方法，在key的后面加 减号 -
    ```
    [root@k8s-master learn-k8s]# kubectl taint node k8s-node-1 keyx-
    node/k8s-node-1 untainted
    [root@k8s-master learn-k8s]# kubectl describe node k8s-node-1 | grep Taints
    Taints:             <none>
    
    ```