# 虚拟化技术

[toc]

## 简介

所谓计算虚拟化：

- 从<u>狭义角度</u>可理解为**对单个物理服务器的虚拟化，主要包括对服务器上的CPU、内存、I/O设备进行虚拟化**，目的就是实现多个虚拟机能各自独立、相互隔离地运行于一个服务器之上。
- 从<u>广义角度</u>还可延伸到云资源池下，**各类资源池组网场景下的CPU、内存、I/O设备等资源进行整合、抽象和虚拟化。**



在没有虚拟化以前（我们抽掉Virtualization层） ， 一个物理的主机（Sever、 Storage、 Network层）上面只能支持一个操作系统及其之上的一系列运行环境和
应用程序； 有了虚拟化技术， 一个物理主机可以被抽象、 分割成多个虚拟的逻辑意义上的主机， 向上支撑多个操作系统及其之上的运行环境和应用程序， 则其资源可以被最大化地利用。  



物理资源虚拟化如下图所示：

![物理资源虚拟化示意图](https://github.com/Nevermore12321/LeetCode/blob/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90%E8%99%9A%E6%8B%9F%E5%8C%96.PNG?raw=true)

说明：

- 在没有虚拟化以前（我们抽掉Virtualization层） ， 一个物理的主机（Sever、 Storage、 Network层） 上面只能支持一个操作系统及其之上的一系列运行环境和应用程序；
-  有了虚拟化技术， 一个物理主机可以被抽象、 分割成多个虚拟的逻辑意义上的主机， 向上支撑多个操作系统及其之上的运行环境和应用程序， 则其资源可以被最大化地利用  

一个完整的服务器虚拟化平台从下到上包括以下几个部分，如下图所示：

- **底层物理资源**：包括网卡、CPU、内存、存储设备等硬件资源，一般<u>将包含物理资源的物理机称为宿主机（Host）</u>。
- **虚拟机监控器（Virtual Machine Monitor，VMM）**：<u>VMM 是位于虚拟机与底层硬件设备之间的虚拟层，直接运行于硬件设备之上，负责对硬件资源进行抽象，为上层虚拟机提供运行环境所需资源，并使每个虚拟机都能够互不干扰、相互独立地运行于同一个系统中。</u>
- **抽象化的虚拟机硬件**：即<u>虚拟层呈现的虚拟化的硬件设备</u>。虚拟机能够发现哪种硬件设施，完全由 VMM 决定。虚拟设备可以是模拟的真实设备，也可以是现实中并不存在的虚拟设备，如 VMware 的 vmxnet 网卡。
- **虚拟机**：相对于底层提物理机，也称为<u>客户机（Guest）</u>。<u>运行在其上的操作系统则称为客户机操作系统（Guest OS）</u>。每个虚拟机操作系统都拥有自己的虚拟硬件，并在一个独立的虚拟环境中执行。通过 VMM 的隔离机制，每个虚拟机都认为自己作为一个独立的系统在运行。

![虚拟化技术的分层结构图](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%BE.PNG)

Hypervisor 与 VMM （如下图）：

![VMM层Hypervisor功能](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/VMM%E5%B1%82Hypervisor%E5%8A%9F%E8%83%BD.PNG)

- Hypervisor 是位于虚拟机和底层物理硬件之间的虚拟层，包括 boot loader、x86 平台硬件的抽象层，以及内存与 CPU 调度器，负责对运行在其上的多个虚拟机进行资源调度。
- VMM 则是与上层的虚机一一对应的进程，负责对指令集、内存、中断与基本的I/O设备进行虚拟化。
- 当运行一个虚拟机时，Hypervisor 中的 vmkernel 会装载 VMM，虚拟机直接运行于 VMM 之上，并通过 VMM 的接口与 Hypervisor 进行通信。<u>而在 KVM 和 Xen 架构中，虚拟层都称为 Hypervisor，也就是 VMM=Hypervisor。</u>

如今市场上最多见的虚拟化软件有 VMWare workstation(VMWare)、VirtualBox(Oracle)、Hyper-V(Microsoft)、KVM(Redhat)、Xen等，这些软件统称之为VMM(Virtual Machine Monitor)，

## x86 CPU架构与虚拟化的关系

为确保操作系统能够安全地操作底层硬件，x86 平台使用了特权模式和用户模式的概念对内核程序与用户应用程序进行隔离。在这个模型下，CPU 提供了4个特权级别，分别是 Ring0、1、2和3。如下图所示：

![x86CPU架构](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/x86CPU%E6%9E%B6%E6%9E%84.PNG)

CPU 为了保证代码执行的安全性、多用户的独立性、保护 OS 的正常运行，实现了 CPU 执行状态的概念。这样能够限制不同程序之间的访问能力，避免一个程序获取另一个程序的内存数据，同时也避免了程序错误操作物理硬件。**一般 CPU 都会划分为用户态和内核态，x86 更是细分为了 Ring3~0 四种状态**。

- **Ring3 用户态(User Mode)**：
    - 运行在用户态的代码需要受到 CPU 的检查，这些代码只能访问内存页表项中规定能被用户态访问的页面的虚拟地址(受限的访问内存)，而且只能访问 TSS 中的 I/O Permission Bitmap 中规定能被用户态访问的端口。
    - 甚至不能访问外围设备、不能抢占 CPU。<u>所有的用户程序(Application)都运行在用户态</u>。—— **当运行在用户态的应用程序需要调用硬件设备时， CPU 会通过特别的接口去调用核心态的代码（系统调用），之后用户态的应用程序才能对硬件设备进行操作**。 
    - 如果用户态的应用程序直接调用硬件设备时，就会被 Host OS 捕捉到并触发异常。
- **Ring0 核心态(Kernel Mode)**：
    - **是 Host OS Kernel 运行的模式，运行在核心态的代码可以无限制的对系统内存、设备驱动程序、网卡接口、显卡接口等外围设备进行访问。**
    - 只有 Host OS 能够无限制的访问硬盘、键盘等外围硬件设备的数据(需要驱动程序)。
- <u>Ring 1、2 和 3权限依次降低。</u>

**CPU 架构与虚拟化**：

1. 为了满足 VMM 的“资源可控” 特征，VMM 必须处于 Ring 0 级别控制所有的硬件资源，并且执行最高特权系统调用。
2. **虚拟机操作系统 Guest OS 则要被降级运行在 Ring 1 级别**，故 Guest OS 在执行特权指令时都会引起 ”陷入“。如果 VMM 能够正常捕获异常，模拟 Guest OS 发出的指令并执行，就达到了目的。

**x86 的指令集有以下种**：

1. <u>访问或修改机器状态的指令</u>。
2. <u>访问或修改敏感寄存器或存储单元的指令， 比如访问时钟寄存器和中断寄存器</u>。
3. <u>访问存储保护系统或内存、地址分配系统的指令（段页之类）</u>。
4. <u>所有I/O指令</u>。

指令集说明：

- 1~4 在 x86 平台都属于敏感指令，第 1、4 类指令属于敏感指令中的特权指令，由操作系统内核执行，Guest OS 在执行两类指令时，因为不处于Ring 0 级别，所以会陷入，并抛出异常，这个异常会被 VMM 捕获，然后模拟 Gust OS 去执行，并将执行结果返回给 Guest OS。
- 到此为止，一切都OK。但是，第 2、3类 指令属于非特权指令，可以由应用程序调用，也就是可以在 Ring 3 级别执行，并调用 Guest OS 内核进程来完成。当应用程序调用这些指令时，由于要修改内存和内部寄存器，这些状态修改需要由 Guest OS 完成，而 Guset OS 此时运行在 Ring 1 级别，虽然也会发生陷入，但是不会抛出异常，这样 VMM 就捕获不到，也就无法模拟完成。
- 因此，当 Guest OS 执行这些指令就会导致虚拟机状态异常，甚至影响服务器的状态。在 x86 平台下，这类指令共有 19 个，也成为边界指令。
- 正是因为 x86 平台指令集有上述缺陷，所以为了计算虚拟化技术在 x86 平台应用，各大虚拟化厂商推出了五花八门的虚拟化技术，其目的都是围绕“如何捕获模拟这19条边界指令”这一命题来设计。在很长一段时间，都是通过软件的方式来解决这个问题，其中**包括无需修改内核的全虚拟化与需要修改内核的半虚拟化。**



## 虚拟化分类

### 1. 全虚拟化 Full Virtualization

全虚拟化，**不需要对 GuestOS 操作系统软件的源代码做任何的修改，就可以运行在这样的 VMM 中**，在全虚拟化的虚拟平台中，GuestOS 并不知道自己是一台虚拟机，它会认为自己就是运行在计算机物理硬件设备上的 HostOS。

<u>全虚拟化通过一层能够完整模拟物理硬件环境的虚拟软件，使得 Guest OS 与底层物理硬件彻底解耦。因此，Guest OS 无需任何修改，虚拟化的环境对其完全透明，也就是说在全虚方案中，虚拟机感知不到自己处于虚拟化环境中，认为自己一直运行在物理硬件上。</u>如下图所示：

![全虚拟化](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96.PNG)

【思考】全虚拟化如何实现？
【回答】**通常是结合特权指令的二进制翻译机制与一般指令的直接执行的方式**：

- 对于 Guest OS 发出的特权指令和边界指令，VMM 会进行实时翻译，并缓存结果（目的是提高虚拟化性能）
- 对于一般级别的指令，则无需 VMM 干涉，可以直接在硬件上执行

【思考】全虚拟化的软件实现用到了两个机制
【回答】全虚拟化通过软件模拟来实现 VMM 层（也叫做软件辅助的全虚拟化）， 通过纯软件的环境来模拟执行客户机里的指令。用到了两个机制：

- **特权解除**：
    - 即翻译，当 GuestOS 需要使用运行在核心态的指令时，<u>VMM 就会动态的将该指令捕获并调用若干的运行在非核心态的指令来模拟该核心态指令的效果，从而将核心态的特权解除</u>。
    - 因为在一个 OS 的指令集中还存在着一种敏感指令(可能是内核态，也可能是用户态)。此时就需要陷入模拟的实现。 
- **陷入模拟**：
    - HostOS 和 GuestOS 都含有敏感指令(reboot、shutdown等)，试想如果在 GuestOS 中执行了 reboot 指令，却将 HostOS 重启了，这将会非常糟糕。
    - 在 GuestOS 中执行了需要运行在内核态中的 reboot 指令，VMM 首先会将 reboot 指令获取、检测并判定为敏感指令。此时 VMM 就会陷入模拟，将敏感指令 reboot 模拟成一个只对 GuestOS 进行操作的、非敏感的、并且运行在非核心态的 ”reboot” 指令，并将其交给 CPU 处理。最后由 CPU 准确的执行 GuestOS 重启的动作。



**全虚拟化的两种翻译方式**： 

- 基于二进制翻译的全虚拟化 
- 基于扫描和修补的全虚拟化

**全虚拟化的优缺点**：

- 优势：由于虚拟化环境对 Guest OS 是完全透明的，全虚拟化模式对于虚拟机的迁移以及可移植性是最佳解决方案，虚拟机可以无缝地从虚拟环境迁移到物理环境中。
- 缺点：软件模拟实现的全虚拟化无疑会增加 VMM 的上下文切换，因为这种方案实现的虚拟机性能不如半虚拟化方案。VMware 的 ESX 系列产品 和 Workstations 系列产品是全虚拟化技术的典型产品。



### 2. 半虚拟化 Para Virtualization

x86 平台上一直存在一些 Ring 3 级别可以执行的边界指令，尽管全虚拟化模式通过实时译这些特殊指令解决了这一问题，但是**实现开销较大，性能并不如在实际物理机上运行**。

为了改善性能，半虚拟化技术应运而生， “Para-Virtualization” 可理解为通过某种辅助的方式实现虚拟化。半虚拟化的解决方案如下图所示。

![半虚拟化](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96.PNG)

半虚拟化是需要GuestOS协助的虚拟化。**半虚拟化在 Guest OS 和虚拟层之间增加了一个特殊指令的过渡模块，通过修改 Guest OS 内核，将执行特权指令和边界指令替换为对虚拟层进行 hypercall 的调用方式来达到目的**。同时，虚拟层也对内存管理、中断处理、时间同步提供了 hypercall 的调用接口。Hypercall调用过程如下图所示：

![半虚拟化hypercall调用](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96hypercall%E8%B0%83%E7%94%A8.PNG)

半虚拟化的优势与缺点：

- 优势：
    - 通过这种方式，虚拟机运行的性能得以显著提升。
    - 半虚拟化 VMM 在处理敏感指令和内核态指令的流程上相对更简单一些。在半虚拟化 VMM 上运行的 GuestOS 都需要修改内核，主要是修改 GuestOS 内核指令集中包括敏感指令在内的内核态指令。
- 缺点：
    - 对于某些无法修改内核的操作系统，比如：Windows，则不能使其运行于半虚拟化环境中。
    - 由于需要修改 Guest OS 内核，无法保证虚拟机在物理环境与虚拟环境之间的透明切换。
    - 开源项目 Xen 和华为 6.3 版本之前的虚拟化解决方案 Fusion Compute 就是通过修改 Linux 内核以及提供 I/O 虚拟化操作的 Domain 0 的特殊虚拟机，使得运行于虚拟化环境上的虚拟机性能可以接近运行于物理环境的性能，属于半虚拟化技术方案的典型产品。但是，随着业务规模的增大，特殊虚机Domain 0是这种解决方案扩展性和性能方面的瓶颈。

注意：半虚拟化除了修改内核外还有另外一种实现方法——在每一个 GuestOS 中安装半虚拟化软件，e.g. VMTools、RHEVTools。



### 3. 硬件辅助虚拟化 HVM

针对敏感指令引发的一系列虚拟化问题，处理器硬件厂商最终给出了自己的解决方案。2005 年 Intel 与 AMD 公司都效法 IBM 大型机虚拟化技术分别推出 VT-x 和 AMD-V 技术。如下图所示：

![硬件辅助虚拟化](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E8%99%9A%E6%8B%9F%E5%8C%96.PNG)

硬件虚拟化技术就是指计算机硬件本身提供能力让客户机指令独立执行， 而不需要（严格来说是不完全需要） VMM截获重定向。  

这种虚拟化技术引入新的 CPU 运行模式和新的指令集，使得 VMM 和 GuestOS 运行于不同的模式下：

- VMM 运行于 Root Mode
- GuestOS 运行于 Non-Root Mode

在绝大多数情况下， 客户机在此受限环境中运行与原生系统在非虚拟化环境中运行没有什么两样， <u>不需要像软件虚拟化那样每条指令都先翻译再执行</u>。

**VMM 运行在 root mode， 拥有完整的硬件访问控制权限**。 仅仅在少数必要的时候， <u>某些客户机指令的运行才需要被 VMM 截获并做相应处理（边界指令，例如 reboot 等）</u>， 之后**客户机返回并继续在 non-root mode 中运行**。 因此， 硬件虚拟化技术的性能接近于原生系统， 并且， 极大地简化了 VMM 的软件设计架构  



### 三种虚拟化方式对比

下面就是三种虚拟化方式的对比图：

![三种虚拟化方式对比](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E4%B8%89%E7%A7%8D%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.PNG)



------

|                             |      **利用二进制翻译的全虚拟化**      | 硬件辅助虚拟化                                               | 操作系统辅助的半虚拟化                                       |
| :-------------------------: | :------------------------------------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|        **实现技术**         |             BT 和直接执行              | 遇到特权指令，转到 root 模式执行                             | HyperCall                                                    |
| **客户操作系统修改/兼容性** |     无需修改 Guest OS ，最佳兼容性     | 无需修改 Guest OS ，最佳兼容性                               | Guest OS 需要修改来支持 HyperCall，因此它不能运行在物理硬件本身或其他的 Hypervisor 上，兼容性差，不支持 Windows |
|          **性能**           |                   差                   | 全虚拟化下，CPU 需要在两种模式之间切换，带来性能开销<br />但是硬件辅助虚拟化性能逼近半虚拟化 | 好。半虚拟化下 CPU 性能开销几乎为 0，虚拟机的性能逼近与物理机 |
|        **应用厂商**         | VMware Workstation / QEMU / Virtual PC | VMware ESXi / Microsoft Hyper-V / Xen 3.0 / KVM              | Xen                                                          |
|                             |                                        |                                                              |                                                              |



说明：

- 全虚拟化与**半虚拟化的 Guest OS 的特权级别都被压缩在 Ring 1 中，而硬件虚拟化则将 Guest OS 恢复到了 Ring 0 级别**。
- **在半虚拟化中，Guest OS 的内核经过修改，所有敏感指令和特权指令都以 Hypercall 的方式进行调用，而在全虚拟化与硬件虚拟化中，则无需对 Guest OS 进行修改。**
- **全虚拟化中对于特权指令和敏感指令采用了动态二进制翻译的方式**，而**硬件虚拟化由于在芯片中增加了根模式的支持，并修改了敏感指令的语义，所有特权指令与敏感指令都能够自动陷入到根模式的 VMM 中。**



## Type1 和 Type2 虚拟化

从软件框架的角度上，**根据虚拟化层是直接位于硬件之上还是在一个宿主操作系统之上**，将虚拟化划分为 Typel 和 Type2。如下图所示：

![虚拟化type1和type2分类](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E4%BA%91%E8%AE%A1%E7%AE%97/kvm/%E8%99%9A%E6%8B%9F%E5%8C%96type1%E5%92%8Ctype2%E5%88%86%E7%B1%BB.PNG)

- **Type1（类型1）Hypervisor 也叫 native 或 bare-metal Hypervisor**。
    - 这类虚拟化层**直接运行在硬件之上，没有所谓的宿主机操作系统**。它们直接控制硬件资源以及客户机。典型地
        如 Xen 和 VMware ESX。
- **Type2（类型2）Hypervisor** 。
    - 运行在一个宿主机操作系统之上，如 VMware Workstation；
    - 或运行在宿主系统里，如 KVM。
    - 这类 Hypervisor 通常就**是宿主机操作系统的一个应用程序**，像其他应用程序一样受宿主机操作系统的管理。比如 VMware Workstation 就是运行在 Windows 或者 Linux 操作系统上的一个程序而已。





