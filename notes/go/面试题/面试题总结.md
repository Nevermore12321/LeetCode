# 面试题总结



1. `switch case` 语句，如下：

```go
type student struct {
	Name string
}

func zhoujielun(v interface{}) {
	switch msg := v.(type) {
	case *student, student:
        //  错误，msg 还是 interface 类型，并不是 student 类型
		msg.Name
       // 正确，类型转换
        msg.(student).Name
    }
}
```

注意：

- switch type 只针对 interface 类型，`msg := interface.(type)`
- case 列表可以有多个
- 使用 `msg := m.(type)` 判断类型后，msg 还是 m 类型，也就是接口类型，不能直接使用，如果要使用，需要类型转换。
- interface 的类型转换使用，`interface.(type)`



2. 当一个 channel 关闭后：
    - 无缓冲信道，从 channel 中发送数据，接收数据，都会发生 panic
    - 有缓冲信道，如果 channel 中有缓冲的数据，可以接收数据，但发送数据就会 panic



3. channel 优雅的关闭：
    - 使用 for range 来遍历 channel，range 可以感知到 channel 的关闭，自动退出。**如果是 nil 信道，循环将永远阻塞。**
    - 使用 `value, ok := <- chan` 退出，如果 ok 为 false，表示信道关闭。配合 for select 使用。

4. main 函数退出，其他野生的 Goroutine 也会退出

    

5. 按照 golang 的语法，⼩写开头的⽅法、属性或 struct 是私有的，同样，在 json 解码或转码的时候也⽆法对私有属性进行转换 。私有属性也不应该加 json 的标签。  

6. 在 Golang 的 fmt 包中，实现了 Stringer 接口，如下：

```go
type Stringer interface {
	String() string
}
```

也就是说，fmt 中的各种打印 print 操作，最终都是调用这个 Stringer 接口中的 String 方法。

如果，一个结构体，自己实现了 String 方法，在方法中又调用了 print 操作，如下：

```go
func (p *People) String() string {
	return fmt.Sprintf("print: %v", p)
}
```

这就导致了，循环调用，调用 Sprintf -> 调用 String -> 调用 Sprintf ... 

7. map 的 value 本身是不可寻址的，因为 map 中的值会在内存中移动，并且旧的指针地址在 map 改变时会变得⽆效。

也就是说 golang 里面的 map, 当通过 key 获取到 value 时，这个 value 是不可寻址的，因为 map 会进行动态扩容，当进行扩展后，map 的 value 就会进行内存迁移，其地址发生变化，所以无法对这个 value 进行寻址。

例如：

```go
type student struct {
	Name string
}


func main() {
	m := make(map[string]student)

	m["a"] = student{Name: "test"}
    //  可以正确拿到
	fmt.Println(m["a"].Name)
    //  报错，无法取址
	m["a"].Name = "bbb"

}
```

可以拿到 `m["a"].Name` ，但是无法修改，如果想要修改，需要使用 `map[string]*student` 格式。

8. defer 在定义的时候会计算好调⽤函数的参数 。也就是说，`defer(a, b + c)` defer 函数会计算好参数中的结果，再把结果压栈到 defer 函数中

9. 值接收者和指针接收者：

- 如果 interface 定义了一个接口，而类型实现的方法是使用**值接收者**，那么把类型实例赋给 interface 时，也必须使用值
- 如果 interface 定义了一个接口，而类型实现的方法是使用**指针接收者**，那么把类型实例赋给 interface 时，也必须使用类型实例的指针

例如：

```go
type People interface {
	Speak(string) string
}

type Student struct {}

func (s *Student) Speak(str string) string {
	fmt.Println(str)
	return str + "new"
}

func main() {
    //  方法使用 指针接收者，因此需要传类型指针，使用 var p People = Student{} 会报错
	var p People = &Student{}

	bbb := p.Speak("aaa")
	fmt.Println(bbb)
}
```

