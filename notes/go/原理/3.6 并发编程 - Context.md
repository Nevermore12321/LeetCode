[toc]



# Context 



## 简介

**Context 传值的使用场景**

在 Go 服务中，每个传入的请求都在其自己的 goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC 服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。

**Context 定时设置 deadline，取消信号的使用场景**

假设，启动了多个 Goroutine，但是有一个 Goroutine 很早就报错了，但是其他 Goroutine 并不知道这个错误，还在继续执行，这时候就需要 Context 来传递 cancel 信号，使得其他 Goroutine 也能退出。




## context 集成到 API 中

在将 context 集成到 API 中时，要记住的最重要的一点是，它的**作用域是请求级别的**。


目前有两种方法可以将 context 对象集成到 API 中：
1. **The first parameter of a function call**
    - **首参数传递 context 对象**，比如，参考  net 包 Dialer.DialContext。此函数执行正常的 Dial 操作，但可以通过 context 对象取消函数调用。
```go
func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)
```
2. **Optional config on a request structure**
    - **在第一个 request 对象中携带一个可选的 context 对象**。例如 net/http 库的 Request.WithContext，通过携带给定的 context 对象，返回一个新的 Request 对象。
```go
func (r *Request) WithContext(ctx context.Context) *Request
```



**context 传递姿势**

- 使用 context 的一个很好的心智模型是它应该在程序中流动，应该贯穿你的代码。**也就是将 Context 作为函数的第一个参数传入**
- 最好不要将其存储在结构体之中。它从一个函数传递到另一个函数，并根据需要进行扩展。
- 理想情况下，每个请求都会创建一个 context 对象，并在请求结束时过期。
- 不将 Context 存储在结构体中的情况，有一个例外，就是要将数据通过 channel 传入，这是就需要将 context 加到结构体中携带。
```go
type message struct {
    responseChan chan<- int
    parameter string
    ctx context.Context
}
```




## Context 索引


### 1. Variables 变量
```go
Variables
    var Canceled = errors.New("context canceled")
    var DeadlineExceeded error = deadlineExceededError{}
```

变量作用：
- `Canceled` : cancelled 是 Context 返回的错误。当上下文被取消时出错。
- `DeadlineExceeded` : DeadlineExceeded 是 Context 返回的错误。当上下文的截止日期过去时出错。


### 2. Copy Context 方法

```go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
type CancelFunc
```

方法作用：
- `WithCancel` : 创建一个带有新的 Done channel 的 context，并且返回一个取消的方法cancel
    - WithCancel 其实就是根据 Parent Context 创建一个 child Context，并且这个 child context 有一个可以取消的方法，当 返回 的 child context 的 cancel 方法被调用了，或者 Parent Context 的 Done channel 关闭了，那么 child context 的 Done channel 将会关闭
- `WithDeadline` : 创建一个具有截止时间的 context
    - 截止时间是 d 和 parent (如果有截止时间的话) 的截止时间中更早的那一个
    - 当 parent 执行完毕，或 cancel 被调用 或者 截止时间到了的时候，这个 context done 掉
- `WithTimeout` :  其实就是调用的 WithDeadline, 调用的就是 `WithDeadline(parent, time.Now().Add(timeout))`



### 3. Generate Context 
```go
type Context
    func Background() Context
    func TODO() Context
    func WithValue(parent Context, key, val interface{}) Context
```

方法作用：
- `Background` : 返回一个非 nil 的空 Context。 
    - 它永远不会被取消，没有值，也没有截止日期。它通常由主函数、初始化和测试使用，并作为传入请求的顶级上下文。
    - 一般用于创建 root context，这个 context 永远也不会被取消，或者是 done
- `TODO` : TODO返回一个非 nil 的空 Context。
    - 底层和 Background 一致，但是含义不同，当不清楚用什么的时候或者是还没准备好的时候可以用它
- `WithValue` : 为 parent context 附加值, 并且返回一个新的 child context对象
    - key 应该具有可比性，一般不应该是 string int 这种默认类型，应该自己创建一个类型
	- 避免出现冲突，一般 key 不应该导出，如果要导出的话应该是一个接口或者是指针





## WithValue 方法

`context.WithValue` 方法允许上下文携带请求范围的数据。

**这些数据必须是安全的，以便多个 goroutine 同时使用。**

**WithValue 内部实现原理：**

为了实现不断的 WithValue，构建新的 context，内部在查找 key 时候，使用递归方式不断从当前，从父节点寻找匹配的 key，直到 root context(Backgrond 和 TODO Value 函数会返回 nil)。




### Context 中的值不可变

**怎么算安全的数据呢**

- 这里的数据，更多是面向请求的元数据，不应该作为函数的可选参数来使用(比如 context 里面挂了一个sql.Tx 对象，传递到 Dao 层使用)，因为元数据相对函数参数更加是隐含的，面向请求的。而参数是更加显示的。
- 同一个 context 对象可以传递给在不同 goroutine 中运行的函数；
- 上下文对于多个 goroutine 同时使用是安全的。
- 对于值类型最容易犯错的地方，在于 context value 应该是 immutable（不可变的） 的，每次重新赋值应该是新的 context，即: context.WithValue(ctx, oldvalue)
- 也就是说，已经存入context中的值时不能修改的，如果想要修改，那么就需要重新 建一个新值，使用 WithValue 拿到新的Context



### Context 的 Copy-On-Write


**使用场景：**

如果要传 10个 key-value 到 context 中，如果用 WithValue 一个一个挂载的话，就需要生成十个新的context不断追加，可以直接往 context 中挂载一个 map 来直接添加 10个 key-value 值。

但是需要注意，如果在其他的 Goroutine 中，想要添加新的 key-value，那么就需要 Copy-On-Write，复制一个map，添加新的 key-value，挂载到 新的 context 中。


COW 过程（如下图）: 
- 从 ctx1 中获取 map1(可以理解为 v1 版本的 map 数据)。
- 构建一个新的 map 对象 map2，复制所有 map1 数据，同时追加新的数据 “k2”: “v2” 键值对，
- 使用 context.WithValue 创建新的 ctx2，ctx2 会传递到其他的 goroutine 中。
- 这样各自读取的副本都是自己的数据，写行为追加的数据，在 ctx2 中也能完整读取到，同时也不会污染 ctx1 中的数据。

![Context 的 Copy-On-Write](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Context_WithValue%E7%9A%84Copy_On_Write.png?raw=true)





### Context 的 cancel

**当一个 context 被取消时，从它派生的所有 context 也将被取消。** 

- WithCancel(ctx) 参数 ctx 认为是 parent ctx，在内部会进行一个传播关系链的关联。
- **`Done()` 返回 一个 chan**，当我们取消某个parent context, 实际上上会递归层层 cancel 掉自己的 child context 的 done chan 从而让整个调用链中所有监听 cancel 的 goroutine 退出。



**cancel的使用示例：**

```go
package main

import (
	"context"
	"fmt"
)

func main() {
	//  gen 函数，返回一个只读 chan，这个函数的作用就是，启动一个Goroutine，这个Goroutine中循环 写入 到chan，如果done chan 关闭了，就返回
	gen := func(ctx context.Context) <- chan int {
		dst := make(chan int)
		n := 1
		go func() {
			for {
				select {
				//  如果 context cancel，那么就goroutine结束
				case <- ctx.Done():
					return
				//  如果没有 cancel，那么就阻塞写入，直到写入成功
				case dst <- n:
					n ++
				}
			}
		}()
		return dst
	}

	//  创建 具有 cancel 的 Context
	ctx, cancel := context.WithCancel(context.Background())
	//  main 函数执行完后，调用 context 的 cancel 方法
	defer cancel()

	for n := range gen(ctx) {
		fmt.Println(n)
		if n == 5 {
			break
		}
	}
}
```


### Context 的 超时控制

**原理**

如果要实现一个超时控制，通过上面的 context 的 parent/child 机制，其实我们只需要**启动一个定时器，然后在超时的时候，直接将当前的 context 给 cancel 掉，就可以实现监听在当前和下层的额 context.Done() 的 goroutine 的退出。**

**超时控制的使用示例：**

```go
const shortDuration = 1 * time.Millisecond

func main() {
	d := time.Now().Add(shortDuration)
	ctx, cancel := context.WithDeadline(context.Background(), d)

	// Even though ctx will be expired, it is good practice to call its
	// cancellation function in any case. Failure to do so may keep the
	// context and its parent alive longer than necessary.
	defer cancel()

	select {
	case <- time.After(1 * time.Second):
		fmt.Println("overslept")
	case <- ctx.Done():
		fmt.Println(ctx.Err())
	}

}
```



## Context 的注意事项

**使用准则**

1. 对 server 应用而言，传入的请求应该创建一个 context
2. **通过 WithCancel , WithDeadline , WithTimeout 创建的 Context 会同时返回一个 cancel 方法，这个方法必须要被执行，不然会导致 context 泄漏，这个可以通过执行 go vet 命令进行检查**
3. 应该将 context.Context 作为函数的第一个参数进行传递，参数命名一般为 ctx 。不应该将 Context 作为字段放在结构体中。
4. 不要给 context 传递 nil，如果你不知道应该传什么的时候就传递 context.TODO()
5. 不要将函数的可选参数放在 context 当中，context 中一般只放一些全局通用的 metadata 数据，例如 tracing id 等等
6. context 是并发安全的可以在多个 goroutine 中并发调用


**使用场景**

1. 超时控制
2. 错误取消
3. 跨 goroutine 数据同步
4. 防止 goroutine 泄漏





# context 源码分析


## 1. Context 接口

```go

type Context interface {
	// Deadline 返回这个 Context 的最终 work 应该结束的超时时间
	// 如果 Deadline 函数的返回值 ok 为 false，说明当前 context 没有设置结束时间
	Deadline() (deadline time.Time, ok bool)

	// Done 返回一个只读 channel
	//  1. 如果返回的 chan 关闭了，表示 这个 Context 结束了
	//  2. 如果 Done 返回 nil，表示这个 Context 永远不会结束
	//  3. 多次调用同一个 context done 方法会返回相同的 channel
    //  4. WithCancel 返回的 Context ，如果 cancel 函数被调用后，Done chan 会被关闭
    //  5. WithDeadline 和 WithDeadline 返回的 Context，如果 超时后，Done chan 会被关闭
	Done() <-chan struct{}

	// 1. 如果 Done 返回的 chan 没有关闭，Err 函数会返回 nil
	// 2. 如果 Done 返回的 chan 关闭了，并且 Err 函数返回了不为空的 err，那么有两种错误：
	//      - context 被主动调用 cancel 方法取消：Canceled
	//      - context 超时取消: DeadlineExceeded
	Err() error

    // Value 用于返回 context 中保存的值, 如果没有附加的值，返回 nil
    // 官方建议在 context 中保存全局的值，不要保存 业务逻辑上的局部值，因为调用者并不知道 key 的名称。
	Value(key interface{}) interface{}
}
```

注意点：
1. 对 Context 接口中 Done 函数返回的 chan，用法示例可以参考官方提供的：
```go
func Stream(ctx context.Context, out chan<- Value) error {
    for {
        v, err := DoSomething(ctx)
  		if err != nil {
  			return err
  		}
  		select {
  		case <-ctx.Done():
  			return ctx.Err()
  		case out <- v:
  		}
  	}
}
```
2. 对于 Value，向 context 中存储 key-value 时，需要类型安全 type-safe
```go
package user
import "context"
// User 是要往 context 中存储的 value 值
type User struct {...}

// key 其实就是 int 类型，但又包装了一下，避免与其他 key 冲突
type key int

//  userKey 就是最终 往 context 中存储的 key 值
var userKey key

// 	// NewContext 返回新的包含 key=userKey， value=User的 Context 
func NewContext(ctx context.Context, u *User) context.Context {
	return context.WithValue(ctx, userKey, u)
}

// FromContext 取出了 存储在 context 中的 userkey 的 value 值，并且做了类型转换
func FromContext(ctx context.Context) (*User, bool) {
	u, ok := ctx.Value(userKey).(*User)
	return u, ok
}
```


## 2. 根 Context - Backgroud, TODO

两个 root Context 的区别：
- `Backgroud()`，一般用于创建 root context，这个 context 永远也不会被取消，或超时
- `TODO()`， 底层和 Background 一致，但是含义不同，当不清楚用什么的时候或者是还没准备好的时候可以用它



1. 首先看 Backgroud() 和 TODO() 的实现：
    - 很明显，Background 和 TODO 就是返回了一个 emptyCtx 对象
```go
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)

func Background() Context {
	return background
}

func TODO() Context {
	return todo
}
```
2. 再来看 emptyCtx 是什么：
    - emptyCtx 也就是个 int
    - emptyCtx 要实现 Context 接口中的那几个方法，才能作为 Context interface。
    - emptyCtx 永远不会取消，没有值，也没有截止日期。因此直接返回。
```go
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
	return
}

func (*emptyCtx) Done() <-chan struct{} {
	return nil
}

func (*emptyCtx) Err() error {
	return nil
}

func (*emptyCtx) Value(key interface{}) interface{} {
	return nil
}

func (e *emptyCtx) String() string {
	switch e {
	case background:
		return "context.Background"
	case todo:
		return "context.TODO"
	}
	return "unknown empty Context"
}
```


## 3. 取消 Context - WithCancel

WithCancel(),  方法会创建一个可以取消的 context


1. 首先看 WithCancel 方法的实现
    - 函数参数是一个 parent 的 copy ，并且可以取消的方法 cancel
    - 如果返回 child context 调用了 cancel 方法，或者 parent context 的 Done chan关闭，那么这个 child context 的 done chan 关闭
```go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    // 如果传入的 parent nil，直接 panic
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	//  这里 调用了 newCancelCtx 方法，其实很简单，就是包装了一下，生成的可以 cancel 的 cancelCtx 结构体
	c := newCancelCtx(parent)
	//  构建父子上下文的联系，确保当父 Context 取消的时候，子 Context 也会被取消
	propagateCancel(parent, &c)
	//  返回 cancelCtx 结构体指针，和 cancel 的方法
	return &c, func() { c.cancel(true, Canceled) }
}
```
2. 再来看包装的 newCancelCtx 方法 和 cancelCtx 结构体
```go
func newCancelCtx(parent Context) cancelCtx {
	return cancelCtx{Context: parent}
}

type cancelCtx struct {
	Context                        // 这里保存的是父 Context

	mu       sync.Mutex            // 互斥锁
	done     chan struct{}         // 获取关闭信号的chan
	children map[canceler]struct{} // 保存所有的子 context，当取消的时候会被设置为 nil
	err      error                 // err
}
```
3. 最有意思的是 propagateCancel 用来保证前后联系，类似链表。
    - 首先，`func propagateCancel(parent Context, child canceler)`, propagateCancel 函数的第二个参数是 canceler，其实又是一个接口，具有 两个方法，后面介绍
```go
func propagateCancel(parent Context, child canceler) {
    //  拿到 parent 的 Done chan，如果 Done chan 已经是 nil 了，那么表示 parent context 没有 cancel 方法，不会 cancel
	done := parent.Done()
	if done == nil {
		return // parent is never canceled
	}

    //  select 等待 parent done chan 关闭，如果收到关闭，直接取消 子 context, 如果没有关闭，那么直接返回
	select {
	case <-done:
		// parent is already canceled
		child.cancel(false, parent.Err())
		return
	default:
	}

    //  这里是向上查找可以被取消的 parent context
	if p, ok := parentCancelCtx(parent); ok {
	    // 如果找到了并且没有被取消的话就把这个子 context 挂载到这个 parent context 上
        // 这样只要 parent context 取消了子 context 也会跟着被取消
		p.mu.Lock()
		if p.err != nil {
			// parent has already been canceled
			child.cancel(false, p.err)
		} else {
			if p.children == nil {
				p.children = make(map[canceler]struct{})
			}
			p.children[child] = struct{}{}
		}
		p.mu.Unlock()
	} else {	// 如果父 Context 不是 CancelCtx 类型的 Context，那么说明 父 Context 是 root context
		// goroutines 用于统计曾经创建的 Goroutine 数量
		atomic.AddInt32(&goroutines, +1)
		// 新开 Goroutine ，监听 看是 父 Context 先 cancel，还是 子 Context 先 cancel
		go func() {
			select {
			case <- parent.Done():
				child.cancel(false, parent.Err())
			case <- child.Done():
			}
		}()
	}
}
```
4. 下面看一下 cancler 接口
    - cancelCtx 的 Done 方法，采用了 懒汉式加载的方式，第一次调用的时候才会去创建这个 channel
    - Value 方法很有意思，这里相当于是内部 cancelCtxKey 这个变量的地址作为了一个特殊的 key，当查询这个 key 的时候就会返回当前 context 如果不是这个 key 就会向上递归的去调用 parent context 的 Value 方法查找有没有对应的值
    - cancel 接收两个参数，removeFromParent 用于确认是不是把自己从 parent context 中移除，err 是 ctx.Err() 最后返回的错误信息
```go
type canceler interface {
	cancel(removeFromParent bool, err error)
	Done() <-chan struct{}
}

//  value 方法，如果当前 context 有 key ，那么就返回当前的 context，如果没有，就返回 parent 的 key
func (c *cancelCtx) Value(key interface{}) interface{} {
	if key == &cancelCtxKey {
		return c
	}
	return c.Context.Value(key)
}

// Done 方法，如果 Done chan为 nil给 cancelCtx 的 创建 ，chan 并返回
func (c *cancelCtx) Done() <-chan struct{} {
	c.mu.Lock()
	if c.done == nil {
		c.done = make(chan struct{})
	}
	d := c.done
	c.mu.Unlock()
	return d
}

//  Err 方法 返回 cancelCtx 的 err
func (c *cancelCtx) Err() error {
	c.mu.Lock()
	err := c.err
	c.mu.Unlock()
	return err
}

//  取消，并且是否从 parent 中删除
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
	if err == nil {
		panic("context: internal error: missing cancel error")
	}
	c.mu.Lock()
    
	if c.err != nil {
		c.mu.Unlock()
		return // already canceled
	}
	c.err = err
	
	// 由于 cancel context 的 done 是懒加载的，所以有可能存在还没有初始化的情况
	if c.done == nil {
		c.done = closedchan
	} else {
		close(c.done)
	}
	
	// 循环的将所有的子 context 取消掉
	for child := range c.children {
		// NOTE: acquiring the child's lock while holding parent's lock.
		child.cancel(false, err)
	}
	
	// 将所有的子 context 和当前 context 关系解除, 类似链表
	c.children = nil
	c.mu.Unlock()
	
    // 如果需要将当前 context 从 parent context 移除，就移除掉
	if removeFromParent {
		removeChild(c.Context, c)
	}
}
```


## 4. 超时 - WithDeadline, WithTimeout

1. WithTimeout 其实就是调用了 WithDeadline 然后再传入的参数上用当前时间加上了 timeout 的时间
```go
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return WithDeadline(parent, time.Now().Add(timeout))
}
```
2. 下面看一下 WithDeadline 函数
```go
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	// 获取 父 parent 的 Deadline
    // 如果 父 parent context 的deadline 比 当前设置的 d 还要早，那肯定先到期 parent 的，那么这个超时就不需要设置了。
    // 只需要返回 WithCancel 就可以了，因为在 parent 过期的时候，子 context 也会被取消掉
	if cur, ok := parent.Deadline(); ok && cur.Before(d) {
		// The current deadline is already sooner than the new one.
		return WithCancel(parent)
	}
	//  timerCtx 是一个 有关超时控制的结构体
	c := &timerCtx{
		cancelCtx: newCancelCtx(parent),
		deadline:  d,
	}
	//  在调用 propagateCancel 方法，将 c 与 parent 关联起来
	propagateCancel(parent, c)
	// 判断传入的时间是不是已经过期，如果已经过期了就 cancel 掉然后再返回
	dur := time.Until(d)
	//  传入的时间已经过期
	if dur <= 0 {
		c.cancel(true, DeadlineExceeded) // deadline has already passed
		return c, func() { c.cancel(false, Canceled) }
	}
	//  传入的时间没有过期，将一个定时 放在 timerCtx 中。
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.err == nil {
		c.timer = time.AfterFunc(dur, func() {
			c.cancel(true, DeadlineExceeded)
		})
	}
	return c, func() { c.cancel(true, Canceled) }
}
```
3. 下面看一下 timerCtx 结构体
```go
type timerCtx struct {
	cancelCtx          //  这里复用了 cancelCtx，保存 cancel context
	timer *time.Timer  // 定时器
	deadline time.Time // 这里保存了快到期的时间
}

func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {
	return c.deadline, true
}

func (c *timerCtx) String() string {
	return contextName(c.cancelCtx.Context) + ".WithDeadline(" +
		c.deadline.String() + " [" +
		time.Until(c.deadline).String() + "])"
}

// cancel 其实就是复用了 cancelCtx 中的取消方法，唯一区别的地方就是在后面加上了对 timer 的判断，如果 timer 没有结束主动结束 timer
func (c *timerCtx) cancel(removeFromParent bool, err error) {
	c.cancelCtx.cancel(false, err)
	if removeFromParent {
		// Remove this timerCtx from its parent cancelCtx's children.
		removeChild(c.cancelCtx.Context, c)
	}
	c.mu.Lock()
	if c.timer != nil {
		c.timer.Stop()
		c.timer = nil
	}
	c.mu.Unlock()
}

```


## 5. 附加值 - WithValue

withValue 的逻辑与之前 withCancel，withTimeout, withDeadline 相似，就是使用了 valueCtx 的结构体，来保存 key-value

```go
type valueCtx struct {
	Context
	key, val interface{}
}
```

WithValue 的方法，很简单：
```go
func WithValue(parent Context, key, val interface{}) Context {
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	if key == nil {
		panic("nil key")
	}
	//  这里加了一个判断，key是否可以比较
	if !reflectlite.TypeOf(key).Comparable() {
		panic("key is not comparable")
	}
	//  最后返回新的 valueCtx ,并保存 key value
	return &valueCtx{parent, key, val}
}
```

