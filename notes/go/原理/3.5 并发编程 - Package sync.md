# Package sync



[toc]



# Sync 简介

sync 包，实际上包含了三个包分别是: 
- `sync`
- `sync/atomic`
- `golang.org/x/sync/errgroup`



`sync/atomic` 包上一节已经介绍过了。

## sync 包


### sync 索引


#### 1. Mutex

锁机制：互斥锁和读写锁

```go
type Locker

type Mutex
    func (m *Mutex) Lock()
    func (m *Mutex) Unlock()
    
type RWMutex
    func (rw *RWMutex) Lock()
    func (rw *RWMutex) RLock()
    func (rw *RWMutex) RLocker() Locker
    func (rw *RWMutex) RUnlock()
    func (rw *RWMutex) Unlock()
```

读写锁，注意：
- 同时只能有一个 goroutine 能够获得写锁定。
- 同时可以有任意多个 gorouinte 获得读锁定。
- 同时只能存在写锁定或读锁定（读和写互斥）。

也就是：**多个 goroutine 可以同时读。但只要有写，其他都不可以**



#### 2. WaitGroup

WaitGroup 用来对 Goroutine 进行计数，并且在主进程可以等待计数了的 Goroutine 结束。
```go
type WaitGroup
    func (wg *WaitGroup) Add(delta int)
    func (wg *WaitGroup) Done()
    func (wg *WaitGroup) Wait()
```

方法介绍：
- Add : 添加几个Gouroutine，用于计数
- Done： 在 Goroutine 内部，执行完毕后，调用 Done 表示该 Goroutine 结束
- Wait: 主程序调用 Wait 函数，等待所有的 Goroutine 执行结束，否则阻塞等待


#### 3. Cond (condition)

sync.Cond，可以和互斥锁或读写锁（以下统称互斥锁）组合使用，用来协调想要访问共享资源的线程。

**条件变量 sync.Cond 的主要作用并不是保证在同一时刻仅有一个线程访问某一个共享资源，而是在对应的共享资源状态发生变化时，通知其它因此而阻塞的线程。**

条件变量总是和互斥锁组合使用，互斥锁为共享资源的访问提供互斥支持，而**条件变量可以就共享资源的状态变化向相关线程发出通知，重在「协调」。**

```go
type Cond
    func NewCond(l Locker) *Cond
    func (c *Cond) Broadcast()
    func (c *Cond) Signal()
    func (c *Cond) Wait()
```


方法介绍：
- NewCond : 传入一个 互斥锁，可以是 Mutex，也可以是 RWMutex，返回一个 Cond 指针对象
- Wait : 等待通知，一个 Goroutine 阻塞等待通知，收到通知后，会继续执行
- Signal : 唤醒一个因等待条件变量 c 阻塞的 goroutine
- Broadcase : 唤醒所有因等待条件变量 c 阻塞的 goroutine

注意：**在调用 Signal，Broadcast 之前，应确保目标 Goroutine 程进入 Wait 阻塞状态。**

条件变量和锁结合使用，在并发时如果逻辑不严谨容易发生死锁，所以尽量不要使用条件变量，推荐用 sync.WaitGroup 来实现并发时 Go 程间的同步。

#### 4. Map

Map 类似于Go `map[interface{}]interface{}`，但对于多个 goroutine 并发使用来说是安全的，无需额外的锁定或协调。加载、存储和删除都是在平摊常量时间内运行的。


sync.Map 有以下特性：
- 无须初始化，直接声明即可。
- sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load  表示获取，Delete 表示删除。
- 使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range - 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。

```go
type Map
    func (m *Map) Delete(key interface{})
    func (m *Map) Load(key interface{}) (value interface{}, ok bool)
    func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)
    func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)
    func (m *Map) Range(f func(key, value interface{}) bool)
    func (m *Map) Store(key, value interface{})
```

方法介绍：
- Delete : 删除一个 key value
- Load : 获取 key 对应的 value
- LoadAndDelete : 获取 key 的 value，并且把这个 key value 删掉
- LoadOrStore : 如果 map 中有 key ，那么就获取 value，如果没有 key，那么就把这个 key value 存储
- Range : Range 对映射中出现的每个键和值依次调用 f。如果 f 返回 false,  range将停止迭代。
**Range 键不会被多次访问，但是如果任何键的值被同时存储或删除，那么 Range 可以在 Range 调用期间的任何点反映该键的任何映射。**
- Store : 存储 key value


注意：**sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。**

#### 5. Once

Once 是只执行一个操作的对象。

使得多个 Goroutine 的 Once 操作只做一次

```go
type Once
    func (o *Once) Do(f func())

```

方法介绍：
- Do : 调一个方法，在第一次启动 Goroutine 时执行一次，下次在执行时不在调用




#### 6. Pool

一个 Pool 是一组可以单独保存和检索的临时对象。类似于数据库连接池，也就是一个**临时对象池**。

作用：**保存和复用临时对象，减少内存分配，降低 GC 压力。**


Pool 对于同时被多个 goroutine 使用是安全的。

方法介绍：
- Put ： 优先放入 private 空间，后面再放入 shared 空间
- Get :   优先从 private 空间拿，再加锁从 shared 空间拿，还没有再从其他的 PoolLocal 的 shared 空间拿，还没有就直接 new 一个返回


```go
type Pool
    func (p *Pool) Get() interface{}
    func (p *Pool) Put(x interface{})
```



## sync.Mutex


### 互斥锁的竞争示例


Mutex 也就是 互斥锁，我们先来看一个例子：
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	done := make(chan bool, 1)
	var mu sync.Mutex
	var i int
	var j int

	//  Goroutine 1 : 死循环加锁解锁，并且在加锁后 sleep 100 毫秒
	go func() {
		for {
			select {
			case <-done:
				return
			default:
				mu.Lock()
				i ++
				time.Sleep(100 * time.Millisecond)
				mu.Unlock()
			}
		}
	}()

	//  Goroutine 2 : 只循环10次，并且 每次开始前 sleep 100 毫秒
	for n := 0; n < 10; n++ {
		time.Sleep(100 * time.Millisecond)
		mu.Lock()
		j ++
		mu.Unlock()
	}
	done <- true
	fmt.Printf("Goroutine1 : %d", i)
	fmt.Printf("Goroutine2 : %d", j)
}

```

上述过程为：
- Goroutine1 获取锁，获取锁后，sleep 100 毫秒，然后释放锁，也就是说 Goroutine 持有锁的时间长
- Goroutine2 也就是 main，每次先 sleep 100 毫秒，然后获取锁，在释放锁
- 最终的结果为：
```go
Goroutine1 : 30
Goroutine2 : 10
```
- 上面跑的结果是基于 go 1.15，如果基于 go 1.8，那么 Goroutine1 有可能 会执行 700多万次，而Goroutine2只执行了十次。




造成这一现象的原因：（go版本为 go 1.8）
1. goroutine1 将获得锁并休眠 100ms。当 goroutine2 试图获取锁时，它将被添加到锁的队列中- FIFO 顺序，goroutine 将进入等待状态, 如下图：
![竞争原理步骤1](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Goroutine%E7%AB%9E%E4%BA%89%E5%8E%9F%E7%90%86%E6%AD%A5%E9%AA%A41.png?raw=true)
2. 当 goroutine1 完成它的工作时，它将释放锁。此版本将通知队列唤醒 goroutine2。goroutine2 将被标记为可运行的，并且正在等待 Go 调度程序在线程上运行，如下图：
![竞争原理步骤2](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Goroutine%E7%AB%9E%E4%BA%89%E5%8E%9F%E7%90%86%E6%AD%A5%E9%AA%A42.png?raw=true)
3. 但是，当 goroutine2 等待运行时，goroutine1 将再次请求锁。如下图：
![竞争原理步骤3](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Goroutine%E7%AB%9E%E4%BA%89%E5%8E%9F%E7%90%86%E6%AD%A5%E9%AA%A43.png?raw=true)
4. goroutine2 尝试去获取锁，结果悲剧的发现锁又被人持有了，它自己继续进入到等待模式。如下图：
![竞争原理步骤4](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Goroutine%E7%AB%9E%E4%BA%89%E5%8E%9F%E7%90%86%E6%AD%A5%E9%AA%A44.png?raw=true)
5. 因此，Goroutine1 获取锁的次数将远大于 Goroutine2
6. 这是在 go 1.8 版本中，是这样实现的，在新的版本中，加入了**饥饿模式**。




### 互斥锁的实现

**锁一共有三种实现模式，分别是：**

1. **Barging 模式** : 这种模式是为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人。
    - Barging 也就是释放完锁，直接唤起一个等待者，不管是谁。
    ![Barging模式原理](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Barging%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86.png?raw=true)
2. **Handsoff 模式** : 当锁释放时候，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。
    - 一个互斥锁的 handsoff 会完美地平衡两个goroutine 之间的锁分配，但是会降低性能，因为它会迫使第一个 goroutine 等待锁。
    - handsoff 模式是在释放完锁后，会在 Go Scheduler 队列里唤醒一个等待者，不会唤醒新来的 Goroutine。
    ![Handsoff模式原理](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Handsoff%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86.png?raw=true)
3. **Spinning 模式** : 自旋在等待队列为空或者应用程序重度使用锁时效果不错。Parking 和 Unparking goroutines 有不低的性能成本开销，相比自旋来说要慢得多。
    - Spinning 模式也就是在 Go Scheduler 队列中没有等待的 Goroutine 时，新来的 Goroutine 想要获取锁，但是锁还没有被释放，这时候，这个新来的 Goroutine 就会自旋等待上锁。由于自旋就是 for 循环获取，牺牲了性能。
    ![Spinning模式原理](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Spinning%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86.png?raw=true)






**GO 中 互斥锁的实现原理：**
1. Go 1.8 使用了 Barging 和 Spining 的结合实现。
    - 当试图获取已经被持有的锁时，如果本地队列为空并且 P（Goroutine 队列） 的数量大于1，goroutine 将自旋几次(用一个 P 旋转会阻塞程序)。
    - 自旋后，goroutine park。在程序高频使用锁的情况下，它充当了一个快速路径。
2. Go 1.9 通过添加一个新的饥饿模式来解决先前解释的问题，
    - 该模式将会在释放时候触发 handsoff。
    - 所有等待锁超过一毫秒的 goroutine (也称为有界等待)将被诊断为饥饿。
    - 当被标记为饥饿状态时，unlock 方法会 handsoff 把锁直接扔给第一个等待者。
    - 在饥饿模式下，自旋也被停用，因为传入的 goroutines 将没有机会获取为下一个等待者保留的锁。




## sync.Once

Once 使用很简单，类似单例模式，循环启动的 Goroutine 只执行一次的操作。

**下面是使用示例：**

```go
func main() {
	var once sync.Once
	onceBody := func() {
		fmt.Println("Only once")
	}
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			once.Do(onceBody)
			done <- true
		}()
	}
	for i := 0; i < 10; i++ {
		<-done
	}
}
```


**源码分析：**
1. Once 的结构体：
```go
type Once struct {
    // done 表示 Once 的操作是否已经执行过
	done uint32
	//  锁
	m    Mutex
}
```
2. Once.Do 方法
- 源码这里很清楚的讲，为什么使用 atomic.LoadUint32 ，而不用 atomic.CompareAndSwapUint32 的CAS操作
- 先介绍 CAS 操作的原理，就是比较并交换，cas(*addr, old, new), 先判断 *addr == old, 如果不相等，则 直接返回，如果相等，则 *addr = new, 在返回。也就是说，不会阻塞等待，而是直接返回。
- 原因就是，如果有两个 Goroutine，第一个 Goroutine 在执行 Once.Do() 方法，第二个Goroutine 必须要等这个 Once.Do 执行完，才能继续执行，如果 这里用 CAS 操作，那么就不会阻塞等待，直接返回，就没有等待第一个 Goroutine 执行，就返回了。
- 如果这么实现最大的问题是，如果并发调用，一个 goroutine 执行，另外一个不会等正在执行的这个成功之后返回，而是直接就返回了，这就不能保证传入的方法一定会先执行一次了

```go
func (o *Once) Do(f func()) {
	// Note: Here is an incorrect implementation of Do:
	//
	//	if atomic.CompareAndSwapUint32(&o.done, 0, 1) {
	//		f()
	//	}
	//
	// Do guarantees that when it returns, f has finished.
	// This implementation would not implement that guarantee:
	// given two simultaneous calls, the winner of the cas would
	// call f, and the second would return immediately, without
	// waiting for the first's call to f to complete.
	// This is why the slow path falls back to a mutex, and why
	// the atomic.StoreUint32 must be delayed until after f returns.
    
    //  如果能拿到 o.done 并且 done == 0，表示还没执行
	if atomic.LoadUint32(&o.done) == 0 {
		// Outlined slow-path to allow inlining of the fast-path.
		o.doSlow(f)
	}
}
```
3. o.doSlow 方法
    - doSlow 就是 执行 具体的 Do 传入的 func 操作
    - 需要先加锁，使用互斥锁来保证只会执行一次
```go
func (o *Once) doSlow(f func()) {
    // 加锁
	o.m.Lock()
	// 执行完 释放锁
	defer o.m.Unlock()
	// 没有执行过，done = 0，那么就执行 操作 f，最后，将 done 置为1，表示已经执行过一次
	if o.done == 0 {
		defer atomic.StoreUint32(&o.done, 1)
		f()
	}
}
```


## sync.Pool

**sync.Pool 的场景是用来保存和复用临时对象，以减少内存分配，降低 GC 压力(Request-Driven 特别合适)。**

- Get 返回 Pool 中的任意一个对象。如果 Pool 为空，则调用 New 返回一个新创建的对象。
- 放进 Pool 中的对象，会在说不准什么时候被回收掉。所以如果事先 Put 进去 100 个对象，下次 Get 的时候发现 Pool 是空也是有可能的。不过这个特性的一个好处就在于不用担心 Pool 会一直增长，因为 Go 已经帮你在 Pool 中做了回收机制。
- 这个清理过程是在每次垃圾回收之前做的。之前每次 GC 时都会清空 pool，而在1.13版本中引入了 victim cache，会将 pool 内数据拷贝一份，避免 GC 将其清空，即使没有引用的内容也可以保留最多两轮 GC。



# errgroup 包


## 介绍

**依赖与并行**

把一个复杂的任务，尤其是依赖多个微服务 rpc 需要聚合数据的任务，分解为依赖和并行
- 依赖的意思为: 需要上游 a 的数据才能访问下游 b 的数据进行组合。
- 但是并行的意思为: 分解为多个小任务并行执行，最终等全部执行完毕。


errgroup 包位于： https://pkg.go.dev/golang.org/x/sync/errgroup

**errgroup 核心原理:**  利用 sync.Waitgroup 管理并行执行的 goroutine。

- 并行工作流
- 错误处理 或者 优雅降级
- context 传播和取消
- 利用局部变量+闭包


可以详见blibli开源的额kratos框架：  
https://github.com/go-kratos/kratos/tree/master/pkg/sync/errgroup



**使用场景：**
- 在一个 goroutine 需要等待多个 goroutine 完成和多个 goroutine 等待一个 goroutine 干活时都可以解决问题。
- 虽然 WaitGroup 已经帮我们做了很好的封装，但是仍然存在一些问题，
    - 例如如果需要返回错误
    - 例如只要一个 goroutine 出错我们就不再等其他 goroutine 了，减少资源浪费
    - 这些 WaitGroup 都不能很好的解决，errgroup 可以很好解决。


注意：
- **如果使用 WithContext 创建 Group，那么只要有一个 Goroutine 有 err 返回，那么所有的 Goroutine 都返回**
- **如果直接创建 Group ，那么有 Goroutine 报错时，其他 Goroutine 继续执行**




## errgroup 索引
```go
type Group
func WithContext(ctx context.Context) (*Group, context.Context)
func (g *Group) Go(f func() error)
func (g *Group) Wait() error
```


### Group 类型

Group 是处理子任务的 goroutine 的集合，这些子任务是同一总体任务的一部分。

一个 Group type 可以管理 goroutine ，并且可以置为空。

并且可以接受 Goroutine 的第一个 err 返回

**Group 类型定义为：**

```go
type Group struct {
	// contains filtered or unexported fields
}
```

**源码为：**

```go
type Group struct {
    // context 中的 cancel 方法
	cancel func()

    //  复用 WaitGroup
	wg sync.WaitGroup
    
    // 用来保证只会接受一次错误
	errOnce sync.Once
	
	// 保存第一个返回的错误
	err     error
}
```


解析：
- errgroup 的实现，其实是使用了基本库中的 sync.WatiGroup 。
- 使用 WatiGroup 来管理 goroutine 的生命周期
- 并且使用 sync.Once 保证只接受一次err

### WithContext 方法

**函数定义：**
```go
func WithContext(ctx context.Context) (*Group, context.Context)
```

**函数作用：**
- WithContext 方法传入一个 Context 对象，返回 新生成的 Group 指针，和 从传入参数 ctx 派生的 context 对象
- 当传递给 Go 的函数第一次返回一个非 nil 错误时，或当 Wait 第一次返回时，派生的 Context 被取消。
- 也就是说，如果有一个子任务返回错误，或者Wait调用返回，这个 Context 就会cancel。



**源码分析：**
```go
func WithContext(ctx context.Context) (*Group, context.Context) {
    //  从 传入的 context 中，派生出一个 可以 cancel 的 context 对象
	ctx, cancel := context.WithCancel(ctx)
	//  返回一个 Group 对象，并且将其中的 cancel 方法赋值
	return &Group{cancel: cancel}, ctx
}
```

- 其实 WithContext 方法实现很简单，就是生成一个新的 Group，并将这个 Group 中的 cancel 方法赋值而已




### Go 方法

**函数定义：**
```go
func (g *Group) Go(f func() error)
```

**函数作用：**
- Go 方法对应 golang 的原生 go，产生一个 Goroutine，并且让 Goroutine 执行 掺入的 函数，
- 当第一次返回 非 nil 的err，就会取消 cancel 这个 Group，返回的这个 err，将会由 Wait 函数接受。
- 也就是说，Go 用于传入子任务，如果成功返回 nil，如果失败返回 error，同时 cancel 那个 Context



**源码分析：**

```go
func (g *Group) Go(f func() error) {
    //  启动一个线程，在 Group 结构体中 的 WatiGroup 计数 加1
	g.wg.Add(1)
    
    //  go 原生启动 Goroutine，
	go func() {
	    //  Goroutine 结束后，调用 WaitGroup.Done ，结束 这个 Goroutine
		defer g.wg.Done()

        //  调用 传进来的函数，如果err返回
		if err := f(); err != nil {
		    //  如果有 err，只调用一次，Once操作，将 err 保存在 Gourp 的 err 字段中
			g.errOnce.Do(func() {
				g.err = err
				//  调用 Group 中的 Cancel 方法，取消 Context
				if g.cancel != nil {
					g.cancel()
				}
			})
		}
	}()
}

```

解析：
- Go 方法其实就类似于 go 关键字，会启动一个 Goroutine 
- 利用 waitgroup 来控制是否结束
- 如果有一个非 nil 的 error 出现就会保存起来，并且如果有 cancel 就会调用 cancel 取消掉，使 ctx 返回



### Wait 方法

**函数定义：**
```go
func (g *Group) Wait() error
```

**函数作用：**
- Wait 函数就是阻塞等待所有 Goroutine 都返回，或者如果有 err ，那就返回第一个非空的 err
- Wait, 类似 waitgroup，等所有的子任务完成后返回，如果有多个子任务返回 error，则会返回第一个 error，所有子任务执行成功则返回 nil。



**源码分析：**
```go
func (g *Group) Wait() error {
    //  调用 WaitGroup 的 Wait 方法 阻塞等待所有 Goroutine 结束
	g.wg.Wait()
	
	//  如果 Wait 函数结束后，Group 中的 cancel 方法不为 nil，说明有 context，那么取消 context
	if g.cancel != nil {
		g.cancel()
	}
	//  最后返回 Group 中的err，如果有，返回第一个产生的err，如果没有，则返回 nil
	return g.err
}
```

解析：
- Wait 方法其实就是调用 WaitGroup 等待，如果有 cancel 就调用一下



## 案例演示

```go
package main

import (
	"fmt"
	"net/http"

	"golang.org/x/sync/errgroup"
)

func main() {
	g := new(errgroup.Group)
	var urls = []string{
		"http://www.golang.org/",
		"http://www.google.com/",
		"http://www.somestupidname.com/",
	}
	for _, url := range urls {
		// Launch a goroutine to fetch the URL.
		url := url // https://golang.org/doc/faq#closures_and_goroutines
		g.Go(func() error {
			// Fetch the URL.
			resp, err := http.Get(url)
			if err == nil {
				resp.Body.Close()
			}
			return err
		})
	}
	// Wait for all HTTP fetches to complete.
	if err := g.Wait(); err == nil {
		fmt.Println("Successfully fetched all URLs.")
	}
}

```