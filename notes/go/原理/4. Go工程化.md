# Go 工程化



[toc]


# Go 项目的目录结构

## 标准的应用程序目录结构

### 1. /cmd 目录

一般使用 `/cmd/[appname]/main.go` 划分不同的应用程序

- **项目的主干。**
- 该目录下，不应该有太多的代码，不应该包含业务逻辑
- 然后根据不同的应用名称，划分不同的目录，
- 如果你认为代码可以导入并在其他项目中使用，那么它应该位于 /pkg 目录中。
- 如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 /internal 目录中


### 2. /internal 目录

**私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。**

- 一般会把项目文件夹放置到 internal 当中，例如 /internal/app
- 如果是可以被其他项目导入的包我们一般会放到 pkg 目录下
- 如果是我们项目内部进行共享的包，而不期望外部共享，我们可以放到 /internal/pkg 当中
- 注意 internal 目录的限制并不局限于顶级目录，在任何目录当中都是生效的
- go 1.4 添加了 对 internal 包的引用限制

例如：
```
❯ tree
.
├── a
│   ├── cmd
│   │   └── a
│   │       └── main.go
│   └── internal
│       └── pkg
│           └── t
│               └── t.go
└── b
    └── cmd
        └── b
            └── main.go
```

如果 b 中main.go使用了 a 中的internal 的包，那么会报错。


### 3. /pkg 目录

**外部应用程序可以使用的库代码(例如 /pkg/mypubliclib)**


- internal 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。
- /pkg 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。
- /pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类再次划分。例如 /pkg/cache 、 /pkg/conf 等
- /internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。
- 如果你的目录结构比较简单，内容也比较少，其实也可以不使用 pkg 目录，直接把上面的这些包放在最上层即可
- 一般而言我们应用程序 app 在最外层会包含很多文件，例如 .gitlab-ci.yml makefile .gitignore 等等，这种时候顶层目录会很多并且会有点杂乱，建议还是放到 /pkg 目录比较好


### 4. /vendor 目录

**存放应用程序依赖项**

- `go mod vendor` 命令将为你创建 /vendor 目录
- 如果要提交代码到 gitlab 或其他仓库中，请不要添加 vendor 目录




## Kit 基础库目录结构

**kit 库其实也就是一些基础库**



每个公司都应当为不同的微服务建立一个统一的 kit 工具包项目(基础库/框架) 和 app 项目。
基础库 kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。


库一般会包含一些常用的公共的方法，例如缓存，配置等等，比较典型的例子就是 go-kit


kit 库必须具有的特点：
- 统一
- 标准库方式布局
- 高度抽象
- 支持插件
- 尽量减少依赖
- 持续维护



## 服务应用程序目录结构（service app）


### 1. /api 目录

**API 协议定义目录**


如果使用 rpc：
- xxapi.proto protobuf 文件，以及生成的 go 文件。
- 通常把 api 文档直接在 proto 文件中描述。

如果使用 http：
- OpenAPI/Swagger 规范
- JSON 模式文件
- 协议定义文件。

例如 k8s 的源码： https://github.com/kubernetes/kubernetes/tree/master/api



### 2. /configs 目录

**配置文件模板或默认配置。**



### 3. /test 目录

**额外的外部测试应用程序和测试数据。你**

- 可以随时根据需求构造 /test 目录。
- 对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。
- 请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。




### 4. /init 目录

**System init（systemd，upstart，sysv）和 process manager/supervisor（runit，supervisor）配置。**

如果需要在添加，可以不要


### 5. /scripts 目录

**执行各种构建、安装、分析等操作的脚本。**

- 就是程序中需要执行的脚本，
- build image 或者 cicd pipeline 一些脚本可以放在 build 目录里。


### 6. /build 目录

**打包和持续集成。**


- 将云( AMI )、容器( Docker )、操作系统( deb、rpm、pkg )包配置和脚本放在 /build/package 目录下。
= 将 CI (travis、circle、drone)配置和脚本放在 /build/ci 目录中。
请注意，有些 CI 工具(例如 Travis CI)对配置文件的位置非常挑剔。尝试将配置文件放在 /build/ci 目录中，将它们链接到 CI 工具期望它们的位置(如果可能的话)。






### 7. /docs 目录

**设计和用户文档(除了 godoc 生成的文档之外)**



## 服务应用程序的目录实例

### Service app 的类型


注意：**每一个微服务都要有一个全局唯一的名称，这样有利于目录的分解，和后面的服务发现**

**微服务中的 app 服务类型分为 4 类：interface、service、job、admin。**

- **interface** : 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。
- **service** : 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了 gRPC 接口只对内服务。只供同层调用。
- **admin** ：区别于 service，更多是面向运营侧的服务，通常数据权限更高，隔离带来更好的代码级别安全。
- **job** : 流式任务处理的服务，上游一般依赖 message broker。
- **task** : 定时任务，类似 cronjob，部署到 task 托管平台中。


**cmd 应用目录负责程序的: 启动、关闭、配置初始化等。**




### Service app 的实例


#### 一般的布局

![一般的布局](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E6%99%AE%E9%80%9A%E7%9A%84ServiceApp%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true)

- api: 放置 API 定义(protobuf)，以及对应的生成的 client 代码，基于 pb 生成的 swagger.json。
- configs: 放服务所需要的配置文件，比如database.yaml、redis.yaml、application.yaml。
- internal: 是为了避免有同业务下有人跨目录引用了内部的 model、dao 等内部 struct。
    - server: 放置 HTTP/gRPC 的路由代码，以及 DTO 转换的代码。
    - model: 放对应“存储层”的结构体，是对存储的一一隐射。
    - dao: 数据读写层，数据库和缓存全部在这层统一处理，包括 cache miss 处理。
    - service: 组合各种数据访问来构建业务逻辑。


注意：
1. DTO  

**DTO(Data Transfer Object)：数据传输对象**，这个概念来源于J2EE 的设计模式。但在这里，泛指用于展示层/API 层与服务层(业务逻辑层)之间的数据传输对象。

简而言之，就是接口之间传递的数据封装
表里面有十几个字段：id，name，gender（M/F)，age……
页面需要展示三个字段：name，gender(男/女)，age

DTO由此产生
- **一是能提高数据传输的速度(减少了传输字段)**
- **二能隐藏后端表结构**

2. DAO

**Dao(data access object)，代表数据访问对象的意思。**

当我们想操作数据库时，不会为每一个场景都去写一些 SQL 语句，把数据库封装一下，让我们和数据库的交道看起来比较像和一个对象打交道。这个对象通常就是 DAO。

3. DO

**DO(Domain Object): 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。**

缺乏 DTO -> DO 的对象转换。


也就是 在 API 展现的时候，有 DTO 对象，也就是想要在页面上展示的数据结构，而在 service 层，需要将 DTO -> DO ，DO 也就是 DO 具有一些不应该让展示层知道的数据



这种设计的缺陷：
- 项目的依赖路径为: model -> dao -> service -> api，model struct 串联各个层，直到 api 需要做 DTO 对象转换。
- server 层可以去掉



#### 较好的布局

![较好的布局](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E8%BE%83%E5%A5%BD%E7%9A%84ServiceApp%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true)


app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。
- internal: 是为了避免有同业务下有人跨目录引用了内部的 biz、data、service 等内部 struct。
  如果存在一个仓库多个应用，那么可以在 internal 里面进行分层，例如 /internal/app , /internal/job
    - biz: 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。
    - data: 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。
    - service: 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -> DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑。



也就是 
- service 层就是实现 grpc 中定义的 service 中的方法，然后将 展示的数据 DTO 转成 内部数据 DO。service 的逻辑应该很简单，并且service主要是做编排的工作，类似第一步做什么，第二步做什么，但具体的细节留给 biz 层。
- biz 层实现处理的逻辑，例如评论前，先检查用户的权限等。并且 biz 层想要的 数据model，在这层定义，并且，把持久化的 interface 放在 biz层，而具体的查询数据库，来填充这个model的实现，留给data层
- data 层


例如：在 biz 层可以这样定义：
```go
//  这是一个订单的 数据 model
type Order struct {
    item string
}

//  在 biz 层，定义一个interface，这个interface是用来对 这个 Order 进行操作的方法
//  而具体的 SaveOrder 和 DeleteOrder 在 data 层实现
type OrderRepo interface {
    SaveOrder(*Order)
    DeleteOrder(*Order)
    ...
}


//  下面就是 具体的 逻辑处理，比如说处理一个 买的服务逻辑，先要 定义一个 Usercase , 这个 Usercase 可能有买，卖等操作, 其实就是操作数据库的操作，也就是 对 model Order 的操作
type OrderUsercase sturct {
    repo OrderRepo
}


func (uc *OrderUsercase) Buy(o *Order) {
    //  前面这里很多都是判断逻辑，比如判断 用户有没有权限买，是否有余额等
    ... 
    //  然后，就是买的结果存入数据库
    uc.repo.SaveOrder(o)
}

```


注意

1. PO

**PO(Persistent Object): 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系**，如果持久层是关系型数据库，那么数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。







# API 的设计


## API 管理姿势

以往 HTTP 的 API 设计，都是每个模块由每个模块的人设计，然后写响应的文档。而当有人想要拿到 api 时，又不知道从哪里找，还得不断地去问，因此花费了大量的时间在沟通上。

而如果使用 gRpc 框架来构建微服务，protobuf 的文件其实就是 api 的定义，因为 protobuf 当中包含了接口的函数签名，入参和返回值同时还支持注释，就是一份天然的文档，同时也不用担心出现代码更新了但是文档没有更新的情况，因为它既是文档也是代码，服务端也需要使用，所以代码更新之后文档也一定会更新。自然而然的就少了很多沟通的成本。




最方便的 API 管理方式：

**建立专门存放 API 接口的仓库，也就是统一存放 protobuf 文件的仓库，每个子项目，通过 cicd 生成对应的客户端代码放到各个子项目的指定文件夹内。**


流程图为：
![API project的cicd流程图](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/api_project_cicd.jpeg?raw=true)


其开发步骤为：
- 开发修改了 proto 文件定义之后 push 到对应的业务应用仓库当中
- 然后触发 cicd 流程将 proto 文件复制到 api project 当中
    - 首先会对 proto 文件进行静态代码分析，查看是否符合规范
    - 然后 clone api project 创建一个新的分支
    - 然后 push 代码，创建一个 merge request 请求
    - 最后，对应负责的同学收到 code review 的通知之后进行 code review，没有问题就会合并到 api project 的主分支当中了
- 最后，会触发 cicd 生成对应语言的客户端代码，push 到对应的各个子仓库当中了


这样做的好处:
- API 仓库，方便跨部门协作。
- 版本管理，基于 git 控制。
- 规范化检查，API lint。
- API design review，变更 diff。
- 权限管理，目录 OWNERS。




## API 项目的目录结构


![API project的目录结构](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/APi_%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpeg?raw=true)

- 首先是在业务项目当中，我们顶层会有一个 api 目录
    - 在 api 目录当中我们会按照 `product name/app name/版本号/app.proto` 的方式进行组织
    - 具体怎么组织可能每个公司都不太一样，但是总的来说就是应用的 唯一名称+版本号 来进行一个区分
- 在 api project 当中和业务应用类似，也有一个 api 目录，通过上图的两个框就可以发现这是一模一样的
    - 除此之外 api project 还有用于注解的 annotations 文件夹
    - 有一些第三方的引用，例如 googleapis 当中的一些 proto 文件




## API 的兼容性

**向后兼容(非破坏性)的修改**
- 给 API 服务定义添加 API 接口
    - 从协议的角度来看，这始终是安全的。
- 给请求消息添加字段
    - 只要客户端在新版和旧版中对该字段的处理保持一致，添加请求字段就是兼容的。
- 给响应消息添加字段
    - 在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。



**向后不兼容(破坏性)的修改**

- 删除或重命名服务，字段，方法或枚举值
    - 从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改 major 版本号。 
- 修改字段的类型
    - 即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加 major 版本号。对于编译型静态语言来说，会容易引入编译错误。
- 修改现有请求的可见行为
    - 客户端通常依赖于 API 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 API 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它
- 给资源消息添加 读取/写入 字段




## API 命名规范

**包名**

- 包名就是应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。
- 文件中声明的包名称应该与产品和服务名称保持一致。
- 带有版本的 API 的软件包名称必须以此版本结尾。

注意：

- 在 gRpc 的 protobuf 文件中，有一个 package 关键字，用于指定包名。
- 如果 `package my.package.v1`，my/pacage.v1 为 API 目录，v1 为版本，定义service相关接口，用于提供业务使用。
- 最终生成的 Request url 为：
```go
// RequestURL: /<package_name>.<version>.<service_name>/{method}
package <package_name>.<version>;
```


## API 设计

详见：
https://www.bookstack.cn/read/API-design-guide/API-design-guide-README.md




# 配置管理


## 常用的配置类型

- **环境配置**
    - 环境配置，应该是应用部署时就已经确定好的信息，这些信息不应该写在我们的配置文件或者是放到配置中心，而是应该由我们的部署平台，例如 K8s 直接在容器启动时候就注入好
        - region: 区域信息
        - env: 环境信息，例如 prod, test
        - zone: 可用区
        - host: 机器名
        - appid: 应用 id
        - color: 流量染色信息，用来做流量分发的
- **静态配置**
    - 资源需要初始化的配置信息，比如 http/gRPC server、redis、mysql 等
    - 这类资源在线变更配置的风险非常大，尽量不要在线动态变更，很可能会导致业务出现不可预期的事故
    - 变更静态配置和发布 bianry app 没有区别，应该走一次迭代发布的流程。
- **动态配置**
    - 应用程序可能需要一些在线的开关，来控制业务的一些简单策略，会频繁的调整和使用，我们把这类是基础类型(int, bool)等配置，用于可以动态变更业务流的收归一起，
    - 不过业务配置最好做到管理后台，因为配置中心运营同学一般没有权限，并且很多配置中心的校验做的不够好，不熟悉的人进行变更很容易出问题
- **全局配置**
    - 我们依赖的各类组件、中间件都有大量的默认配置或者指定配置，在各个项目里大量拷贝复制，容易出现意外，所以我们使用全局配置模板来定制化常用的组件，然后再特化的应用里进行局部替换。




## 最佳配置的时间过程


### No.1 函数参数配置

例如，如果我们要新建一条 Redis 的连接，那么需要新建一个函数，来创建 Redis 连接。

第一阶段，直接定义一个函数，传入必须要的参数。如下
```go
func Dial(network, address string) (Conn, error)
```

问题：
- “我要自定义超时时间！”
- “我要设定 Database！”
- “我要控制连接池的策略！”
- “我要安全使用 Redis，让我填一下 Password！”
- “可以提供一下慢查询请求记录，并且可以设置 slowlog 时间？”

第二阶段，不断添加函数，来实现不同配置信息的传入。
```go
// DialTimeout acts like Dial for establishing the
// connection to the server, writing a command and reading a reply.
func Dial(network, address string) (Conn, error)

// DialTimeout acts like Dial but takes timeouts for establishing the
// connection to the server, writing a command and reading a reply.
func DialTimeout(network, address string, connectTimeout, readTimeout, writeTimeout time.Duration) (Conn, error)

// DialDatabase acts like Dial but takes database for establishing the
// connection to the server, writing a command and reading a reply.
func DialDatabase(network, address string, database int) (Conn, error)

// DialPool
func DialPool...

```

问题：
- 不能每多一个参数，就添加一个函数来处理，大量的重复逻辑在其中
- 用户的需求是满足不完的，作为公共库，不可能为每个用户的需求都单独来搞个函数签，太多了
- 因为 Go 没有重载，因此，这就造成了没实现一个功能，就得多加一个函数


第三阶段，可以查看标准库 net/http 包的实现，是通过传入一个结构体，把所有的配置都包含在内，并且这个结构体实现了很多方法。用户在传入时，就可以只传入一个结构体，把需要的必须参数和可选参数带上。
```go
package main
import (
  "log"
  "net/http"
  "time"
)
func main() {
  s := &http.Server{
  Addr: ":8080",
  Handler: nil,
  ReadTimeout: 10 * time.Second,
  WriteTimeout: 10 * time.Second,
  MaxHeaderBytes: 1 << 20,
}
  log.Fatal(s.ListenAndServe())
}

```

问题：
- 首先，必填参数的问题还是没有解决的
- 什么是必填参数，什么是选填参数，需要大量的文档来说明
- 这么传参我们是没有办法区分默认值的，通过指针我们可以通过判断是否等于 nil 来区分，因为大部分的场景下其实用默认值就可以了，这样做反而降低了使用体验



第四阶段，可以将必填参数通过函数参数字段传进去，而选填字段通过不定参数传入函数。
```go
//  对外暴露的，用户可以传入的选填参数
type DialOption struct {
    f func(*dialOptions)
}

//  具体实现创建链接的函数，前两个必填参数，后面是不定参数传入可选参数
func Dial(network, address string, options ...DialOption) (Conn, error) {
    //  生成一个 小写的 dialOptions ，也就是一份全配置，
    do := dialOptions{
        dial: net.Dial,
    }
    //  在这里可以修改 dialOptions 全配置的一些默认值
    ...
    //  这里遍历所有不定参数，修改 dialOptions 全配置的字段
    for _, option := range options {
        option.f(&do)
    } // ...
}

// 这里还有很多这样的函数，用户通过这样的函数，来生成可选配置的字段，传入 Dial 函数
func DialReadTimeout(d time.Duration) DialOption {
    //  返回 DialOption 对象，并且 配置 f 为修改某个字段
	return DialOption{func(do *dialOptions) {
		do.readTimeout = d
	}}
}
```

使用姿势：
```go
package main
import (
    "time"
    "github.com/go-kratos/kratos/pkg/cache/redis"
)
func main() {
    c, _ := redis.Dial("tcp", "127.0.0.1:3389",
    redis.DialDatabase(0),
    redis.DialPassword("hello"),
    redis.DialReadTimeout(10*time.Second))
}

```


优点：
- 把必填参数放在前面几位，保证参数必填，一眼就能看出来，减少沟通成本
- 可以在函数内部先初始化一个 defaultOption 然后用后面配置的函数进行修改即可


### 与配置文件结合

思路：

**将解析配置文件与加载配置文件解耦**


方法：
1. 使用 pb 作为配置文件，好处：可以添加验证规则
```go
syntax = "proto3";
import "google/protobuf/duration.proto";
package config.redis.v1;
// redis config.
message redis {
  string network = 1;
  string address = 2;
  int32 database = 3;
  string password = 4;
  google.protobuf.Duration read_timeout = 5;
}
```
2. 将 解析配置和加载配置解耦的方式来处理：

```go
//   将 配置文件 转成 config 结构体
func ApplyYAML(s *redis.Config, yml string) error {
  js, err := yaml.YAMLToJSON([]byte(yml))
  if err != nil {
    return err
  }
  return ApplyJSON(s, string(js))
}
// 将 Config 结构体 转成 redis 可以识别的 选项
func Options(c *redis.Config) []redis.Options {
  return []redis.Options{
    redis.DialDatabase(c.Database),
    redis.DialPassword(c.Password),
    redis.DialReadTimeout(c.ReadTimeout),
  }
}
```
3. 使用起来就很简单：
```go
func main() {
  // load config file from yaml.
  c := new(redis.Config)
  _ = ApplyYAML(c, loadConfig())
  r, _ := redis.Dial(c.Network, c.Address, Options(c)...)
}
```



## 配置总结

修改配置其实是一件比较危险的事情，很多时候我们缺乏足够的敬畏，因为现在在线的配置中心越来方便，所以修改的成本越来越低，大家就越来越随意，所以我们需要对配置的修改慎重一些。配置的目标：


- 避免复杂
- 多样的配置
- 简单化努力
- 以基础设施 -> 面向用户进行转变
- 配置的必选项和可选项
- 配置的防御编程
- 权限和变更跟踪
- 配置的版本和应用对齐，这个很多都没做到，经常应用回滚了配置没回滚，就出事故了
- 安全的配置变更：逐步部署、回滚更改、自动回滚