[toc]

# Golang Runtime - GC原理


## 概述

GC 其实也就是 Garbage Collection ，垃圾收集器。

![Garbage Collection](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Garbage_Collection.png?raw=true)

- 应用程序(mutator)会操作内存
- 内存分配器(Alloctor)，会在内存堆(Heap)上分配内存。
- 垃圾回收器(Collector)会将不用的变量释放



现代高级编程语言管理内存的方式分为两种：
- 手动。像 C、C++ 等编程语言使用手动管理内存的方式，**工程师编写代码过程中需要主动申请或者释放内存**；
- 自动。而 PHP、Java 和 Go 等语言使用自动的内存管理系统，**有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的 GC**。


**主流的垃圾回收算法**：
- 引用计数
- 追踪式垃圾回收

**Go 现在用的三色标记法就属于追踪式垃圾回收算法的一种。**



## 朴素的 Mark & Sweep (标记与清除)

### 过程

Mark Sweep 两个阶段：**标记(Mark)和 清除(Sweep)两个阶段**


两个重要阶段中的概念：
- **STW**
    - stop the world, GC 的一些阶段需要停止所有的 mutator（应用程序） 以确定当前的引用关系。这便是很多人对 GC 担心的来源，这也是 GC 算法优化的重点。
- **Root**
    - 根对象是 mutator（应用程序） 不需要通过其他对象就可以直接访问到的对象。比如全局对象，栈对象中的数据(如l var 等局部变量)等。
    - 通过Root对象。可以追踪到其他存活的对象。



这个算法就是严格按照追踪式算法的思路来实现的：
![标记算法过程](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Mark%E5%92%8CSweep.gif?raw=true)


过程：
- **Stop the World** ：停止应用程序
- **Mark**：通过 Root 和 Root 直接间接访问到的对象， 来寻找所有可达的对象，并进行标记。 
- **Sweep**：**对堆对象迭代**，已标记的对象置为标记。所有未标记的对象加入freelist， 可用于再分配。
- **Start the Wrold** ：开启应用程序


问题：
- 算法最大的问题是 GC 执行期间需要把整个程序完全暂停，朴素的 Mark Sweep 是整体 STW，并且分配速度慢，内存碎片率高。




### STW(stop the world) 的问题


标记过程需的要 STW，因为对象引用关系如果在标记阶段做了修改，会影响标记结果的正确。**也就是说，如果程序没有暂停直接标记，那么程序有可能会对某些已经标记过的对象进行修改，这样标记过程就不准确。**


- 1.3以前的版本使用**标记-清扫的方式，整个过程都需要 STW**。
- 1.3版本**分离了标记和清扫的操作，标记过程STW，清扫过程并发执行**。



**在 Go 1.3 版本，标记的时候 STW，而清除 Sweep 的时候并发执行。**


并发 GC 分为两层含义：
- 每个 mark 或 sweep 本身是多个线程(协程)执行的(concurrent)
    - concurrent 这一层是比较好实现的
    - GC 时整体进行 STW，那么对象引用关系不会再改变，对 mark 或者 sweep 任务进行分块，就能多个线程(协程) conncurrent 执行任务 mark 或 sweep。
- mutator(应用程序) 和 collector(垃圾处理器) 同时运行(background)
    - 而对于 backgroud 这一层, 也就是说 mutator 和 mark，sweep 同时运行，则相对复杂。
    - backgroup sweep 是比较容易实现的，因为 mark 后，哪些对象是存活，哪些是要被 sweep 是已知的，sweep 的是不再引用的对象。
    - sweep 结束前，这些对象不会再被分配到，所以 sweep 和 mutator 运行共存。无论全局还是栈不可能能访问的到这些对象，可以安全清理。
    - 也就是 mark 阶段 STW，而 Sweep 阶段，垃圾处理器可以与应用程序并行执行



**1.5版本在标记过程中使用三色标记法**。<u>标记和清扫都并发执行的，但标记阶段的前后需要 STW 一定时间来做 GC 的准备工作和栈的re-scan。</u>




## 三色标记法 Tri-color Mark & Sweep - 标记过程


### 原理

三色标记是对标记清除法的改进，标记清除法在整个执行时要求长时间 STW，Go 从1.5版本开始改为三色标记法
![三色标记法](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95.gif?raw=true)

过程：
- 初始将所有内存标记为白色
- 然后将 roots 加入待扫描队列(进入队列即被视为变成灰色)
- 然后使用并发 goroutine 扫描队列中的指针，如果指针还引用了其他指针，那么被引用的也进入队列（置为灰色），被扫描的对象视为黑色（被扫描的灰色对象变为黑色）。
- 不停循环，2、3步骤，最终内存中还是白色的对象，就是需要清除的内存对象

**白色、灰色、黑色三种颜色的意义：**

- **白色对象**：<u>潜在的垃圾</u>，其内存可能会被垃圾收集器回收。
- **黑色对象**：<u>活跃的对象</u>，包括不存在任何引用外部指针的对象以及从根对象可达的对象，垃圾回收器不会扫描这些对象的子对象。
- **灰色对象** ：<u>活跃的对象</u>，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。




### 扫描过程

一共有 67 个 size 范围, 8byte-32KB；每个size有两种类型(sizeclass)
- scan : 表示分配的对象包含指针，需要 GC Scan
- noscan, 表示分配的对象不包含指针，不包含指针的就不用GC scan

![扫描过程scan与noscan](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E6%89%AB%E6%8F%8F%E8%BF%87%E7%A8%8Bscan%E4%B8%8Enoscan.png?raw=true)



扫描过程：
- 垃圾收集器从 root 开始然后跟随指针递归整个内存空间。
- 分配于 noscan 的 span 的对象, 不会进行扫描。然而，此过程不是由同一个 goroutine 完成的，每个指针都排队在工作池中
- 然后，先看到的被标记为工作协程的后台协程从该池中出队，扫描对象，然后将在其中找到的指针排入队列。
- 持续上述步骤




### 三色标记法 - 整体染色流程

**染色流程：**

1. 一开始所有对象被认为是白色

![三色标记法-染色流程1](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95-%E6%9F%93%E8%89%B2%E6%B5%81%E7%A8%8B1.png?raw=true)


2. 根节点(stacks，heap，global variables)被染色为灰色，如果有 noscan 对象，直接染色为 黑色

![三色标记法-染色流程2](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95-%E6%9F%93%E8%89%B2%E6%B5%81%E7%A8%8B2.png?raw=true)


**一旦主流程走完，gc会：**

3. 选一个灰色对象，标记为黑色

![三色标记法-染色流程3](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95-%E6%9F%93%E8%89%B2%E6%B5%81%E7%A8%8B3.png?raw=true)


4. 遍历这个对象的所有指针，标记所有其引用的对象为灰色

![三色标记法-染色流程4](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95-%E6%9F%93%E8%89%B2%E6%B5%81%E7%A8%8B4.png?raw=true)

**最终直到所有对象需要被染色。**
最后，

- 黑色对象是内存中正在使用的对象
- 白色对象是要使用垃圾回收器回收的对象

**每一个 span 中有一个名为 gcmarkBits 的位图属性，该属性跟随扫描，如果正在使用，则为1，否则为0.**




## Write Barrier （写屏障）


### 问题抛出

1.5版本在标记过程中使用三色标记法。**回收过程主要有四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要 STW 一定时间来做 GC 的准备工作和栈的 re-scan。**

![Go各个版本GC的时间消耗](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Go%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%ACGC%E7%9A%84%E6%97%B6%E9%97%B4%E6%B6%88%E8%80%97.png?raw=true)




使用并发的垃圾回收，也就是多个 Mutator 与 Mark 并发执行，想要在并发或者增量的标记算法中保证正确性，我们需要**达成以下两种三色不变性(Tri-color invariant)中的任意一种：**
- **强三色不变性** ：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。
    - 也就是 活跃的对象不会指向需要释放的对象。
- **弱三色不变性** ：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。
    - 也就是 如果活跃对象指向了白色释放对象，那么必须有一个 灰色的带扫描的对象指向这个白色对象，这样灰色带扫描的对象扫描过后，会继续扫描这个白色对象。


可以看出：
- **一个白色对象被黑色对象引用，是注定无法通过这个黑色对象来保证自身存活的**
- 与此同时，**如果所有能到达它的灰色对象与它之间的可达关系全部遭到破坏，那么这个白色对象必然会被视为垃圾清除掉。** 
- 故当上述两个条件不满足时，就会出现对象丢失的问题。如果这个白色对象下游还引用了其他对象，并且这条路径是指向下游对象的唯一路径，那么他们也是必死无疑的。


![三色不变性导致的问题](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%B8%89%E8%89%B2%E4%B8%8D%E5%8F%98%E6%80%A7%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.png?raw=true)

过程：
- 一个灰色带扫描的对象 B 指向一个白色对象 C，另外有一个活跃的对象 A
- 这时候，应用程序将 活跃对象 A 指向了白色对象 C，这是可以的，因为B对象还没有扫描，C 会通过B进行扫描，变成黑色
- 但如果 应用程序 取消 灰色的B对象对白色 C 对象的指针，此时，活跃的 A 对象指向了 需要释放的 白色 C 对象，这是有问题的
- 最终，灰色的 B 对象扫描完成变成黑色，活跃A指向需要释放的白色对象C，这就造成了问题。
- 标记过程需的要 STW，因为对象引用关系如果在标记阶段做了修改，会影响标记结果的正确性。
- 灰色对象 B 中包含指向白色对象 C 的指针 e，对象 C 尚未被扫描，此时，如有其他程序，将 e 指针从 B 对象中删除，并将指向对象 C 的新指针 f插入到黑色对象 A 中，由于对象 A 早已完成扫描，对象 C 就会一直保持白色状态直到被回收。






#### 解决（阶段1）： Dijkstra 写屏障 

**解决**：

为了防止这种现象的发生，最简单的方式就是 STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是 STW 的过程有明显的资源浪费，对所有的用户程序都有很大影响，如何能在保证对象不丢失的情况下合理的尽可能的提高 GC 效率，减少 STW 时间呢？


Go 团队在实现上选择了**在标记阶段完成时暂停程序**、**将所有栈对象标记为灰色并重新扫描**，<u>在活跃 goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。</u>
1.  内存屏障只是对应一段特殊的代码；
2. 内存屏障这段代码在编译期间生成；
3. 内存屏障本质上在运行期间拦截内存写操作，相当于一个 hook 调用



插入屏障（Dijsktra写屏障）**拦截将白色指针插入黑色对象的操作，标记其对应对象为灰色状态**，这样就不存在黑色对象引用白色对象的情况了，满足强三色不变式，在插入指针 f 时将 C 对象标记为灰色。

![Dijsktra写屏障](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Dijsktra%E5%86%99%E5%B1%8F%E9%9A%9C.png?raw=true)

也就是说，在应用程序每次修改指针时，例如 A.Field = &C 时，会添加一段代码来做插入屏障的拦截，下面就是一小段伪代码：
```go
writePoint(slot, ptr):
	// 标记灰色
    shade(ptr)
    // 黑色指向白色
    *slot = ptr
```



总结：
- **如果对栈上的写做拦截，那么流程代码会非常复杂，并且性能下降会非常大，得不偿失。**
- **插入屏障，不在栈上执行**
- 根据局部性的原理来说，其实我们程序跑起来，大部分的其实都是操作在栈上，函数参数啊、函数调用导致的压栈出栈、局部变量啊，协程栈，这些如果也弄起写屏障，那么可想而知了，根本就不现实，复杂度和性能就是越不过去的坎。
- **Go 1.5 采用的就是只对堆上做拦截**



#### 写屏障拦截器的整个过程

1. 初始化 GC 任务，包括开启写屏障(write barrier)和开启辅助 GC(mutator assist)，统计 root 对象的任务数量等，**这个过程需要STW。**
2. 扫描所有 root 对象，包括全局指针和 goroutine(G) 栈上的指针(扫描对应 G 栈时需停止该 G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空，该过程后台并行执行。
3. 完成标记工作，**重新扫描(re-scan)全局指针和栈**。因为 Mark 和 mutator 是并行的，所以在 Mark 过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障(write barrier)记录下来，re-scan 再检查一下，**这个过程也是会 STW 的。**
4. 按照标记结果回收所有的白色对象，该过程后台并行执行。

![写屏障拦截的整个过程](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%99%E5%B1%8F%E9%9A%9C%E6%8B%A6%E6%88%AA%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B.png?raw=true)




#### 解决（阶段2）： Yuasa 删除写屏障 

**删除屏障也是拦截写操作的**，**但是是通过保护灰色对象到白色对象的路径不会断来实现的**。

<u>注意：删除写屏障是同时在 栈 和 堆上 执行的。因此少了插入写屏障最后的 recan 栈操作。</u>

如下图例中：<u>在删除指针 e 时将对象 C 标记为灰色，这样 C 下游的所有白色对象，即使会被黑色对象引用，最终也还是会被扫描标记的，满足了弱三色不变式。</u>**这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。**

![Yuasa删除写屏障](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Yuasa%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C.png?raw=true)



伪代码类似为：
```go
writePoint(slot, ptr):
    shade(*slot)
    // 如果下游是灰色的
    if current stack is prey
        shade(ptr)
    *slot = ptr
```




#### 解决（阶段3）： 混合写屏障 

插入屏障和删除屏障各有优缺点：
- Dijkstra 的插入写屏障：
    - 在标记开始时无需 STW，可直接开始，并发进行
    - 但结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活；
- Yuasa 的删除写屏障：
    - 需要在 GC 开始时 STW 扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象
    - 但结束时无需 STW。


**Go1.8 混合写屏障结合了Yuasa的删除写屏障和Dijkstra的插入写屏障**



**混合写屏障的具体操作：**

1. GC 开始将栈上的对象全部扫描并且标记为黑色。（之后不再进行第二次重复扫描，无需 STW）
2. GC 期间，任何在栈上创建的新对象，均为黑色
3. GC 期间，栈上不执行任何屏障操作。
4. 被删除的对象标记为灰色（删除写屏障）
5. 被添加的对象标记为灰色（插入写屏障）



**Golang 中的混合写屏障满足的是变形的弱三色不变式，同样允许黑色对象引用白色对象，白色对象处于灰色保护状态，但是只由堆上的灰色对象保护。**


由于结合了 Yuasa 的删除写屏障和 Dijkstra 的插入写屏障的优点:

**只需要在开始时并发扫描各个goroutine 的栈，使其变黑并一直保持，这个过程不需要 STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行 re-scan 操作了，减少了 STW 的时间。**


为了移除栈的重扫描过程，除了引入混合写屏障之外，**在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。**


![混合写屏障的过程](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E6%B7%B7%E5%90%88%E5%B1%8F%E9%9A%9C%E7%9A%84%E8%BF%87%E7%A8%8B.jpg?raw=true)







## Sweep


我们在 Mark 阶段的时候，提到了 gcmarkBits 位图，1 表示正则使用，0 表示可以释放。


Sweep 让 Go 知道哪些内存可以重新分配使用，然而，**Sweep 过程并不会处理释放的对象内存置为0(zeroing the memory)。而是在分配重新使用的时候，重新 reset bit。**


每个 span 内有一个 bitmap **allocBits**，表示**上一次 GC 之后每一个 object 的分配情况，1：表示已分配，0：表示未使用或释放。**


内部还使用了 uint64 allocCache(deBruijn)，加速寻找 freeobject。



GC 将会启动去释放不再被使用的内存。在标记期间，GC 会用一个位图 gcmarkBits 来跟踪在使用中的内存。
正在被使用的内存被标记为黑色，然而当前执行并不能够到达的那些内存会保持为白色。


现在，我们可以使用 gcmarkBits 精确查看可用于分配的内存。**Go 使用 gcmarkBits 赋值了 allocBits，这个操作就是内存清理。**


然而必须每个 span 都来一次类似的处理，需要耗费大量时间。**Go 的目标是在清理内存时不阻碍执行，并为此提供了两种策略。**
1. 在后台启动一个 worker 等待清理内存，一个一个 mspan 处理
    - 当开始运行程序时，Go 将设置一个后台运行的 Worker(唯一的任务就是去清理内存)，它将进入睡眠状态并等待内存段扫描。
2. 当申请分配内存时候 lazy 触发
    - 当应用程序 goroutine 尝试在堆内存中分配新内存时，会触发该操作。清理导致的延迟和吞吐量降低被分散到每次内存分配时。


![Sweep步骤1](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Sweep%E6%AD%A5%E9%AA%A41.png?raw=true)

![Sweep步骤2](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Sweep%E6%AD%A5%E9%AA%A42.png?raw=true)


过程：

- 清理内存段的第二种方式是即时执行。但是，由于这些内存段已经被分发到每一个处理器 P 的本地缓存 mcache 中，因此很难追踪首先清理哪些内存。这就是为什么 Go 首先将所有内存段移动到 mcentral 的原因。
- 然后，它将会让本地缓存 mcache 再次请求它们，去即时清理。
即时扫描确保所有内存段在保存资源的过程中都会得到清理，同时会保存资源以及不会阻塞程序执行。
- 由于后台只有一个 worker 在清理内存块，清理过程可能会花费一些时间。但是，我们可能想知道如果另一个 GC 周期在一次清理过程中启动会发生什么。在这种情况下，这个运行 GC 的 Goroutine 就会在开始标记阶段前去协助完成剩余的清理工作。
  



## STW - Stop The World

**在垃圾回收机制 (GC) 中，"Stop the World" (STW) 是一个重要阶段。**

顾名思义， 在 "Stop the World" 阶段，++当前运行的所有程序将被暂停， 扫描内存的 root 节点和添加写屏障 (write barrier)++.


Go 在1.9之后就只需要一次STW，刚开始的STW去掉了，在mark阶段开启 写屏障。写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间. 




- 这个阶段的第一步， 是 G0 抢占所有正在运行的 goroutine，被抢占之后， 这些 goroutine 会被悬停在一个相对安全的状态。
- 第二步，处理器 P (无论是正在运行代码的处理器还是已在 idle 列表中的处理器)， 都会被被标记成停止状态 (stopped)， 不再运行任何代码。 调度器把每个处理器的 M  从各自对应的处理器 P 分离出来， 放到 idle 列表中去。
- 对于 Goroutine 本身， 他们会被放到一个全局队列中等待。


![STW 过程](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/STW%E8%BF%87%E7%A8%8B.png?raw=true)


注意：

- 运行时中有 GC Percentage 的配置选项，默认情况下为100。
- 值表示在下一次垃圾收集必须启动之前可以分配多少新内存的比率。
- 将 GC 百分比设置为100意味着，基于在垃圾收集完成后标记为活动的堆内存量，下次垃圾收集前，堆内存使用可以增加100%。
- 如果超过2分钟没有触发，会强制触发 GC