# sync/atomic

[toc]




## 简介

代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。


针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是 Go 语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库 sync/atomic 提供。



## 方法大纲（都是指针操作）


### 1. 加减法

第一类 AddXXX 当需要添加的值为负数的时候，做减法，正数做加法
```go
func AddInt32(addr *int32, delta int32) (new int32)
func AddInt64(addr *int64, delta int64) (new int64)
func AddUint32(addr *uint32, delta uint32) (new uint32)
func AddUint64(addr *uint64, delta uint64) (new uint64)
func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)
```

### 2. 比较地址，并赋值操作


第二类 CompareAndSwapXXX CAS 操作， 会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功。

逻辑功能是：
```go
  if *addr == old {
    *addr = new
    return true
  }
  return false
```


```go
func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)
func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)
```


### 3. 取出值

第三类 LoadXXX ，从某个地址中取值
```go
func LoadInt32(addr *int32) (val int32)
func LoadInt64(addr *int64) (val int64)
func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
func LoadUint32(addr *uint32) (val uint32)
func LoadUint64(addr *uint64) (val uint64)
func LoadUintptr(addr *uintptr) (val uintptr)
```

### 4. 给对应地址赋值

第四类 StoreXXX ，给某个地址赋值
```go
func StoreInt32(addr *int32, val int32)
func StoreInt64(addr *int64, val int64)
func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
func StoreUint32(addr *uint32, val uint32)
func StoreUint64(addr *uint64, val uint64)
func StoreUintptr(addr *uintptr, val uintptr)
```

### 5. 交换操作

第五类 SwapXXX ，交换两个值，并且返回老的值

逻辑功能为：
```go
old = *addr
*addr = new
return old
```

```go
func SwapInt32(addr *int32, new int32) (old int32)
func SwapInt64(addr *int64, new int64) (old int64)
func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
func SwapUint32(addr *uint32, new uint32) (old uint32)
func SwapUint64(addr *uint64, new uint64) (old uint64)
func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)
```

### 6. Value 类型

最后一类 Value 用于任意类型的值的 Store、Load，这是 1.4 版本之后引入的，签名的方法都只能作用于特定的类型，引入这个方法之后就可以用于任意类型了。

```go
type Value
    func (v *Value) Load() (x interface{})
    func (v *Value) Store(x interface{})
```


Value的实现非常简单，就是包括一个空接口，可以保存任何类型的值，如下：
```go
type Value struct {
	v interface{}
}
```


下面看一下 Value 类型的两个方法，Store和Load。


#### 1. Store 方法

**Store 方法的定义：**

```go
func (v *Value) Store(x interface{})
```

**作用：**

将地址为 v 的值设置为 x。

注意：
- 调用 Store 的前提，是 *v 和 x 的类型必须一致，如果不一致，会报 panic
- 如果传入 x 的值为 nil，也会包 panic



**源码分析:**

首先定义了 ifaceWords 结构体，这个结构体其实就是 interface 的内部实现结构：
```go
type ifaceWords struct {
	typ  unsafe.Pointer
	data unsafe.Pointer
}
```


下面看一下 Store 方法的源码：
```go
func (v *Value) Store(x interface{}) {
	//  判断 x 的值 是否为nil，如果是nil，则 panic
	if x == nil {
		panic("sync/atomic: store of nil value into Value")
	}
	//  将 v 和 x 都转成 ifaceWords 地址的格式
	vp := (*ifaceWords)(unsafe.Pointer(v))
	xp := (*ifaceWords)(unsafe.Pointer(&x))
	
	//  不断的尝试
	for {
	    //  先取出 v 的类型 typ
		typ := LoadPointer(&vp.typ)
		//  如果 类型是空，那么说明是第一次 Store
		if typ == nil {
            //  调用 runtime 的方法禁止抢占，避免操作完成一半就被抢占了
            //  同时可以避免 GC 的时候看到 unsafe.Pointer(^uintptr(0)) 这个中间状态的值
			runtime_procPin()
			//  CAS操作，先比较 v 类型的地址对应的值 是否是 nil，如果不是nil，则返回false，如果是nil，则将 unsafe.Pointer(^uintptr(0)) 的值付给 v 类型
			if !CompareAndSwapPointer(&vp.typ, nil, unsafe.Pointer(^uintptr(0))) {
				runtime_procUnpin()
				continue
			}
			// 存储 data 的值
			StorePointer(&vp.data, xp.data)
			StorePointer(&vp.typ, xp.typ)
			//  调用 runtime 的方法，开启抢占
			runtime_procUnpin()
			return
		}
		//  如果判断发现这个类型是这个固定值，说明当前第一次赋值还没有完成，所以进入自旋等待
		if uintptr(typ) == ^uintptr(0) {
			continue
		}
		// 第一次赋值已经完成，判断新的赋值的类型和之前是否一致，如果不一致就直接 panic
		if typ != xp.typ {
			panic("sync/atomic: store of inconsistently typed value into Value")
		}
		StorePointer(&vp.data, xp.data)
		return
	}
}
```


#### 2. Load 方法

**Load 方法的定义：**
```go
func (v *Value) Load() (x interface{})
```

**作用：**

返回最近一次 v 被 Store 存储的值。

注意：
- 如果 v 没有被 Store 过，那么返回 nil



**源码分析:**
```go
func (v *Value) Load() (x interface{}) {
    //  将 v 转成 ifaceWords 地址的格式
	vp := (*ifaceWords)(unsafe.Pointer(v))
	//  将 v 的类型取出
	typ := LoadPointer(&vp.typ)
	//  下面的条件，表示 v 还没有被 Store 过，类型还是 nil
	if typ == nil || uintptr(typ) == ^uintptr(0) {
		// 如果没有 被 Store 过，那么直接返回 nil
		return nil
	}
	//  取出 v 的data 值
	data := LoadPointer(&vp.data)
	//  将 x 转成 ifaceWords 类型
	xp := (*ifaceWords)(unsafe.Pointer(&x))
	//  给 x 赋值 ，并返回
	xp.typ = typ
	xp.data = data
	return
}
```




## 使用 Value 的完整示例


在这个实例中，分别使用了 atomic 原子操作，和 RMutex 读写锁进行实现 单一写/多读 配置的操作：

```go
package benchmark

import (
	"sync"
	"sync/atomic"
	"testing"
)


//  配置结构体，模拟 1个写 / 多个读的操作
type Config struct {
	a []int
}

//  模拟 读取配置后的处理操作
func (c *Config) T() {}

//  使用 原子操作 Atomic 实现
func BenchmarkAtomic(b *testing.B) {
	//  定义一个 atomic.Value 类型
	var v atomic.Value
	//  首次 Store，为了将 v 的类型 定义为 Config 类型
	v.Store(&Config{})

	// 模拟 写 配置操作，将 a 数组，不断加1，死循环，不停的写
	go func() {
		i := 0
		for {
			i++
			// 写配置，并且存入到 v 中
			cfg := &Config{a: []int{i, i + 1, i + 2, i + 3, i + 4, i + 5}}
			v.Store(cfg)
		}
	}()

	//  模拟 读 配置操作，开启4个Goroutine来都配置
	var wg sync.WaitGroup
	for n := 0; n < 4; n++ {
		wg.Add(1)
		go func() {
			for n := 0; n < b.N; n++ {
				// 使用atomic Value 的load 读取v值
				cfg := v.Load().(*Config)
				//  模拟处理配置
				cfg.T()
			}
			wg.Done()
		}()
	}
	wg.Wait()
}

//  使用读写锁实现
func BenchmarkRWMutex(b *testing.B) {
	var l sync.RWMutex
	var cfg *Config

	//  模拟 写 配置
	go func() {
		i := 0
		for {
			i ++
			// 上写锁，修改配置
			l.Lock()
			cfg = &Config{a: []int{i, i + 1, i + 2, i + 3, i + 4, i + 5}}
			//  完成后，解锁
			l.Unlock()
		}
	}()

	//  模拟 读 操作，4个Goroutine读
	var wg sync.WaitGroup
	for n := 0; n < 4; n++ {
		wg.Add(1)
		go func() {
			for i := 0; i < b.N; i++ {
				//  读取时，加读锁
				l.RLock()
				cfg.T()
				//  读取完并完成操作后，解锁
				l.RUnlock()
			}
			wg.Done()
		}()
	}
	wg.Wait()
}
```


可以看一下 benchmark 的实现结果，
```go
C:\install-tools\goland-2020-3-2\golang-project\grpc-test\go_learn\benchmark>go test -bench=. config_test.go
goos: windows
goarch: amd64
cpu: Intel(R) Core(TM) i7-4800MQ CPU @ 2.70GHz
BenchmarkAtomic-8       284157844                4.540 ns/op
BenchmarkRWMutex-8       1103823              1146 ns/op
PASS
ok      command-line-arguments  5.031s

```

结论：**原子操作 atomi c的性能远高于读写锁 Mutex，但是实际情况中用什么，根据实际情况而定。**




## 写时复制

Copy-On-Write（写时复制） 思路在微服务降级或者 local cache 场景中经常使用。

**写时复制指的是，写操作时候复制全量老数据到一个新的对象中，携带上本次新写的数据，之后利用原子替换(atomic.Value)，更新调用者的变量。来完成无锁访问共享数据。**


也就是说，原子操作在写时时复制一份出来的，读的还是原来那份数据。

在一份共享资源，被多个调用者共同消费时，若出现修改资源的操作，我们并不直接对资源进行修改，而是对将资源修改操作划分为三个步骤：
- 第一：先将资源进行复制，复制出一个新的资源备份；
- 第二：往这个资源备份里面添加新的数据；
- 第三：将原先资源地址指向资源备份的地址。 



**atomic.Value 这种适合配置文件这种读特别多，写特别少的场景，因为他是 COW（Copy On Write）写时复制的一种思想，COW 就是指我需要写入的时候我先把老的数据复制一份到一个新的对象，然后再写入新的值。**

