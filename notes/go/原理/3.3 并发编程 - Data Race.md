# data race

[toc]





基本概念

**Share Memory By Communicating（使用通信来进行共享内存）**
传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。

Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励**使用 chan 在 goroutine 之间传递对数据的引用**。这种方法确保在给定的时间只有一个goroutine 可以访问数据。


注意：**不要通过共享内存来通信，而是应该通过通信来共享内存**




## data race（数据竞争）

**data race** 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。

**造成的问题：**

这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。


**Go解决方法：**

Go 工具引入了一个 **race detector**。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。



**使用方法：**

- 产品发布，不建议使用 `go build -race`
- 一般是在调查问题所在，或者专门的 test case 时，才使用
```bash
go test -race ./...
go build -race
```



### data race 的经典示例1

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

var wait sync.WaitGroup
var counter int

func Routine() {
	for i := 0; i < 2; i++ {
		// 将 counter + 1，注意 counter ++ 不是一个原子操作，也就是底层 汇编指令有三条
		counter = counter + 1
		time.Sleep(1 * time.Nanosecond)
	}
	//  表示 goroutine 结束
	wait.Done()
}


func main() {
	// 启动两个 goroutine
	for i := 0; i < 2; i++ {
		wait.Add(1)
		go Routine()
	}

	wait.Wait()
	fmt.Printf("Final Counter is : %d", counter)
}

```


注意：
- `time.sleep()`, 用来切换 Goroutine
- counter ++ 不是原子操作，在汇编时，转成三条语句执行，因此会造成 data race
- 最终的结果会出现随机的bug，理想结果是4，但是有可能是2等等
- 如果使用 `go build -race main.go`，会有下面的结果：
```bash
==================
WARNING: DATA RACE
Read at 0x000001175608 by goroutine 8:
  main.Routine()
      C:/install-tools/goland/golang-project/grpc-test/benchmark/main.go:15 +0x4e

Previous write at 0x000001175608 by goroutine 7:
  main.Routine()
      C:/install-tools/goland/golang-project/grpc-test/benchmark/main.go:15 +0x6a

Goroutine 8 (running) created at:
  main.main()
      C:/install-tools/goland/golang-project/grpc-test/benchmark/main.go:27 +0x6f

Goroutine 7 (running) created at:
  main.main()
      C:/install-tools/goland/golang-project/grpc-test/benchmark/main.go:27 +0x6f
==================
Final Counter is : 4Found 1 data race(s)

```
- 两个 Goroutime 会有data race



**修改办法**

实际上有三行汇编代码在执行以增加计数器。这三行汇编代码看起来很像原始的 Go 代码。在这三行汇编代码之后可能有一个上下文切换。尽管程序现在正在运行，但从技术上讲，这个 bug 仍然存在。我们的 Go 代码看起来像是在安全地访问资源，而实际上底层的程序集代码根本就不安全。


我们应该使用 Go 同步语义: Mutex，Atomic




### data race 的使用配置

可以通过设置 GORACE 环境变量，来控制 data race 的行为， 格式如下:
```
GORACE="option1=val1 option2=val2"
```

可选配置有：
| 配置 -            | - 默认值	- | - 说明                                                       |
| ----------------- | ------------- | ------------------------------------------------------------ |
| log_path          | stderr        | 日志文件的路径，除了文件路径外支持 stderr, stdout 这两个特殊值 |
| exitcode          | 66            | 退出码                                                       |
| strip_path_prefix | “”            | 从日志中的文件信息里面去除相关的前缀，可以去除本地信息，同时会更好看 |
| history_size      | 1             | per-goroutine 内存访问历史记录为 32K * 2 ** history_size，增加这个可以避免出现堆栈还原失败的错误，但是增加这个会导致使用的内存也跟着增加 |
| halt_on_error     | 0             | 用来控制第一个数据竞争错误出现后是否立即退出                 |
| atexit_sleep_ms   | 100           | 用来控制 main 退出之前 sleep 的时间                          |



### 案例二 在循环中启动 goroutine 引用临时变量

```
func main() {
	var wg sync.WaitGroup
	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i) // Not the 'i' you are looking for.
			wg.Done()
		}()
	}
	wg.Wait()
}
```

打印结果：
- 大概率是输出 5 个 5，因为在 for 循环的 i++ 会执行的快一些，所以在最后打印的结果都是 5
- 但是结果也是随机的，因为存储在 data race，某个 Goroutine 拿到局部变量 i 时，有可能已经被其他 Goroutine 修改了



### 案例三 一不小心就把变量共享了

```
func main() {
	res := make(chan error, 2)
	f1, err := os.Create("/tmp/file1")
	if err != nil {
		res <- err
	} else {
		go func() {
			// This err is shared with the main goroutine,
			// so the write races with the write below.
			_, err = f1.Write(data)
			res <- err
			f1.Close()
		}()
	}
}
```

结果：
- 上面代码中，go 启动的 Goroutine 中，会修改全局的 err，这点在平时的编程中需要注意。



### 关于原子操作的例子

```
package main

import "fmt"

type IceCreamMaker interface {
	// Great a customer.
	Hello()
}

type Ben struct {
	name string
}

func (b *Ben) Hello() {
	fmt.Printf("Ben says, \"Hello my name is %s\"\n", b.name)
}

type Jerry struct {
	name string
}

func (j *Jerry) Hello() {
	fmt.Printf("Jerry says, \"Hello my name is %s\"\n", j.name)
}

func main() {
	var ben = &Ben{name: "Ben"}
	var jerry = &Jerry{"Jerry"}
	var maker IceCreamMaker = ben

	var loop0, loop1 func()

	loop0 = func() {
		maker = ben
		go loop1()
	}

	loop1 = func() {
		maker = jerry
		go loop0()
	}

	go loop0()

	for {
		maker.Hello()
	}
}
```

解析：
- 这个例子，就是一个循环调用 Goroutine，但是上面的代码有可能会打印出：`Ben says, "Hello my name is Jerry"`
- 原因：
    - `maker = ben` 这种操作，不是原子操作，只有对 single machine word 进行赋值的时候才是原子的，机器字，就是操作系统一次可以处理的字节数，64位系统一般一次处理8个字节
    - 虽然go的代码只有一行，但是 interface 的实现，不是只有一个值，interface的结构如下：
    ```
    type interface struct {
       Type uintptr     // points to the type of the interface implementation
       Data uintptr     // holds the data for the interface's receiver
    }
    ```
    - interface 在 go 中其实是一个结构体，它包含了 type 和 data 两个部分，所以它的复制也不是原子的
    - 有可能 Type 赋值完，data 还没赋值，就到下一个Goroutine了。


### 总结

- 善用 data race 这个工具帮助我们提前发现并发错误
- 不要对未定义的行为做任何假设，虽然有时候我们写的只是一行代码，但是 go  编译器可能后面做了很多事情，并不是说一行写完就一定是原子的
- 即使是原子的出现了 data race 也不能保证安全，因为我们还有可见性的问题，上篇我们讲到了现代的 cpu 基本上都会有一些缓存的操作。
- 所有出现了 data race 的地方都需要进行处理