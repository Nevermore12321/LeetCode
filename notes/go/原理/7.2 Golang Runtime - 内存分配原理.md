[toc]


# 堆栈 & 内存模型


## 堆栈的定义


Go 有两个地方可以分配内存：

- 一个全局堆空间用来动态分配内存
- 另一个是每个 goroutine 都有的自身栈空间。



1. **栈**

注意点：

- **栈区的内存一般由编译器自动进行分配和释放**，其中存储着函数的入参以及局部变量
- 这些参数会随着函数的创建而创建，函数的返回而销毁。(通过 CPU push & release)。



2. **堆**

注意点：

- **堆区的内存一般由编译器和工程师自己共同进行管理分配**，交给 Runtime GC 来释放。
- 堆上分配必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描堆空间寻找不再被使用的对象。
- golang 会自动检测如果一段内存的使用，超出了其所在函数的作用域，编译器会自动将其分配在堆上



**栈分配廉价，堆分配昂贵**



## 逃逸分析

逃逸分析 ： **通过检查变量的作用域是否超出了它所在的栈来决定是否将它分配在堆上的技术，其中，变量的作用域超出了它所在的栈**。这种行为即被称为逃逸

逃逸分析在大多数语言里属于静态分析：在编译期由静态代码分析来决定一个值是否能被分配在栈帧上，还是需要“逃逸”到堆上。




**逃逸分析的优势：**

- 减少 GC 压力，栈上的变量，随着函数退出后系统直接回收，不需要标记后再清除
- 减少内存碎片的产生
- 减轻分配堆内存的开销，提高程序的运行速度



例如：
```go
func main() {
    num := getRandom()
    println(*num)
}

getRandom() *int {
    tmp := random.Intn(100)
    
    return &tmp
}
```

分析：
- 可以使用 `go build -gcflags '-m'` 来检测是否有逃逸行为
- 在 getRandom 函数的最后，返回了 tmp 的指针，tmp 指针已经除了 getRandom 函数的作用域，因此有逃逸行为发生


示例的过程分析：

**逃逸分析1：**

![逃逸分析1](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%901.png?raw=true)

1. main 函数执行，压栈，注意，栈是从上往下进行写入的
2. 调用 getRandom 函数，压栈，并且生成了一个 局部变量 tmp，目前也是保存在 栈 中


**逃逸分析2：**

![逃逸分析2](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%902.png?raw=true)


3. 在 getRandom 函数中返回了 &tmp 指针 ，在main函数中接收
4. 当 getRandom 函数执行结束后，会自定回收，这时候 main 函数中接收到的 变量地址就会无效，这就是 逃逸行为，编译器发现这种行为，会将该变量存入到 堆 上





注意：

- 当一个函数被调用时，会在两个相关的帧边界间进行上下文切换。从调用函数切换到被调用函数，如果函数调用时需要传递参数，那么这些参数值也要传递到被调用函数的帧边界中。
- Go 语言中帧边界间的数据传递是按**值传递**的。任何在函数 getRandom 中的变量在函数返回时，都将不能访问。Go 查找所有变量超过当前函数栈侦的，把它们分配到堆上，避免 outlive 变量。


**逃逸分析3：**

![逃逸分析3](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%903.png?raw=true)

5. 最终，会在堆上分配 tmp 值，然后将 tmp 的地址 返回。

注意：

- 上述情况中，num 变量不能指向之前的栈。
- Go 查找所有变量超过当前函数栈侦的，把它们分配到堆上，避免 outlive 变量。
- 变量 tmp 在栈上分配，但是它包含了指向堆内存的地址，所以可以安全的从一个函数的栈侦复制到另外一个函数的栈帧。



## 逃逸案例

还存在大量其他的 case 会出现逃逸，比较典型的就是 “多级间接赋值容易导致逃逸”，这里的**多级间接指的是**，对某个引用类对象中的引用类成员进行赋值（记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递）。**Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type(指针)** ：
- 一个值被分享到函数栈帧范围之外
- 在 for 循环外声明，在 for 循环内分配，同理闭包
- 发送指针或者带有指针的值到 channel 中
- 在一个切片上存储指针或带指针的值
- slice 的背后数组被重新分配了
- 在 interface 类型上调用方法
- .... go build -gcflags '-m'

多级赋值的例子：

```go
func test(i * int) {}

func main() {
    te := test
    tmp := 0
    
    test(&tmp)	// 不逃逸
    te(&tmp)	// 逃逸
}
```

上例中 `te` 的类型是 `func(*int)`，属于引用类型，参数 `*int` 也是引用类型，则调用 `te(&tmp)` 形成了为 `te` 的参数(成员) `*int` 赋值的现象，即 `te.i = &tmp` 会导致逃逸。代码中其他几种调用都没有形成**多级间接赋值**情况。

多级赋值举例：

- `[]interface{}`:  `data[0] = 100` 会导致 `100` 逃逸
- `map[string]interface{}`:  `data["key"] = "value"` 会导致 `"value"` 逃逸
- `map[interface{}]interface{}`:  `data["key"] = "value"` 会导致 `key` 和 `value` 都逃逸
- `map[string][]string`:  `data["key"] = []string{"hello"}` 会导致切片逃逸
- `map[string]*int`:  赋值时 `*int` 会 逃逸
- `[]*int`:  `data[0] = &i` 会使 `i` 逃逸
- `func(*int)`:  `data(&i)` 会使 `i` 逃逸
- `func([]string)`:  `data([]{"hello"})` 会使 `[]string{"hello"}` 逃逸
- `chan []string`:  `data <- []string{"hello"}` 会使 `[]string{"hello"}` 逃逸
- 以此类推，不一一列举了



# 连续栈


## 分段栈(Segmented stacks)


Go 应用程序运行时，每个 goroutine 都维护着一个自己的栈区，这个栈区只能自己使用不能被其他 goroutine 使用。

栈区的初始大小是 2KB (比 x86_64 架构下线程的默认栈2M 要小很多)，在 goroutine 运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在 64 位系统上是 1GB。


golang 的内存内存分配演进：

- v1.0 ~ v1.1 — 最小栈内存空间为 4KB
- v1.2 — 将最小栈内存提升到了 8KB
- v1.3 — 使用连续栈替换之前版本的分段栈
- v1.4 — 将最小栈内存降低到了 2KB


![分段栈](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%88%86%E6%AE%B5%E6%A0%88.png?raw=true)

如果所示，如果左边的栈区大小不够了，会扩展创建一个新的，并且原先的栈会有一个链接，指向新的栈区。好处就是没有拷贝。



**分段栈的 Hot split 问题**

![分段栈的 hot split 问题1](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%88%86%E6%AE%B5%E6%A0%88%E7%9A%84hot-split%E9%97%AE%E9%A2%981.png?raw=true)

![分段栈的 hot split 问题2](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%88%86%E6%AE%B5%E6%A0%88%E7%9A%84hot-split%E9%97%AE%E9%A2%982.png?raw=true)

图一分析：
- 假设 main 函数、F 函数、G 函数，已经沾满了真个 8k 的栈区
- 当 G 函数中再次调用了 H 函数时，就会触发创建新的 栈区，如果时分段栈的话，就会扩展一个栈区，并且原始栈区会指向新的栈区
- 当函数 H 执行结束后，就需要释放该栈区。

图二分析：
- 当 G 函数会循环的调用 H 函数时，每次循环 调用 H 函数，创建栈区，执行完毕后，释放。进入下一次循环
- 会频繁的进行创建和释放


总结：

- 分段栈的实现方式存在 “hot split” 问题，如果栈快满了，那么下一次的函数调用会强制触发栈扩容。
- 当函数返回时，新分配的 “stack chunk” 会被清理掉。
- 如果这个函数调用产生的范围是在一个循环中，会导致严重的性能问题，频繁的 alloc/free。


Go 不得不在1.2版本把栈默认大小改为 8KB，降低触发热分裂的问题，但是每个 goroutine 内存开销就比较大了。直到实现了连续栈(contiguous stack)，栈大小才改为2KB。




## 连续栈(Contiguous stacks)

![连续栈](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E8%BF%9E%E7%BB%AD%E6%A0%88.png?raw=true)


**连续栈**

- 采用复制栈的实现方式，在热分裂场景中不会频发释放内存，
- 即不像分配一个新的内存块并链接到老的栈内存块，而是**会分配一个两倍大的内存块并把老的内存块内容复制到新的内存块里，当栈缩减回之前大小时，我们不需要做任何事情。**



**连续栈的扩容步骤：**

- runtime.newstack 分配更大的栈内存空间
- runtime.copystack 将旧栈中的内容复制到新栈中
- 将指向旧栈对应变量的指针重新指向新栈
- runtime.stackfree 销毁并回收旧栈的内存空间
- **如果栈区的空间使用率不超过1/4，那么在垃圾回收的时候使用 runtime.shrinkstack 进行栈缩容，同样使用 copystack**




**栈扩容**

- 在每次调用一个函数前，Go 运行时判断栈空间是否足够，所以在 call function 中会插入 runtime.morestack，用来判断栈是否足够。
- 但每个函数调用都判定的话，成本比较高。
- 在编译期间通过计算 sp（栈指针）、func stack framesize（调用函数会占用多大的栈空间） 确定需要哪个函数调用中插入 runtime.morestack 进行判断。


什么时候会插入 runtime.morestack 进行判断会不会进行栈扩容呢？

![栈扩容](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E8%BF%9E%E7%BB%AD%E6%A0%88%E6%89%A9%E5%AE%B9.png?raw=true)


- 当函数是叶子节点，且栈帧小于等于 112 ，不插入指令
- 当叶子函数栈帧大小为 120 -128 或者 非叶子函数栈帧大小为 0 -128，SP < stackguard0，插入指令
- 当函数栈帧大小为 128 - 4096。SP - framesize < stackguard0 - StackSmall，插入指令
- 大于 StackBig ，  SP-stackguard+StackGuard <= framesize + (StackGuard-StackSmall)，插入指令




# 内存管理

## 内存优化的常用手段

1. 小对象结构体合并
    - 例如 ：
    - struct A { struct B }
    - new A 就只创建 一个 对象
2. bytes.Buffer：写入磁盘
    - 在创建 bytes.Buffer 时，分配一个大小，避免后面空间不够造成对象的二次创建
3. slice, map 预创建
    - 大小提前分配
4. 长调用栈
    - 假设一个 goroutine 调用时间过长，有可能会调用 Goroutine 的扩容，这是非常消耗资源的
    - 最好一个函数的操作简洁、简短
    - 如果在一个 Goroutine 中有很多 defer 代码时，消耗资源也比较大
5. 避免频繁创建临时对象
    - 避免频繁创建临时对象，然后频繁的使用 GC 去回收资源，消耗资源比较大
6. 字符串拼接：strings.Builder
7. 不必要的 memory copy
8. 分析内存逃逸




## 内存管理主要两个问题

TCMalloc 是 Thread Cache Malloc 的简称，是 Go 内存管理的起源，Go 的内存管理是借鉴了TCMalloc


1. 内存碎片

**内存碎片**：随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。

内存碎片的示意图如下：

![内存碎片](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87.png?raw=true)

图示分析：
- P1 申请 4 个字节
- P2 连续申请了 5 个字节
- P3 接着连续申请了 6 个字节
- 此时，释放掉 P2 ，也就是释放了 5 个字节，这时，已经构成了 内存碎片，P1 和 P3 中间的一段内存区域
- 接着，P4 想要申请 6 个字节，显然，P1 和 P3 中间的一段内存不够存储，只能再往后申请，这就造成了 内存碎片


解决：
- 为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片。


2. 大锁

**大锁** ：同一进程下的所有线程共享相同的内存空间，它们申请内存时需要加锁，如果不加锁就存在同一块内存被2个线程同时访问的问题。



## 内存分配中的几个重要概念

![内存分配中的几个重要概念](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5.png?raw=true)


我们需要先知道几个重要的概念：
- **page**: 内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 page 为单位的。
- **span**: 内存块，一个或多个连续的 page 组成一个 span。
- **sizeclass**: 空间规格，每个 span 都带有一个 sizeclass，标记着该 span 中的 page 应该如何使用。
- **object**: 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object。假设 object 的大小是 16B，span 大小是 8K，那么就会把 span 中的 page 就会被初始化 8K / 16B = 512 个 object。




## 小于 32Kb 的内存分配


### mcache

![内存管理中的mcache](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84mcache.png?raw=true)


**mcache**：
- 当程序里发生了 32kb 以下的小块内存申请时，Go 会从一个叫做的 mcache 的本地缓存给程序分配内存。
- 这样的一个内存块里叫做 mspan，它是要给程序分配内存时的分配单元。
- 在 Go 的调度器模型里，每个线程 M 会绑定给一个处理器 P，在单一粒度的时间里只能最多处理运行一个 goroutine，每个 P 都会绑定一个上面说的本地缓存 mcache。
- 当需要进行内存分配时，当前运行的 goroutine 会从 mcache 中查找可用的 mspan。从本地 mcache 里分配内存时不需要加锁，这种分配策略效率更高。




申请内存时都分给他们一个 mspan 这样的单元会不会产生浪费？

- 其实 mcache 持有的这一系列的 mspan 并不都是统一大小的，而是按照大小，从 8kb 到 32kb 分了大概 67*2 类的 mspan。也就是有不同的 大小梯度。
- 每个内存页分为多级固定大小的“空闲列表”，这有助于减少碎片。类似的思路在 Linux Kernel、Memcache 都可以见到 Slab-Allactor。



### mcentral

如果分配内存时 mcachce 里没有空闲的对口 sizeclass 的 mspan 了，Go 里还为每种类别的 mspan 维护着一个 **mcentral**。


**也就是说，分配内存时，先从 mcache 获取，如果没有可用的内存空间，再从 mcentral 中获取内存、**

![内存管理中的mcentral](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84mcentral.png?raw=true)


mcentral 的作用是:
- 为所有 mcache 提供切分好的 mspan 资源。
- 每个 central 会持有一种特定大小的全局 mspan 列表，包括已分配出去的和未分配出去的。 
- 每个 mcentral 对应一种 mspan，当工作线程的 mcache 中没有合适(也就是特定大小的)的mspan 时就会从 mcentral 去获取。
- mcentral 被所有的工作线程共同享有，存在多个 goroutine 竞争的情况，因此从 mcentral 获取资源时需要加锁。
- **mcentral 里维护着两个双向链表，nonempty 表示链表里还有空闲的 mspan 待分配。empty 表示这条链表里的 mspan 都被分配了object 或缓存 mcache 中**。




### 小于 32Kb 的内存分配过程

1. 程序申请内存的时候，mcache 里已经没有合适的空闲 mspan了，那么工作线程就会像下图这样去 mcentral 里去申请。mcache 从 mcentral 获取和归还 mspan 的流程：

![内存分配过程1](https://github.com/Nevermore12321/LeetCode/blob/blog/go进阶训练营/内存分配过程1.png?raw=true)

- 获取加锁；从 nonempty 链表找到一个可用的mspan；并将其从 nonempty 链表删除；将取出的 mspan 加入到 empty 链表；将 mspan 返回给工作线程；解锁。

- 归还加锁；将 mspan 从 empty 链表删除；将mspan 加入到 nonempty 链表；解锁。

mcentral 是 sizeclass 相同的 span 会以链表的形式组织在一起, 就是指该 span 用来存储哪种大小的对象。



2. 当 mcentral 没有空闲的 mspan 时，会向 mheap 申请。而 mheap 没有资源时，会向操作系统申请新内存。mheap 主要用于大对象的内存分配，以及管理未切割的 mspan，用于给 mcentral 切割成小对象。

![内存分配过程2](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B2.png?raw=true)

mheap 中含有所有规格的 mcentral，所以当一个 mcache 从 mcentral 申请 mspan 时，只需要在独立的 mcentral 中使用锁，并不会影响申请其他规格的 mspan。



## 小于 16b 内存分配

**对于小于16字节的对象(且无指针)，Go 语言将其划分为了tiny 对象。**

- 划分 tiny 对象的主要目的是为了处理极小的字符串和独立的转义变量。
- json 的基准测试表明，使用 tiny 对象减少了12%的分配次数和20%的堆大小。
- **tiny 对象会被放入 class 为 2 的 span 中。也就是 16b 的 sizeclass 梯队中**


![小于16b的内存分配过程](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%B0%8F%E4%BA%8E16b%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png?raw=true)

- 首先查看之前分配的元素中是否有空余的空间
- 如果当前要分配的大小不够，例如要分配16字节的大小，这时就需要找到下一个空闲的元素
- **tiny 分配的第一步是尝试利用分配过的前一个元素的空间，达到节约内存的目的。**



## 大于 32kb 内存分配

Go 没法使用工作线程的本地缓存 mcache 和全局中心缓存 mcentral 上管理超过32KB的内存分配，所以**对于那些超过32KB的内存申请，会直接从堆上(mheap)上分配对应的数量的内存页(每页大小是8KB)给程序。**




## 内存分配整体流程

![内存分配整体流程](https://github.com/Nevermore12321/LeetCode/blob/blog/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png?raw=true)

**一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。**

- Go 在程序启动时，会向操作系统申请一大块内存，由 mheap 结构全局管理(现在 Go 版本不需要连续地址了，所以不会申请一大堆地址)
- Go 内存管理的基本单元是 mspan，每种 mspan 可以分配特定大小的 object
- mcache, mcentral, mheap 是 Go 内存管理的三大组件，mcache 管理线程在本地缓存的 mspan；mcentral 管理全局的 mspan 供所有线程