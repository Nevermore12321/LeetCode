# Chan

[toc]




## Golang Gorotine 间通信的准则

**Do not communicate by sharing memory; instead, share memory by communicating.**

**不要通过共享内存来通信，而是使用通信来共享内存**



## Channel

channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。


chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。
- 当创建的 chan 没有容量时，称为无缓冲通道。
- 使用容量创建的 chan 称为缓冲通道。


### Unbuffered Channels - 无缓冲信道

```go
ch := make(chan struct{})
```

注意：
- 无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。
- 当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有 goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。
- 当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。
- **无缓冲信道的本质是保证同步。**
- 也就是，向 无缓冲 chan 中发送数据时，会阻塞，直到有人从 chan 中读取，才会继续。接收数据，同样如此。
- 问题就是：代价大，延迟时间未知。



### Buffered Channels - 有缓冲信道

```go
ch := make(chan struct{}, 10)
```

注意：
- buffered channel 具有容量，因此其行为可能有点不同。
- 当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine 并使其等待缓冲区可用。
- 如果通道中有空间，发送可以立即进行，goroutine 可以继续。
- 当 goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。
- 如果通道中有数据，接收可以立即进行，goroutine 可以继续。




## chan 使用场景

- Timing out
- Moving on
- Pipeline
- Fan-out, Fan-in
- Cancellation
    - Close 先于 Receive 发生(类似 Buffered)。
    - 不需要传递数据，或者传递 nil。
    - 非常适合去掉和超时控制。
- Contex


### 1. 超时控制
```go
timeout := make(chan bool, 1)
go func() {
    time.Sleep(1 * time.Second)
    timeout <- true
}()

select {
case <-ch:
    // a read from ch has occurred
case <-timeout:
    // the read from ch has timed out
}
```


### 2. 继续执行 Moving on

只要有一个 Goroutine 返回结果，就继续往后面执行，也就是选出一个执行最快的
```go
func Query(conns []Conn, query string) Result {
    ch := make(chan Result)
    for _, conn := range conns {
        go func(c Conn) {
            select {
            case ch <- c.DoQuery(query):
            default:
            }
        }(conn)
    }
    return <-ch
}
```

### 3. pipeline 

pipeline 也就是一级一级的将 chan 传下去
- gen 返回 chan ，用于读取数据，gen 函数内向 这个 chan 写数据
- sq 传入 gen 的 chan，再次返回 chan，sq 函数读取 gen 的 chan，平方后，写入到 返回的 chan
```go
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}


func sq(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

```

### Fan-out, Fan-in

Fan-out(扇出): 多个函数可以从同一通道读取，直到该通道关闭; 也就是从一个 chan 发散出去 读

这提供了一种在一组工作人员之间分配工作的方法，以并行化 CPU 使用和 I/O。


Fan-in(扇入): 一个函数可以从多个输入读取数据，并通过将多个输入通道复用到单个通道，直到所有输入通道都被关闭，该通道在所有输入通道关闭时关闭。也就是从多个 chan 读取到同一个函数点

参考连接：
https://blog.golang.org/pipelines