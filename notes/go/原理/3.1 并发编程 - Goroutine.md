# 并发编程

[toc]




## Goroutine



### 线程和进程


- 操作系统会为该应用程序创建一个**进程**。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。
- **线程**是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。**一个进程从一个线程开始，即主线程**，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。
- 无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。



### Goroutine 和 Parallelism(并行)


**Goroutine**

- Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。
- 操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的**逻辑处理器中运行(P)**。
- 即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。


**并发与并行**
- 并行性是指两个或多个事件在同一时刻发生。
    - 在多 cpu 的操作系统中，才有并行性
    - 也就是在同一时刻，多个进程可以同时运行在不同的 cpu 上
    - 并行的关键是你有同时处理多个任务的能力。
    - 并行的"同时"是同一时刻可以多个进程在运行(处于running)
- 并发性是指两个或多个事件在同一时间间隔发生。
    - 并发描述的是一种现象。在宏观上看，并发指的是在一个时间间隔内，多个指令同时执行，但围观来看，这些指令也有可能不是同时，而是每个指令执行一会，然后下一个执行执行，切换到很快，因此可以看成是同时执行。
    - 并发的关键是你有处理多个任务的能力，不一定要同时。
    - 并发的"同时"是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种 OS 欺骗用户的现象。



**Concurrency is not Parallelism.**

- **并发不是并行**。
- 并行是指两个或多个线程同时在不同的处理器执行代码。
- 如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。
- 但是，**要获得真正的并行性，需要在具有多个物理处理器的计算机上运行程序**。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。
- 也就是说，逻辑处理器（P）中有很多的 Goroutine ，而 P 中有关联了一个线程 M（如果多线程的话，就关联多个线程M），然后逻辑处理器会把某个 Goroutine 放到线程M中运行



### 不要创建一个你不知道何时退出的 goroutine

如果要启动 Goroutine，关键要看两个问题：
- Goroutine 什么时候结束
- 怎么能够让这个 Goroutine 结束




分析下面的代码：
```
package main

import (
	"log"
	"net/http"
	_ "net/http/pprof"
)

func setup() {
	// 这里面有一些初始化的操作
}


func server() {
	go func() {
		mux := http.NewServeMux()
		mux.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {
			w.Write([]byte("pong"))
		})

		// 主服务
		if err := http.ListenAndServe(":8080", mux); err != nil {
			log.Panicf("http server err: %+v", err)
			return
		}
	}()
}

func pprof() {
	// 辅助服务，监听了其他端口，这里是 pprof 服务，用于 debug
	go http.ListenAndServe(":8081", nil)
}


func main() {
	setup()

	// 主服务
	server()

	// for debug
	pprof()

	select {}
}
```

问题：
- 一般在main函数中，添加 go 关键字，开启异步，这样写，没有人知道 server 和 pprof 会在内部开启 go 异步执行
- main 函数其实也是在一个 Goroutine 中运行的，这样 main 函数不会结束，server 函数不会结束， pprof 函数也不会结束
- 当 main 函数退出时，server 和 pprpf 函数仍旧不会退出, 造成 Goroutine 泄露
- 当server 或 pprof 函数任意一个退出时，另一个都会继续运行，理想是，只要某一个监听程序退出，整个程序退出。
- main 函数当中什么也没做，有可能会造成资源浪费
- 没有办法手动退出 server 和 pprof 函数的 Goroutine
- log.Fatal() 和 log.panic() 函数，一般只在 main 函数和 init 函数中执行，而且这两个函数退出后，不会执行 defer 操作。




注意：
1. **执行 go 关键字，启动 Goroutine 一定是调用者决定的。一般在函数内部不添加。**
2. **一定要知道启动的 Goroutine 什么时候结束**
3. **你要有办法能够让启动的 Goroutine 结束**




修改后的代码为：
```
package main

import (
	"context"
	"log"
	"net/http"
)

func serve(addr string, handler http.Handler, stop <-chan struct{}) error {
	s := http.Server{
		Addr: addr,
		Handler: handler,
	}

	//  在内部启动一个 Goroutine，用来控制 监听线程的结束
	go func() {
		//  如果 stop chan 收到结束信号, 调用 shutdown 接口，否则，阻塞等待
		<- stop
		err := s.Shutdown(context.Background())
		if err != nil {
			panic(err)
		}
	}()

	return s.ListenAndServe()
}



func main() {
	//  done chan 用来判断某个 Goroutine 是否有 error
	done := make(chan error, 2)
	//  stop chan 用来手动结束某个 Goroutine， 做到只要有一个服务退出了那么另外一个服务也会随之退出
	stop := make(chan struct{})

	//  在 main 函数中 使用 go 关键字 启动 Goroutine
	go func() {
		done <- serve("0.0.0.0:8080", nil, stop)
	}()
	go func() {
		done <- serve("0.0.0.0:8081", nil, stop)
	}()

	// stoped 用于判断当前 stop 的状态
	var stoped bool
	// 这里循环读取 done 这个 channel
	// 只要有一个退出了，我们就关闭 stop channel
	for i := 0; i < cap(done); i++ {
		//  有一个退出，就会抛出 err
		if err := <- done; err != nil {
			log.Printf("server exit err: %+v", err)
		}
		if !stoped {
			stoped = true
			close(stop)
		}
	}
}
```



### 将是否启动 Goroutine 留给调用者决定

上面的例子讲过了

### 防止 Goroutine 泄露

```
func leak() {
    ch := make(chan int)
    
    go func() {
        val := <- ch
        fmt.Println(val)
    }()
}
```


上面这个函数是会造成 Goroutine 泄露的，因为 这个函数内部定义了也给 channel，外部是无法发送信号给 Goroutine，让其结束，因此这个 Goroutine 会一直等待



### 总结 Goroutine 使用三大原则：

1. 把是否启动 Goroutine 留给调用者
2. 知道 Goroutine 什么时候结束
3. 能够手动控制启动的 Goroutine 结束



一个好的例子：
```
package main

import (
	"context"
	"fmt"
	"time"
)

//  定义 Tracker 结构体，里面有两个 channel，用来控制 Goroutine
type Tracker struct {
	//  用于向 Goroutine 中传递参数
	ch chan string
	//  用于管控生命周期
	stop chan struct{}
}

//  Tracker 结构体的 New 函数
func NewTracker() *Tracker {
	return &Tracker{
		ch: make(chan string, 10),
	}
}

//  Event 函数，传入 context 用于管控生命周期， 判断是否超时
//  也就是数据的提供者
func (t *Tracker) Event(ctx context.Context, data string) error {
	select {
	//  向 ch 中传递 data 参数
	case t.ch <- data:
		return nil
	//  超时控制
	case <-ctx.Done():
		return ctx.Err()
	}
}

//  Run 函数 模拟处理操作的 Goroutine，留给调用者判断是否启用 Goroutine
//  也就是用来消费数据
func (t *Tracker) Run() {
	//  遍历 t.ch 信道，有数据则处理
	for data := range t.ch {
		//  模拟处理操作
		time.Sleep(1 * time.Second)
		fmt.Println(data)
	}

	//  处理完成后，给 stop 信道发送信号，关闭 goroutine
	t.stop <- struct{}{}
}

//  Shutdown 函数，用于手动结束 goroutine
func (t *Tracker) Shutdown(ctx context.Context) {
	//  关闭 传参 信道
	close(t.ch)
	//  这里判断是否超时
	select {
	case <-t.stop:
	case <-ctx.Done():
	}
}

func main() {
	tr := NewTracker()
	//  启动一个 消费者来消费数据，也就是 异步的 处理逻辑
	go tr.Run()

	//  向消费者中传递数据，也就是希望处理的数据
	//  传三条数据，处理也就是需要三秒
	_ = tr.Event(context.Background(), "test1")
	_ = tr.Event(context.Background(), "test2")
	_ = tr.Event(context.Background(), "test3")

	//  创建处理超时操作, 2s后超时
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2*time.Second))

	defer cancel()
	tr.Shutdown(ctx)
	// 结果应该是，在超时的 2s 内，Run函数能处理几个数据，就打印几个， 最终结果，打印了两个
}

```

注意：
- `for i := range channel` 用法，如果channel是有缓冲的信道，并且里面数据时，当关闭信道后，for range channel 会把所有数据读取后，在结束。

