# Error实践

[toc]




## Error 与 Panic

### Panic 使用场景


- 在程序启动的时候，如果有强依赖的服务出现故障时 panic 退出
- 在程序启动的时候，如果发现有配置明显不符合要求， 可以 panic 退出（防御编程）
- 其他情况下只要不是不可恢复的程序错误，都不应该直接 panic 应该返回 error
- 在程序入口处，例如 gin 中间件需要使用 recover 预防 panic 程序退出
- 在程序中我们应该避免使用野生的 goroutine
    - 如果是在请求中需要执行异步任务，应该使用异步 worker ，消息通知的方式进行处理，避免请求量大时大量 goroutine 创建
    - 如果需要使用 goroutine 时，应该使用统一的 Go 函数进行创建，这个函数中会进行 recover ，避免因为野生 goroutine panic 导致主进程退出


### Error 使用注意点

2. error 应该是函数的最后一个返回值，当 error 不为 nil 时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待
3. 错误处理的时候应该先判断错误， `if err != nil` 出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套.
4. 在应用程序中出现错误时，使用 `errors.New` 或者 `errors.Errorf` 返回错误
5. 如果是调用应用程序的其他函数出现错误，请直接返回，如果需要携带信息，请使用 `errors.WithMessage`
```go
func (u *usecese) usecase2() error {
    name, err := u.repo.getUserName(uid)
    if err != nil {
        return errors.WithMessage(err, "其他附加信息")
    }

    // 其他逻辑
    return nil
}
```
6. 如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用 errors.Wrap 添加堆栈信息
    - 切记，不要每个地方都是用 errors.Wrap 只需要在错误第一次出现时进行 errors.Wrap 即可
    - 根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 repository 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 ORM 库时需要去修改上层代码
    - 注意我们在基础库，被大量引入的第三方库编写时一般不使用 errors.Wrap 避免堆栈信息重复
```go
func f() error {
    err := json.Unmashal(&a, data)
    if err != nil {
        return errors.Wrap(err, "其他附加信息")
    }

    // 其他逻辑
    return nil
}
```
7. 禁止每个出错的地方都打日志，只需要在进程的最开始的地方使用 %+v 进行统一打印，例如 http/rpc 服务的中间件
8. 错误判断使用 errors.Is 进行比较
```go
err := A()
if errors.Is(err, io.EOF){
	return nil
}
```
9 错误类型判断，使用 `errors.As` 进行赋值

```go
func f() error {
    err := A()

    var errA errorA
    if errors.As(err, &errA){
    	// ...
    }

    // 其他逻辑
    return nil
}
```
10. 对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档
11. 不需要返回，被忽略的错误必须输出日志信息
12. 同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数
13. 对同一个类型的错误，采用相同的模式



### Error 和 Panic 的不同


**Panic**
- 会直接退出，是致命错误
- 如果使用 panic recover 进行处理的话，会有很多问题：
    - 性能问题
    - 容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出
    - 不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理
- 对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic



**Error**
- 简单。
- 考虑失败，而不是成功(Plan for failure, not success)。
- 没有隐藏的控制流。
- 完全交给你来控制 error。
- Error are values




### Error 的实现

在 errors 的官方 package 中，源码是这样定义 Error 的：
```
package errors

func New(text string) error {
	return &errorString{text}
}

type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
```

- New() 函数返回 error 类型，error 其实是一个实现了 Error() 方法的接口
```
type error interface {
	Error() string
}
```
- New() 函数中返回的时 errorString 的指针，思考为什么返回指针，而不是直接返回值？
    - 解答：**因为如果直接返回值，那么在比较两个 error 是否相等时，就只会比较字符串的值，而不是比较其地址，有歧义。**
- 我们经常使用 `errors.New()` 来返回一个 error 对象。



## error type: 错误类型与判断


### Sentinel Error

哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式。


例如，在 io 标准库中，有很多：
```
var EOF = errors.New("EOF")

var ErrUnexpectedEOF = errors.New("unexpected EOF")

var ErrNoProgress = errors.New("multiple Read calls return no data or error")
```

**我们在外部判定的时候一般使用等值判定或者使用 errors.Is 进行判断**

```
if err == io.EOF {
	//...
}

if errors.Is(err, io.EOF){
	//...
}
```


**缺点**

将 error 当做包的 API 暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限

**结论:** 

尽可能避免 sentinel errors。我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。



### Error types

Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。
```
//  自己实现 error 接口
type MyError struct {
	Msg string
	File string
	Line int
}

func (err *MyError) Error() string {
	return fmt.Sprintf("%s:%d: %s", err.File, err.Line, err.Msg)
}

func test() error {
	return &MyError{
		Msg:  "Something happened",
		File: "test.go",
		Line: 42,
	}
}
```

**优点**
与错误值相比，错误类型的一大改进是它们能够包装底层错误以提供更多上下文。

**缺点**

调用者要使用类型断言和类型 switch，就要让自定义的 error 变为 public。这种模型会导致和调用者产生强耦合，从而导致 API 变得脆弱。

**结论:** 

结论是尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于出错的更多上下文，但是 error types 共享 error values 许多相同的问题。

因此，我的建议是避免错误类型，或者至少避免将它们作为公共 API 的一部分。



### Opaque errors


不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好。只需返回错误而不假设其内容


我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值
```
//  错误类型的各个错误行为的方法，是内部变量，不能被外部引入
type temporary interface {
	Temporary() bool
	Timeout() bool
}

//  判断错误是否是某种行为，或某种类型的方法
func IsTemporary(err error) bool {
	te, ok := err.(temporary)
	return ok && te.Temporary()
}

//  判断错误是否是某种行为，或某种类型的方法
func IsTimeout(err error) bool {
	te, ok := err.(temporary)
	return ok && te.Timeout()
}

```

这种方式我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值



## Error 处理


在 go 中常常会存在大量的 if err 代码，下面介绍两种常见的减少这种代码的方式

### 1. 使用更好的方法调用减少错误处理


sc.Scan 之后一个 if err 的判断都没有，极大的简化了代码，这是因为在 sc.Scan 做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁

```
// 统计文件行数
func count(r io.Reader) (int, error) {
	var (
		br    = bufio.NewReader(r)
		lines int
		err   error
	)

	for {
		// 读取到换行符就说明是一行
		_, err = br.ReadString('\n')
		lines++
		if err != nil {
			break
		}
	}

	// 当错误是 EOF 的时候说明文件读取完毕了
	if err != io.EOF {
		return 0, err
	}

	return lines, err
}

func count2(r io.Reader) (int, error) {
	var (
		sc    = bufio.NewScanner(r)
		lines int
	)

	for sc.Scan() {
		lines++
	}

	return lines, sc.Err()
}
```


### 2. 自己封装

自己调用一些重复方法，并且每次需要判断 err 时，可以在外层在封装一层，来处理err


例如：文件处理，再次write后，都要判断err：
```
_, err = fd.Write(p0[a:b])
if err != nil {
    return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
    return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
    return err
}
// and so on
```


这时候，就可以将 write 函数重新封装，把 err 的判断卸载封装的函数内部，这样只需要在最后一次使用 wirte 函数时，判断一次err即可

```
//  封装 writer 接口，添加一个error
type errWriter struct {
    w   io.Writer
    err error
}

//  重新实现 wirte 方法，其内部使用 Writer.Write() 函数，但在调用前，判断err
func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}


//  使用
ew := &errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// and so on
if ew.err != nil {
    return ew.err
}
```



## Wrap erros

- 错误要被日志记录。
- 应用程序处理错误，保证100%完整性。
- 之后不再报告当前错误。



处理 Error 有一些问题：
- 如果有错误必须要处理，或者向上抛出，如果不处理，value 的值不可估计
- 在日志记录的时候，如何打印堆栈信息，也就是在哪个文件第几行报错
- 不能在每一层出现错误时，都打印日志，这样会有日志噪音
- 错误应该只被处理一次。



这就需要 Error 的封装。


推荐使用 `github.com/pkg/errors` 对 error 进行 wrap

`github.com/pkg/errors` 源码中，对原生的 error 进行了二次封装，既有 stack 信息，也有 msg 信息

```
//  stack信息，也就是错误发生的文件，行号，具体内容
type withStack struct {
	error
	*stack
}

//  Error 的 msg 信息
type withMessage struct {
	cause error
	msg   string
}

```


使用很简单：
- 只要在最上层 err 出现的地方，调用一次 `errors.Wrap(err, "Some Err Msg")`
- 后面在捕获到这个 err 时，就不必要在 wrap 了，只需要添加
    - `errors.WithStack(err)`: 添加堆栈信息
    - `errors.WithMessage(err, "msg")` : 添加err信息
```
package main

import (
	"fmt"
	"github.com/pkg/errors"
	"io/ioutil"
	"os"
	"path/filepath"
)

func ReadFile(path string) ([]byte, error) {
	//  在最上层 wrap 一次 Open 的 err
	file, err := os.Open(path)
	if err != nil {
		return nil, errors.Wrap(err, "Open Failed")
	}
	defer file.Close()

	//  在最上层 wrap 一次 Read 的 err
	buf, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, errors.Wrap(err, "Read Failed")
	}

	return buf, nil
}

func ReadConfig() ([]byte, error) {
	home := os.Getenv("Home")
	//  下面调用 ReadFile 函数
	config, err := ReadFile(filepath.Join(home, ".settings.xml"))
	//  这里就不用再处理 err 了，如果出错了，只需要添加 msg 即可
	return config, errors.WithMessagef(err, "could not read config")
}

func main() {
	_, err := ReadConfig()
	if err != nil {
		fmt.Printf("Original error: %T %v \n", errors.Cause(err), errors.Cause(err))
		fmt.Printf("Stack trace: \n%+v\n", err)
		os.Exit(1)
	}
}

```


打印结果为，（可以看到有堆栈的信息）
```
Original error: *fs.PathError open .settings.xml: The system cannot find the file specified. 
Stack trace: 
open .settings.xml: The system cannot find the file specified.
Open Failed
main.ReadFile
	C:/install-tools/goland-2020-3-2/golang-project/grpc-test/go_learn/main.go:15
main.ReadConfig
	C:/install-tools/goland-2020-3-2/golang-project/grpc-test/go_learn/main.go:31
main.main
	C:/install-tools/goland-2020-3-2/golang-project/grpc-test/go_learn/main.go:37
runtime.main
	C:/install-tools/go-1-16/src/runtime/proc.go:225
runtime.goexit
	C:/install-tools/go-1-16/src/runtime/asm_amd64.s:1371
could not read config

```


github.com/pkg/errors 使用姿势
- 在你的应用代码中，使用 errors.New 或者  errors.Errorf 返回错误。 
- 如果在应用中，调用其他的函数，通常简单的直接返回。 
- 如果和其他库进行协作，例如 go 基础库、github 第三方库、或者自己开发的基础库，考虑使用 errors.Wrap 或者 errors.Wrapf 保存堆栈信息。同样适用于和标准库协作的时候。 
- 直接返回错误，而不是每个错误产生的地方到处打日志。
- **在程序的顶部或者是工作的 goroutine 顶部(请求入口)，使用 %+v 把堆栈详情记录。**
- **使用 errors.Cause 获取 root error，再进行和 sentinel error 判定。**
- **也就是最底层的 err，需要 wrap**


总结：
- Packages that are reusable across many projects only return root error values.
    - 选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同(kit 库的 sql.ErrNoRows)。
- If the error is not going to be handled, wrap and return up the call stack. 
    - 这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句。确定您记录的上下文是足够多还是太多的一个好方法是检查日志并验证它们在开发期间是否为您工作。    
- Once an error is handled, it is not allowed to be passed up the call stack any longer.
    - 一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零(比如降级处理中，你返回了降级数据，然后需要 return nil)。