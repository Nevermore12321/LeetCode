

[toc]



# 前置知识：递归

**递归函数**，简单来说，就是自己调用自己，但是一定要注意终止条件。

## 递归过程



递归示例：

```go
// GetMax 获取数组中的最大值
func GetMax(nums []int) int {
	return process(nums, 0, len(nums) - 1)
}

// 返回 L~R 上的最大值
func process(nums []int, L, R int) int {
	// 递归终止条件
	if L == R {
		return nums[L]
	}

	// 找出 middle 值
	// 右移 相当于 除以 2
	mid := L + ((R - L) >> 2)

	var left = process(nums, L, mid)
	var right = process(nums, mid + 1, R)
	if left < right {
		return right
	} else {
		return left
	}
}
```

上面递归过程的简单分析如下图：

![递归过程分析](https://github.com/Nevermore12321/LeetCode/blob/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E9%80%92%E5%BD%92demo%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png?raw=true)

递归函数：

- 递归过程，其实就是压栈出栈的过程
- **递归调用的过程，就是一颗二叉树，压栈出栈的顺序，其实就是一个后序遍历。**



## 剖析递归的时间复杂度

计算递归过程的时间复杂度，可以使用 **master 公式**。注意：使用 master 公式的前提是，一定要是均分，二分或者三分等，也就是说子问题的规模是等量的。例如上面例子中就是二分，`process(nums, L, mid)` 和 `process(nums, mid + 1, R)`

**master 公式为：**
$$
T(N) = a * T(\frac {N} {b}) + O(N^d)
$$

- **$\log_b {a} > d$  -----> 复杂度为 $O(N^{\log_b {a}})$** 
- **$\log_b {a} < d$  -----> 复杂度为 $O(N^d)$**
- **$\log_b {a} = d$  -----> 复杂度为 $O(N^d * log_b {N})$**



其中：

- $N$ - 表示母问题（原始问题）中的规模为 $N$。
- $a$ - 表示母问题一公分解程了几个子问题，也就是首次调用时，使用了几次递归。
- $b$ - 表示通过递归分解后，子问题的规模为 $\frac {N} {b}$，也就是说，原始分体，通过分解，拆分成了几次递归（首次调用时）
- $d$ - 表示除了递归操作，剩下其他操作总共的时间复杂度为：$O(N^d)$



以上一小节中的 process 递归函数为例，假设要求一个长度为 N 的数组中的最大值，那么可以使用 process 递归求解。那么根据 master 公式，就可以计算出递归的时间复杂度。首先分析：

- 母问题，也就是原始问题中，数组的长度为 $N$，因此规模就为 $N$
- 由于母问题分解后，采取二分，子问题规模是等量的，也就是从中间分开，左边右边分别递归，子问题的规模就变成了  $\frac {N} {2}$，也就是说 $b = 2$
- 分解后的母问题变成了两个子问题，因此 $a = 2$
- 除了递归子问题调用之外，其他的代码时间复杂度为 $O(1)$

得出了最终的 master 公式为：$T(N) = 2 * T(\frac {N} {2}) + O(1)$。再根据 a，b，d的大小判断出，$\log_b {a} = \log_2 {2} = 1 > d = 0$ 。因此世界复杂度就是   $O(N^{\log_b {a}}) = O(N)$ 

# 归并排序

**归并排序**：要将一个数组排序，可以先（递归的）将它分成两半分别排序，然后将结果归并起来。

注意：
- **归并排序**最吸引人的性质就是**保证将任意长度为 $N$ 的数组排序所需时间和 $NlogN$ 成正比。**
- **归并排序所需的额外空间和 $N$ 成正比。**


## 原地归并方法

### 归并操作流程
**归并操作**：即将两个有序的数组归并成一个更大的有序数组。

归并操作的流程分析图:

![归并操作的流程分析图](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%8E%9F%E5%9C%B0%E5%BD%92%E5%B9%B6%E6%95%B0%E7%BB%84%E5%88%86%E6%9E%90.png?raw=true)


### 归并操作伪代码
```
__MERGE(A, low, mid, high)
    //  __MERGE 函数是将 A[low, mid] 和 A[mid+1, high] 归并
    //  并且 A[low, mid] 和 A[mid+1, high] 分别有序
    //  i 表示左半部分的下标，j 表示右半部分的下标
    i <- low
    j <- mid + 1
    
    //  初始化辅助数组，将A中的 low-high 拷贝到 aux 辅助数组中
    aux = A
    
    //  归并开始
    for k <- low to A.length - 1
        //  i > mid 表示左半部分已经结束，只剩右边 
        if i > mid 
            A[k] = aux[j]
            j ++
        //  j > high 表示右半部分已经结束，只剩左边
        else if j > high
            A[k] = aux[i]
            i ++
        //  aux[i] < aux[j] 表示左边i号元素小，取左边元素
        else if aux[i] < aux[j]
            A[k] = aux[i]
            i ++
        //  aux[i] > aux[j] 表示右边j号元素小，取右边元素
        else 
            A[k] = aux[j]
            j ++
```


### 归并操作golang实现
```go
func __merge(nums []int, l, mid, r int) {
	// 将 nums[l, mid], nums[mid+1, r] 进行归并

	// 开辟辅助空间，并且将原数组复制到辅助数组
	aux := make([]int, r - l + 1)
	for i := l; i <= r; i++ {
		aux[i - l] = nums[i]
	}

	// i、j 分别表示 辅助数组 左右两部分的 下标
	// 设置下标，i 从 l 开始， j 从 mid+1 开始
	var (
		i  = l
		j  = mid + 1
	)

	//  k 表示 原数组 l-r 的位置
	for k := l; k <= r; k++ {

		if i > mid { 					// 说明 左半部分结束，还剩下右半部分，不需要比较，直接复制，右边+1
			nums[k] = aux[j]
			j ++
		} else if j > r {				// 说明 右半部分结束，还剩下左半部分，不需要比较，直接复制，左边+1
			nums[k] = aux[i- ]
			i ++
		} else if aux[i-l] < aux[j-l] {			// 都未完成，且左边的小，将左边的复制，左边+1
			nums[k] = aux[i - l]
			i ++
		} else {									//  都未完成，且右边的小，将右边的复制，右边+1
			nums[k] = aux[j - l]
			j ++
		}
	}
}
```



## 自顶向下的归并排序

**自顶向下**：就是将数组从上到下，先分，再合，也就是使用分治思想。

如果能将两个子数组排序，那么就能通过归并两个子数组来将整个数组排序。


### 自顶向下的归并排序图解

![自顶向下的归并排序图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif?raw=true)


### 自顶向下的归并排序递归过程分析

- 自顶向下的归并排序是**分治思想**的典型应用。
- 自顶向下的归并排序利用**递归**，相当于分组，当分组只剩下一个元素后，开始**归并**，也就是上面讲的原地归并方法，__MERGE函数。


![递归过程分析](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png?raw=true)



### 自顶向下的归并排序递归伪代码
- 归并排序的递归函数伪代码：
```go
//  该函数用于递归，将 A[low, high] 排序
__MERGESORT(A, low, high)
    // 递归退出条件
    if low >= high 
        return
    mid <- low + (high - low) / 2
    //  将左半边排序
    __MERGESORT(A, low, mid)
    //  将右半边排序
    __MERGESORT(A, mid+1, high)
    //  两边排完序后，进行归并
    __MERGE(A, low, mid,                                                        )
```
- 归并排序的主函数伪代码：
```go
// 主函数很简单，调用 递归函数即可
MERGESORT(A)
    __MERGESORT(A, 0, A.length - 1)
```

### 自顶向下的归并排序递归golang实现
```go
func __merge(nums []int, l, mid, r int) {
	// 将 nums[l, mid], nums[mid+1, r] 进行归并

	// 开辟辅助空间，并且将原数组复制到辅助数组
	aux := make([]int, r - l + 1)
	for i := l; i <= r; i++ {
		aux[i - l] = nums[i]
	}

	// i、j 分别表示 辅助数组 左右两部分的 下标
	// 设置下标，i 从 l 开始， j 从 mid+1 开始
	var (
		i = l
		j = mid + 1
	)

	//  k 表示 原数组 r-l 的位置
	for k := l; k <= r; k++ {
		if i > mid {				// 说明 左半部分结束，还剩下右半部分，不需要比较，直接复制，右边+1
			nums[k] = aux[j - l]	// aux 索引从 0 开始
			j++
		} else if j > r {			// 说明 右半部分结束，还剩下左半部分，不需要比较，直接复制，左边+1
			nums[k] = aux[i - l]
			i++
		} else if aux[i - l] < aux[j - l] {	// 都未完成，且左边的小，将左边的复制，左边+1
			nums[k] = aux[i - l]
			i++
		} else {					//  都未完成，且右边的小，将右边的复制，右边+1
			nums[k] = aux[j - l]
			j++
		}

	}
}
```



## 自顶向下归并排序算法分析

### 时间复杂度

可以看过程分析的树状图，可以发现：
- 每个节点都表示一个MERGESORT()方法通过__MERGE() 方法归并而成的子数组。
- **这棵树一共有 $n$ 层，且 $n = logN$ 层**
- 对于其中任意一层 $k$ ，自顶向下的第k层有 $2^{k}$ 个子数组
- 每个数组的长度为  $2^{n-k}$ ，**每个子数组归并最多需要比较 $2^{n-k}$ 次**
- 因此，每层的比较次数为 $2^k+2^{n-k}=2^n$，**那么所有层一共需要的比较次数为 $n2^n=logN2^{logN}=NlogN$**


因此：
- > **对于长度为 $N$ 的任意数组，自顶向下的归并排序需要  $\frac12 NlogN$ 至 $NlogN$ 次比较**
- > **对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlogN$ 次**  
  > 每次归并最多需要访问数组 $6N$ 次，$2N$ 次用来复制，$2N$ 次用来将排好序的元素移动回去，另外最多比较 $2N$ 次

也可以使用 master 公式，来求解归并排序的时间复杂度，首先分析 a，b，d 三个参数

- 原始数组的长度为 N
- 归并排序使用取中间 mid 进行二分，因此子问题一共调用了两次递归，$a = 2$
- 二分，因此子问题是等量的，等分成 2，因此子问题的规模为 $T(\frac {N} {2})$
- 在归并的规程中，i 往 mid 方向移动，j 往 r 的方向移动，总共需要遍历 N 次，因此，除了递归外的时间复杂度为 $O(N)$，因此 $d = 1$

综上，master 公式为 $T(N) = 2 * T(\frac {N} {2}) + O(N)$，根据 $log_b {a} = log_2 {2} = 1 = d = 1$，因此，归并排序的时间复杂度为：$O(N * log_2 {N})$

### 空间复杂度

**归并过程需要一个辅助数组，因此空间复杂度为 $O(N)$**

### 归并排序优缺点

- 优点：
    - 归并排序只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序，可以用归并排序处理数百万甚至更大规模的数组，这是插入排序和选择排序做不到的。
- 缺点：
    - 辅助数组所使用的额外空间和N的大小成正比
    - 在大量的递归操作，会耗费一些时间，这就导致，有些归并排序耗时要比希尔排序大。



## 自顶向下归并排序的优化

### 优化1，对小规模数组使用插入排序

**优化步骤**：  

由于递归会使小规模问题中的调用过于频繁，会耗费许多实践，因此，对小规模的子数组使用插入排序处理，比如长度小于15的子数组使用插入排序，一般可将归并排序的运行时间缩短10%-15%。


### 优化2，测试数组是否已经有序

如果在归并两个子数组时，两个子数组整体已经有序，就不需要在遍历比较了，可以直接比较 $A[mid]$ 和 $A[mid+1]$，如果 $A[mid] <= A[mid+1]$，那么就可以跳过__MERGE()方法了。


### 两种优化的golang实现
```go
// 优化后的插入排序
func insertionSort(nums []int, l, r int) {
	for i := l; i <= r; i++ {
		var (
			j = i
			tmp = nums[i]
		)
		for ; j > l && tmp < nums[j - 1]; j-- {
			nums[j] = nums[j - 1]
		}
		nums[j] = tmp
	}
}

//  归并排序的优化，
func __mergeSortAdvanced(nums []int, l, r int) {
	//  递归结束的条件，如果 数组长度 <= 15 ，则直接使用插入排序，并返回
	//  优化1 小规模数组 n <= 15 ，使用插入排序
	if r - l <= 15 {
		insertionSort(nums, l, r)
		return
	}
	//  如果 长度 > 15 继续递归
	mid := l + (r - l) / 2
	__mergeSortAdvanced(nums, l, mid)
	__mergeSortAdvanced(nums, mid + 1, r)

	//  由于左半部分的最大值 nums[mid] 比 右半部分的最小值 nums[mid+1] 还要小，说明整个数组有序，不需要归并，此外其他情况需要归并
	//  优化2 对有序数组的跳过
	if nums[mid] > nums[mid + 1] {
		__merge(nums, l, mid, r)
	}
}

func MergeSortAdvanced(nums []int) {
	__mergeSortAdvanced(nums, 0, len(nums) - 1)
}
```


### 归并排序优化后的时间对比
```bash
ShellSort :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  0.2328659 seconds 
	10000000元素，乱序程度 1000000:  0.3627899 seconds 
MergeSort :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  1.3432265 seconds 
	10000000元素，乱序程度 1000000:  1.6360542 seconds 
MergeSortAdvanced :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  0.2788596 seconds 
	10000000元素，乱序程度 1000000:  1.1533132 seconds 
```

可以看到结果：
- 希尔排序还是一如既往的快
- 归并排序算法的优化后，对于近乎有序的数组有显著的提高，对于乱序的数组，提高不明显。


## 自底向上的归并排序

### 自底向上归并排序的步骤


**步骤**
1. 首先进行的是两两归并，也就是把每个元素想象成一个大小为 1 的数组
2. 然后是四四归并，将两个大小为 2 的数组归并成一个有 4 个元素的数组
3. 然后是八八归并，一直下去
4. 在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小，但是 归并方法 Merge 不是问题。


**自底向上归并排序的图解**
![自底向上归并排序的图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png?raw=true)



### 自底向上归并排序的golang实现
```go
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func MergeSortBT(nums []int) {
	var N = len(nums)

	// sz 表示每一轮子数组的长度
	for sz := 1; sz < N; sz += sz {
		//  lo 表示要归并的两个数组的首元素索引， lo+sz-1 表示 mid 元素的索引，lo+sz+sz-1 表示子数组的尾元素索引
		// 最后两个要归并的两个子数组，最后一个有可能不够 sz 的长度，因此去剩下的 N-1
		for lo := 0; lo < N - sz; lo += sz + sz {
			__merge(nums, lo, lo + sz - 1, min(lo + sz + sz - 1, N - 1))
		}
	}
}
```

### 自底向上归并排序耗时对比
```bash
MergeSort :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  1.3553312 seconds 
	10000000元素，乱序程度 1000000:  1.7118617 seconds 
MergeSortAdvanced :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  0.2994992 seconds 
	10000000元素，乱序程度 1000000:  1.2759504 seconds 
MergeSortBT :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  1.4616702 seconds 
	10000000元素，乱序程度 1000000:  1.6634278999999998 seconds 
```

可以看到：
- 自底向上的归并排序，比自顶向下的归并排序耗时差不多。
- **对于长度为 $N$ 的任意数组，自底向上的归并排序需要 $1/2NlogN$ 至 $NlogN$ 次比较，最多访问数组 $6NlogN$ 次**


## 归并排序总结

- **没有任何基于比较的算法能够保证使用少于 $log(N!)-NlogN$ 次比较将长度为N的数组排序。**
- **归并排序是一种渐进最优的基于比较的排序算法**

# 快速排序

快速排序流行的原因是它**实现简单**、**适用于各种不同输入数据、且在一般应用中比其他排序算法要快得多**。

## 快速排序的特点

- 快速排序是**原地排序，只需要很小的一个辅助栈**
- 快速排序**将长度为 N 的数组排序所需要的时间与 $N\log{N}$ 成正比**。
- 快速排序**内层循环比大多数排序算法都要短小**，在实际中速度更快。

## 快速排序的基本算法

快速排序是一种分治的排序算法。与归并排序算法相比：

- 归并排序，重点在于合（merge）
- 快速排序，重点在于分（partition）

快速排序的图解：

![快速排序](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif)

快速排序算法的基本思想是：（$a[lo...hi]$ 排序)

- 随机选一个 $a[j]$ 将其放在合适的位置上，使得：
    - 所有 j 前面的数，都小于等于 $a[j]$
    - 所有 j 后面的数，都大于  $a[j]$
- 然后将数组，从 j 的位置分开，这就是 partition 的过程，这个时候，j 位置上的数其实已经排好了。
- 递归调用将其他位置上的元素排序。

【思考】：为什么快速排序不需要最后的 merge 过程？
答：因为快速排序通过 j 位置将数组分成两部分，这这两部分有一个特点，就是前半部分全部 $<= a[j]$；后半部分全部 $> a[j]$。这样，其实将前半部分和后半部分分别排好序，这个数组就已经天然有序了，不需要 merge 过程。



快速排序的切分方法 partition 的具体步骤：

1. 先随意的取 $a[lo]$ 作为切分元素，也就是最终会被排定的元素。（后面优化会随机取）
2. 从数组的左端开始向右扫描，$i$ 记为 lo 位置，直到找到一个大于等于 $a[lo]$ 的元素，$i$ 就表示该元素的位置
3. 从数组的有段开始向左扫描，$j$ 记为 hi 位置，直到找到一个小于等于 $a[lo]$ 的元素，$j$ 就表示该元素的位置
4. $a[i]$ 和 $a[j]$ 显然是没有排定的元素，交换 $a[i]$ 和 $a[j]$ 的位置，重复 2 - 4 步骤
5. 如果做指针 $i$ 与 右指针 $j$ 相遇时，将切分元素  $a[lo]$ 与左子数组（小于等于切分元素的数组）的最右侧的元素  $a[j]$ 交换位置
6. 返回切分元素排定的位置 $j$

![快速排序切分partition](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png?raw=true)

快速排序的关键在于切分，最终切分后的数组满足以下条件：

- 对于某个 $j$ ，$a[j]$ 已经排定
- $a[lo]$ 到 $a[j-1]$ 中的所有元素都不大于 $a[j]$
- $a[j+1]$ 到 $a[hi]$ 中的所有元素都不小于 $a[j]$



下面是一个实际的快速排序的切分示例：

![快速排序示例](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.png?raw=true)



## 快速排序的 Golang 实现

```go
func __swap(s, d *int) {
	*s, *d = *d, *s
}

// 将数组切分为 arr[lo...j-1], a[j], a[j+1...hi]
func partition(arr []int, lo, hi int) int {
	// 选择第一个为 切分元素
	v := arr[lo]

	// 左右扫描指针
	i := lo + 1
	j := hi
	
	// 循环从两边找
	for true {

		// 从左向右扫描，找到左边第一个 >= v 的元素
		for i <= hi && arr[i] < v {
			i++
		}

		// 从右向左扫描，找到右边第一个 < v 的元素
		for j >= lo && arr[j] > v {
			j--
		}

		// 控制循环结束
		if i > j {
			break
		}

		//  现在 arr[i] > v arr[j] <= v ，交换后，继续上述步骤
		__swap(&arr[i], &arr[j])

		i++
		j--
	}

	// 跳出循环后，
	// i 表示 左边 + 1 元素 -> 也就是右边第一个元素
	// j 表示 右边 + 1 元素 -> 也就是左边最后一个元素
	__swap(&arr[j], &arr[lo])
	return j
}

func __quickSort(arr []int, lo, hi int) {
	if lo >= hi {
		return
	}

	j := partition(arr, lo, hi)
	__quickSort(arr, lo, j)
	__quickSort(arr, j+1, hi)
}

func QuickSort(arr []int) {
	__quickSort(arr, 0, len(arr) - 1)
}
```

## 快速排序性能特点

### 快排的优点

- 快速排序切分方法中的内循环会使用一个递增的索引将数组和一个定值比较，简洁短小。例如，归并排序在内循环中还需要移动数据。
- 快速排序的比较次数很少，排序的效率以来切分数组的效果，这就依赖于切分元素的在整个数组中的位置。

**快速排序的最好情况时每次都正好能将数组对半分。**

根据 master 公式： $T(N) = a * T(\frac {N} {b}) + O(N^d)$

- 如果每次都是二分，那么复杂度就是 $O(Nlog{N})$

- 如果每次选择的数是随机的，那么 master 公式就是：
    $$
    T(N) = T(\frac {N} {3}) + T(\frac {2N} {3}) + O(N^d)  	\\
    
    T(N) = T(\frac {N} {4}) + T(\frac {3N} {4}) + O(N^d)  	\\
    
    T(N) = T(\frac {N} {5}) + T(\frac {4N} {5}) + O(N^d)	 \\
    
    ...
    $$

- 将上面的公式所有的求概率平均，最终结果，同样也是 $O(Nlog{N})$



### 快速排序的缺点

- 在切分不平衡时，上面的快速排序算法可能会很低效。
- 例如，在已经接近有序的数组，切分元素每次选择第一个，就只能切分出一个元素，最终快速跑排序会退化成 $O(N^2)$



## 快速排序的优化

### 1. 切换到插入排序

与归并排序的优化相同， 在排序到底的情况，使用插入排序优化。

对于多少个元素使用插入排序呢？一般在 5 ~ 15 之间个数的数组，使用插入排序比较合适。

因此，在 `__quickSort()` 函数中，将 

```go
if lo >= hi {
    return
}
```

替换为：

```go
if lo >= hi {
    InsertionSort(arr, lo, hi)
}
```



### 2. 优化选择切分元素

归并排序每次的切分都是等分的。因此不需要在切分元素优化。而快速排序不一定是等分的。

之前我们选择元素是直接取数组的第一个，如果整个数组是接近有序的，那么每次取数组的第一个元素作为切分元素，就会每次只切出一个元素，快速排序的复杂度将为$O(N^2)$

对于这种情况的优化，有两种办法：

- 不使用第一个元素作为切分元素，而是随机选择一个中间元素。
- 使用三取样切分，也就是使用子数组的一小部分的中位数来作为切分元素，但是代价就是需要计算中位数。



#### 2.1 随机切分的 Golang 实现

```go
func __insertionSortForQuick(arr []int, lo, hi int) {
	for i := lo; i <= hi; i++ {
		tmp := arr[i]
		j := i
		for ; j > lo && arr[j - 1] > tmp; j-- {
			arr[j] = arr[j - 1]
		}

		arr[j] = tmp
	}
}

func __partitionAdvanced(arr []int, lo, hi int) int {
	// 随机选择一个数，并将与第一个位置的元素交换
	__swap(&arr[lo], &arr[rand.Intn(hi - lo) + lo])
	// 选择第一个为 切分元素
	v := arr[lo]

	// 左右扫描指针
	i := lo + 1
	j := hi

	// 循环从两边找
	for true {

		// 从左向右扫描，找到左边第一个 >= v 的元素
		for i <= hi && arr[i] < v {
			i++
		}

		// 从右向左扫描，找到右边第一个 < v 的元素
		for j >= lo && arr[j] > v {
			j--
		}

		// 控制循环结束
		if i > j {
			break
		}

		//  现在 arr[i] > v arr[j] <= v ，交换后，继续上述步骤
		__swap(&arr[i], &arr[j])

		i++
		j--
	}

	return j
}

func __quickSortAdvanced(arr []int, lo, hi int) {
	if lo - hi <= 15 {
		__insertionSortForQuick(arr, lo, hi)
		return
	}

	j := __partitionAdvanced(arr, lo, hi)

	__quickSortAdvanced(arr, lo, j - 1)
	__quickSortAdvanced(arr, j + 1, hi)

}

func QuickSortAdvanced(arr []int) {
	rand.Seed(time.Now().UnixNano())
	__quickSortAdvanced(arr, 0, len(arr) - 1)
}

```



优化后的快速排序与之前普通的快速排序的性能比较如下：

```bash
QuickSort :
	1000 elements and 1000 random:  0 seconds 
	500000 elements and 10 random:  11.9426644 seconds 
	500000 elements and 500000 random:  0.0419888 seconds 
QuickSortAdvanced :
	1000 elements and 1000 random:  0 seconds 
	500000 elements and 10 random:  0.000984 seconds 
	500000 elements and 500000 random:  0.0010135 seconds 
```

#### 2. 2 三取样切分的 Golang 实现

改进快速排序的第二个办法就是使用三取样切分法，也就是寻找子数组的一小部分中位数来切分数组。

步骤：取三个数（连续的子数组），找到中位数，也就是按照排序顺序，中间第二个元素就是中位数。

golang 实现为：

```go
// 三取样切分算法，返回三取样切分元素索引
func __threeMedianIndex(arr []int, lo, hi int) int {
	//子数组少于3个元素时，第一个元素作为切分元素
	if hi - lo + 1 < 3 {
		return lo
	}

	//子数组有3个或以上元素时，取子数组前三个元素的中位数作为切分元素
	tmpArr := [3]int{lo, lo + 1, lo + 2}

	//使用插入排序法排序新数组b,按原数组的值进行排序。排序后的结果是原数组中小中大值对应的索引
	for i := 0; i < len(tmpArr); i++ {
		for j := i; j > 0; j-- {
			if arr[tmpArr[j]] < arr[tmpArr[j - 1]] {
				__swap(&tmpArr[j], &tmpArr[j - 1])
			}
		}
	}

	return tmpArr[1]
}
```

### 3. 熵最优的排序（三路切分 Dijstra 快速排序）

#### 3.1 三路快排算法

实际中，**经常会出现含有大量重复元素的数组**，在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现。

如果有大量重复元素，那么还是会造成数组切分的不均匀，导致一头非常大，一头非常小，导致快速排序的耗时非常严重，接近于 $O(N^2)$

遇到这种重复元素很多的情况，可以使用 Dijkstra 的“三路切分的快速排序”。



该算法一共维护三个指针：

- 维护一个指针 $lt$ ，使得 $a[lo...lt-1]$ 中的元素都小于 $v$
- 维护一个指针 $gt$ ，使得 $a[gt+1...hi]$ 中的元素都大于 $v$
- 维护一个指针 $i$ ，使得 $a[lt...i-1]$ 中的元素都等于 $v$ 

Dijkstra 三路快速排序算法的步骤为：（三指针的移动过程）

- $a[i]<v$ ，将 $a[lt]$ 和 $a[i]$ 交换，并将 $lt++$, $i++$
- $a[i]>v$ ，将 $a[gt]$ 和 $a[i]$ 交换，并将 $gt--$, $i$ 不变
- $a[i]=v$ ，直接将 $i++$

算法步骤如下图所示：

![三路快速排序](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png?raw=true)

最终分成的三部分分别是：

- $<v$ 部分：lo ~ lt-1
- $=v$ 部分：lt ~ gt
- $>v$ 部分：gt+1 ~ hi



#### 3.2 三路快排的 Golang 实现

```go
func DijkstraQuickSort(arr []int) {
	rand.Seed(time.Now().UnixNano())
	__DijkstraQuickSort(arr, 0, len(arr) - 1)
}
func __DijkstraQuickSort(arr []int, lo, hi int) {
	// 数量小于 15 使用 插入排序
	if hi - lo <= 15 {
		__insertionSortForQuick(arr, lo, hi)
		return
	}

	//  随机切分
	randIndex := rand.Intn(hi - lo) + lo
	__swap(&arr[lo], &arr[randIndex])

	// 切分元素
	//v := arr[lo]
	v := arr[lo]

	//  三个指针初始化
	lt := lo
	gt := hi
	i := lo + 1

	for i <= gt {
		if arr[i] < v {
			__swap(&arr[lt], &arr[i])
			//arr[lt], arr[i] = arr[i], arr[lt]
			lt++
			i++
		} else if arr[i] > v {
			__swap(&arr[gt], &arr[i])
			//arr[gt], arr[i] = arr[i], arr[gt]
			gt--
		} else {
			i++
		}
	}

	// 去掉中间 =v 的部分，已经排好
	__DijkstraQuickSort(arr, lo, lt - 1)
	__DijkstraQuickSort(arr, gt + 1, hi)
}
```

在重复元素有很多的请开给你下，三路快排与普通二路快排的对比：

```bash
三路快速排序耗时：
	100000 elements and 100 random:  0.0026145 seconds 
普通快速排序耗时：
	100000 elements and 100 random:  1.5579819000000001 seconds 
```

上面的原始数组是由 0~100 之间的数组成的数组，一共有100000 个，因此会有大量的重复数据，可以看出上面的结果，三路快排有很大的优势。 



# 堆排序

之前的文章，介绍了使用最大堆和最小堆来实现优先队列，而优先队列的使用场景就是可以从一些列值中，每次选出一个最大/最小值出来，而数组无论插入还是删除元素，都i保持了最大堆/最小堆的堆有序化性质。

可以把任意优先队列变成一种排序算法。

**将所有元素插入一个查找最小元素的优先队列，然后在重复调用删除最小值的操作来将他们按顺序删除**，最终构成的就是一个从小到大的顺序。

实现堆排序，需要两个步骤：

1. 构造堆阶段
2. 排序阶段

## 使用优先队列的构造函数实现堆排序



上面也介绍了堆排序需要两个阶段，如果我们直接使用**最大堆的优先队列**来实现堆排序，那么堆排序的两个步骤可以简化为：

1. **使用最大堆的构造函数，构造堆，并且使用 Insert 方法将待排序的数组元素逐个插入。**
2. **然后每次删除最大的元素，逆序放入到待排序的数组中。**

使用最大堆优先队列的构造函数来直接实现堆排序的 Golang 实现为：

```go
func HeapSort1(arr []int) {
	// 使用 最大堆优先队列 的构造函数创建堆
	maxHeap := lib.MaxHeapInit(len(arr))

	// 将待排序数组的所有元素，逐个插入到堆中
	for _, item := range arr {
		maxHeap.Insert(item)
	}

	// 同样逐个删除堆中的最大值，逆序放入到待排序数组中
	for i := len(arr) - 1; i >= 0; i-- {
		arr[i] = maxHeap.DelMax()
	}
}
```



## 使用新的构造函数实现堆排序



上面的方法，有一个问题就是：

- 在构造堆时，每插入一个元素，都需要调用 swim 操作，将新插入元素上浮
- 每次删除最大值时，也都需要调用 sink 操作，将根节点下沉

### **第一步，堆的构造**。

我们使用一个新的构造函数来实现，实现的思路就是，使用 sink 操作替代 swim 操作。

【思考】：**数组的每一个索引位置是一个子二叉堆，sink 操作，对每一个子二叉堆，同样适用**。

所有的叶子节点，其实已经满足了最大堆的定义，叶子节点没有子节点，是一颗完全二叉树，并且根节点大于子节点（无）。因此，每一个子节点，都是一个子二叉树的根节点。
这里注意：叶子节点没有子节点，因此叶子节点也就不需要 sink 操作，那么如何判断一个索引位置是否是叶子节点呢？**如果堆中有 n 个元素，那么最后一个不是叶子节点的索引为 $n/2$**

用下沉 sink 操作由 N 个元素构造堆只需少于2N 次比较以及少于 N 次交换。

具体的实现步骤：**从最后一个不是叶子节点的索引往前循环，进行 sink 操作（下沉），将每一个子二叉堆都堆有序化，最终到根节点后，整个二叉堆就满足堆有序化了**。

实现流程：

![堆排序2-堆构造过程](https://github.com/Nevermore12321/LeetCode/blob/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/%E5%A0%86%E6%8E%92%E5%BA%8F2-%E5%A0%86%E7%9A%84%E6%9E%84%E9%80%A0.png?raw=true)

​	例如上图，一共有 11 个元素，那么最后一个非叶子节点就是 11/2 = 5 ，那么就将索引为 5 的节点进行 sink 操作，然后依次 4，3，2，1 节点进行同样的操作。以此类推，每个非叶子节点，由底层向高层，最后为根节点，依次执行 sink 操作。

golang 实现：

```go
//  用于堆排序的初始化函数
func MaxHeapInitForSort(arr []int, capacity int) {
	//  建堆过程
	//  创建 堆数组，从1开始存放
	data := make([]int, capacity + 1)
	maxHeap := new(MaxHeap)
	maxHeap.data = data
	maxHeap.count = 0
	
	// 将数组的元素拷贝到堆中
	for i := 0; i < len(arr); i++ {
		maxHeap.data[i + 1] = arr[i]
	}

	// 从最后一个非叶子节点开始，向上依次执行 sink 操作
	for i := capacity / 2; i >= 1; i-- {
		maxHeap.__sink(i)
	}
	
}
```



### 第二步，排序过程

第二步骤，就非常简单了，堆已经建好了，只需要每次将最大值取出，逆序存入数组中即可。

golang 实现为：

```go
func HeapSort2(arr []int) {
	//  排序过程
	maxHeap := lib.MaxHeapInitForSort(arr, len(arr))
	for i := len(arr) - 1; i >= 0; i-- {
		arr[i] = maxHeap.DelMax()
	}
}
```

### 分析

**堆主要用于数据的动态维护。**

该方法建堆的时间复杂度为：

- 将 n 个元素逐个插入到一个空堆中，算法复杂度为 $O(nlog {n})$

- 使用该方法，使用非叶子节点 sink 操作建堆，算法复杂度为 $O(n)$



## 终极堆排序（原地堆排序）

上面两种方法，都使用了堆的 delMax 删除最大值的操作，而且最大的问题是，**上面两个方法的空间复杂度为 $O(n)$**

【思考】：如何不用开辟一段新的空间来存储数组形成的堆，而直接进行堆排序？
【回答】：**原地堆排序**

原地堆排序的算法步骤：

- 原始数组 arr 抽象成堆数组（**从0开始存储**）
- 建堆过程：与第二种方法相同，使用非叶子节点进行 sink 操作
- 排序过程（此时，堆已经有序化了）：
    - 根节点最大，放在数组的末尾，也就是根节点与堆中最后一个元素交换位置
    - 交换后，令堆的长度减一，堆交换后的根节点进行 sink 操作，使得堆有序化，此时最后一个元素已排好。
    - 重复 1 和 2 步骤。



注意：这里需要堆数组从 0 索引开始存储，那么**对于索引为 i 的节点**：

- 索引 i 的父节点：$(i-1)/2$
- 索引 i 的左孩子节点：$2*i+1$
- 索引 i 的右孩子节点：$2*i+2$

同样，对于长度为 N 的堆，最后一个非叶子节点就变成了 $(N-1)/2$



原地堆排序的 Golang 实现：

```go
func swap(arr []int, i, j int) {
	arr[i], arr[j] = arr[j], arr[i]
}


//  堆的 下沉操作
//  arr 表示堆的实现数组，注意堆元素 从 0 开始存放
//  k 表示要下沉的节点
//  n 表示堆的长度 也就是 count
func sink(arr []int, k, n int) {
	// 2k+1 是 k 的左孩子节点
	for 2 * k + 1 < n {
		j := 2 * k + 1

		if j + 1 < n && arr[j] < arr[j + 1] {
			j = j + 1
		}

		if arr[k] > arr[j] {
			break
		}

		swap(arr, k , j)
		k = j
	}
}

func HeapSort3(arr []int) {
	// 建堆过程, 把原始数组抽象成堆数组
	n := len(arr)
	for i := (n - 1) / 2; i >= 0; i-- {
		sink(arr, i, n)
	}

	// 排序过程。i 表示每次堆的长度
	// 每次将最大的第一个元素放到堆末尾，然后堆长度减一
	for i := n - 1; i > 0; i-- {
		// 将最大的 0 号根节点元素，与堆长度最后的位置元素交换
		swap(arr, 0, i)
		// 交换后，破坏了堆有序化，利用 sink 操作，从 根节点开始 下沉，重新形成堆
		sink(arr, 0, i)
	}
}
```

