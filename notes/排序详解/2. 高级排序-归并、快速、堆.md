

[toc]


# 归并排序

**归并排序**：要将一个数组排序，可以先（递归的）将它分成两半分别排序，然后将结果归并起来。

注意：
- **归并排序**最吸引人的性质就是**保证将任意长度为 $N$ 的数组排序所需时间和 $NlogN$ 成正比。**
- **归并排序所需的额外空间和 $N$ 成正比。**


## 原地归并方法

### 归并操作流程
**归并操作**：即将两个有序的数组归并成一个更大的有序数组。

归并操作的流程分析图:
![归并操作的流程分析图](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%8E%9F%E5%9C%B0%E5%BD%92%E5%B9%B6%E6%95%B0%E7%BB%84%E5%88%86%E6%9E%90.png?raw=true)


### 归并操作伪代码
```
__MERGE(A, low, mid, high)
    //  __MERGE 函数是将 A[low, mid] 和 A[mid+1, high] 归并
    //  并且 A[low, mid] 和 A[mid+1, high] 分别有序
    //  i 表示左半部分的下标，j 表示右半部分的下标
    i <- lo
    j <- mid + 1
    
    //  初始化辅助数组，将A中的 low-high 拷贝到 aux 辅助数组中
    aux = A
    
    //  归并开始
    for k <- lo to A.length - 1
        //  i > mid 表示左半部分已经结束，只剩右边 
        if i > mid 
            A[k] = aux[i-l]
            i ++
        //  j > high 表示右半部分已经结束，只剩左边
        else if j > high
            A[k] = aux[j-l]
            j ++
        //  aux[i] < aux[j] 表示左边i号元素小，取左边元素
        else if aux[i] < aux[j]
            A[k] = aux[i]
            i ++
        //  aux[i] > aux[j] 表示右边j号元素小，取右边元素
        else 
            A[k] = aux[j]
            j ++
```


### 归并操作golang实现
```
func __merge(nums []int, l, mid, r int) {
	// 将 nums[l, mid], nums[mid+1, r] 进行归并

	// 开辟辅助空间，并且将原数组复制到辅助数组
	aux := make([]int, r - l + 1)
	for i := l; i <= r; i++ {
		aux[i - l] = nums[i]
	}

	// i、j 分别表示 辅助数组 左右两部分的 下标
	// 设置下标，i 从 l 开始， j 从 mid+1 开始
	var (
		i  = l
		j  = mid + 1
	)

	//  k 表示 原数组 l-r 的位置
	for k := l; k <= r; k++ {

		if i > mid { 					// 说明 左半部分结束，还剩下右半部分，不需要比较，直接复制，右边+1
			nums[k] = aux[j - l]
			j ++
		} else if j > r {				// 说明 右半部分结束，还剩下左半部分，不需要比较，直接复制，左边+1
			nums[k] = aux[i - l]
			i ++
		} else if aux[i - l] < aux[j - l] {			// 都未完成，且左边的小，将左边的复制，左边+1
			nums[k] = aux[i - l]
			i ++
		} else {									//  都未完成，且右边的小，将右边的复制，右边+1
			nums[k] = aux[j - l]
			j ++
		}
	}
}
```



## 自顶向下的归并排序

**自顶向下**：就是将数组从上到下，先分，再合，也就是使用分治思想。

如果能将两个子数组排序，那么就能通过归并两个子数组来将整个数组排序。


### 自顶向下的归并排序图解

![自顶向下的归并排序图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif?raw=true)


### 自顶向下的归并排序递归过程分析

- 自顶向下的归并排序是**分治思想**的典型应用。
- 自顶向下的归并排序利用**递归**，相当于分组，当分组只剩下一个元素后，开始**归并**，也就是上面讲的原地归并方法，__MERGE函数。


![递归过程分析](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png?raw=true)



### 自顶向下的归并排序递归伪代码
- 归并排序的递归函数伪代码：
```go
//  该函数用于递归，将 A[low, high] 排序
__MERGESORT(A, low, high)
    // 递归退出条件
    if low >= high 
        return
    mid <- low + (high - low) / 2
    //  将左半边排序
    __MERGESORT(A, low, mid)
    //  将右半边排序
    __MERGESORT(A, mid+1, high)
    //  两边排完序后，进行归并
    __MERGE(A, low, mid, high)
```
- 归并排序的主函数伪代码：
```go
// 主函数很简单，调用 递归函数即可
MERGESORT(A)
    __MERGESORT(A, 0, A.length - 1)
```

### 自顶向下的归并排序递归golang实现
```go
func __mergeSort(nums []int, l, r int)  {
	//  该函数利用递归，实现自顶向下的归并排序

	//  递归的终止条件，类似 二分搜索
	if l >= r {
		return
	}

	mid := l + (r - l) / 2

	//  递归，对两边分别进行 排序，排好序的两个数组，可以使用归并合成一个有序数组
	__mergeSort(nums, l, mid)
	__mergeSort(nums, mid + 1, r)
	__merge(nums, l, mid, r)
}

func MergeSort(nums []int) {
	__mergeSort(nums, 0, len(nums) - 1)
}
```



## 自顶向下归并排序算法分析

### 时间复杂度

可以看过程分析的树状图，可以发现：
- 每个节点都表示一个MERGESORT()方法通过__MERGE() 方法归并而成的子数组。
- **这棵树一共有 $n$ 层，且 $n = logN$ 层**
- 对于其中任意一层 $k$ ，自顶向下的第k层有 $2^{k}$ 个子数组
- 每个数组的长度为  $2^{n-k}$ ，**每个子数组归并最多需要比较 $2^{n-k}$ 次**
- 因此，每层的比较次数为 $2^k+2^{n-k}=2^n$，**那么所有层一共需要的比较次数为 $n2^n=logN2^{logN}=NlogN$**


因此：
- > **对于长度为 $N$ 的任意数组，自顶向下的归并排序需要  $\frac12 NlogN$ 至 $NlogN$ 次比较**
- > **对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlogN$ 次**  
  > 每次归并最多需要访问数组 $6N$ 次，$2N$ 次用来复制，$2N$ 次用来将排好序的元素移动回去，另外最多比较 $2N$ 次



### 空间复杂度

**归并过程需要一个辅助数组，因此空间复杂度为 $O(N)$**

### 归并排序优缺点

- 优点：
    - 归并排序只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序，可以用归并排序处理数百万甚至更大规模的数组，这是插入排序和选择排序做不到的。
- 缺点：
    - 辅助数组所使用的额外孔家你和N的大小成正比
    - 在大量的递归操作，会耗费一些时间，这就导致，有些归并排序耗时要比希尔排序大。



## 自顶向下归并排序的优化

### 优化1，对小规模数组使用插入排序

**优化步骤**：  

由于递归会使小规模问题中的调用过于频繁，会耗费许多实践，因此，对小规模的子数组使用插入排序处理，比如长度小于15的子数组使用插入排序，一般可将归并排序的运行时间缩短10%-15%。


### 优化2，测试数组是否已经有序

如果在归并两个子数组时，两个子数组整体已经有序，就不需要在遍历比较了，可以直接比较 $A[mid]$ 和 $A[mid+1]$，如果 $A[mid] <= A[mid+1]$，那么就可以跳过__MERGE()方法了。


### 两种优化的golang实现
```go
// 优化后的插入排序
func insertionSort(nums []int, l, r int) {
	for i := l; i <= r; i++ {
		var (
			j = i
			tmp = nums[i]
		)
		for ; j > l && tmp < nums[j - 1]; j-- {
			nums[j] = nums[j - 1]
		}
		nums[j] = tmp
	}
}

//  归并排序的优化，
func __mergeSortAdvanced(nums []int, l, r int) {
	//  递归结束的条件，如果 数组长度 <= 15 ，则直接使用插入排序，并返回
	//  优化1 小规模数组 n <= 15 ，使用插入排序
	if r - l <= 15 {
		insertionSort(nums, l, r)
		return
	}
	//  如果 长度 > 15 继续递归
	mid := l + (r - l) / 2
	__mergeSortAdvanced(nums, l, mid)
	__mergeSortAdvanced(nums, mid + 1, r)

	//  由于左半部分的最大值 nums[mid] 比 右半部分的最小值 nums[mid+1] 还要小，说明整个数组有序，不需要归并，此外其他情况需要归并
	//  优化2 对有序数组的跳过
	if nums[mid] > nums[mid + 1] {
		__merge(nums, l, mid, r)
	}
}

func MergeSortAdvanced(nums []int) {
	__mergeSortAdvanced(nums, 0, len(nums) - 1)
}
```


### 归并排序优化后的时间对比
```bash
ShellSort :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  0.2328659 seconds 
	10000000元素，乱序程度 1000000:  0.3627899 seconds 
MergeSort :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  1.3432265 seconds 
	10000000元素，乱序程度 1000000:  1.6360542 seconds 
MergeSortAdvanced :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  0.2788596 seconds 
	10000000元素，乱序程度 1000000:  1.1533132 seconds 
```

可以看到结果：
- 希尔排序还是一如既往的快
- 归并排序算法的优化后，对于近乎有序的数组有显著的提高，对于乱序的数组，提高不明显。


## 自底向上的归并排序

### 自底向上归并排序的步骤


**步骤**
1. 首先进行的是两两归并，也就是把每个元素想象成一个大小为 1 的数组
2. 然后是四四归并，将两个大小为 2 的数组归并成一个有 4 个元素的数组
3. 然后是八八归并，一直下去
4. 在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小，但是 归并方法 Merge 不是问题。


**自底向上归并排序的图解**
![自底向上归并排序的图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png?raw=true)



### 自底向上归并排序的golang实现
```go
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func MergeSortBT(nums []int) {
	var N = len(nums)

	// sz 表示每一轮子数组的长度
	for sz := 1; sz < N; sz += sz {
		//  lo 表示要归并的两个数组的首元素索引， lo+sz-1 表示 mid 元素的索引，lo+sz+sz-1 表示子数组的尾元素索引
		// 最后两个要归并的两个子数组，最后一个有可能不够 sz 的长度，因此去剩下的 N-1
		for lo := 0; lo < N - sz; lo += sz + sz {
			__merge(nums, lo, lo + sz - 1, min(lo + sz + sz - 1, N - 1))
		}
	}
}
```

### 自底向上归并排序耗时对比
```bash
MergeSort :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  1.3553312 seconds 
	10000000元素，乱序程度 1000000:  1.7118617 seconds 
MergeSortAdvanced :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  0.2994992 seconds 
	10000000元素，乱序程度 1000000:  1.2759504 seconds 
MergeSortBT :
	1000元素，乱序程度 1000:  0 seconds 
	10000000元素，乱序程度 10:  1.4616702 seconds 
	10000000元素，乱序程度 1000000:  1.6634278999999998 seconds 
```

可以看到：
- 自底向上的归并排序，比自顶向下的归并排序耗时差不多。
- **对于长度为N的任意数组，自底向上的归并排序需要 $1/2NlogN$ 至 $NlogN$ 次比较，最多访问数组 $6NlogN$ 次**


## 归并排序总结

- **没有任何基于比较的算法能够保证使用少于 $log(N!)-NlogN$ 次比较将长度为N的数组排序。**
- **归并排序是一种渐进最优的基于比较的排序算法**



# 

