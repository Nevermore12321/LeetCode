# 优先队列（二叉堆）

[toc]



## 优先队列定义

很多应用程序需要处理有序的元素，但不一定需要完全有序，或是不一定要一次就将他们排序。例如，很多情况下我们只需要获取当前最大的元素，然后在添加更多的元素，在获取当前最大的元素，以此类推。

那么这种场景下，只需要两种操作：

- **删除最大元素**
- **插入元素**

满足这种条件的数据类型叫做**优先队列**。

<u>优先队列：出队顺序和入队顺序无关，和优先级有关。</u>
<u>普通队列：先进先出、后进后出。</u>

**优先队列，是一种抽象的数据类型，表示一组值和对这些值的操作。**

### 优先队列的 API

优先队列最重要的操作就是**删除最大元素**和**插入元素**。要实现优先队列，下面的 API 是必不可少的。

- 构造方法：
    - `MaxPQ()` - 创建一个优先队列
    - `MaxPQ(max int)` - 创建一个初始容量为 max 的优先队列
- 插入元素：
    - `Insert(v)` - 向优先队列中插入元素 v
- 删除元素：
    - `delMax()` - 删除并返回优先队列中的最大值
- 返回最大元素
    - `max()` - 返回优先队列中的最大元素
- 判断空队列
    - `isEmpty()` - 判断队列是否为空
- 队列长度
    - `size()` - 返回优先队列的长度

### 优先队列的调用

【思考】：静态问题，在 N 个元素中选出前 M 个元素

- 使用排序方法的时间复杂度为：$O(N\log {N})$
- 使用优先队列方法的时间复杂度为：$O(N\log {M})$

如果，输入 N 的规模特别的庞大，那么使用排序的方法就会造成很大的耗时，而使用优先队列，会大大降低时间的损耗，提高性能。



## 优先队列的实现

使用二叉堆（binary heap）实现优先队列，是最为经典的。

 ### 二叉堆的定义

![image-20211009143450193](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211009143450193.png)

满足以下条件的，成为二叉堆：

- **任何一个节点都比其父节点小。**
- **必须是一颗完全二叉树。**（完全二叉树，是指从上到下、从左到右的顺序组成的一棵树，也就是最后一层，不够的节点全部集中在左侧）

**当一棵二叉树的每个节点都大于等于它的两个子节点时，称为堆有序。**

**根节点是堆有序的二叉树中的最大节点。**

**二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储。（不适用数组的第一个元素）**



### 二叉堆的分类

1. 最大堆：父节点 > 子节点
2. 最小堆：父节点 < 子节点

### 二叉堆的实现（数组实现）

### 二叉堆数据结构的实现

首先，在一个堆中，如果使用数组来实现二叉堆，那么可以通过数组的索引来找到当前节点的父子节点。

对于位置 k 的节点：

- 父节点：$\lfloor k/2 \rfloor$ （也就是 k/2，不带小数部分）
- 左孩子节点：$ 2 * k$
- 右孩子节点：$2 * k + 1$

注意：一颗大小为 N 的完全二叉树，高度为 $\lfloor \log_2 {N} \rfloor$ 

利用数组中无需指针就可以沿树上下移动的便利，保证了对数复杂的性能。

![image-20211009145319166](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211009145319166.png)



利用上面的二叉堆的特性，可以实现一个二叉堆结构的定义，其 Golang 实现为：

```go
// 最大堆
type MaxHeap struct {
	// 存放所有元素
	data []int
	// 数组中由多少元素，也就是堆中的元素个数
	count int
}

func MaxHeapInit(capacity int) *MaxHeap {
    //  因为 0 号元素不存放
	data := make([]int, capacity + 1)
	maxHeap := new(MaxHeap)

	maxHeap.data = data
	maxHeap.count = 0

	return maxHeap
}

func (m *MaxHeap) IsEmpty() bool {
	return m.count == 0
}

func (m *MaxHeap) size() int {
	return m.count
}
```

### 二叉堆基本操作的实现

堆的有序化，也就是如果插入或者删除元素时，要保持堆的特性，也就是使得父节点比子节点大。

堆有序化，有以下两种情况：

- 当某个节点的优先级上升（或者时堆底加入一个新元素），我们需要由下至上恢复堆的顺序。
- 当某个节点的优先级下降（或者删除最大元素，也就是删除根节点时），我们需要由上至下恢复堆的顺序。



1. 向堆中插入元素 - 底向上升

**由下至上的堆有序化（上浮） - swim 操作**

插入元素步骤：

- **将新元素加到数组末尾**
- **增加堆的大小**
- **让这个新元素上浮到合适的位置（swim 操作）**

当插入某个元素时，这时候堆的有序化有可能被打破，也就是插入的元素比其父节点要大，因此需要 swim 操作将该元素由下至上找到一个合适的位置：

![](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211010222411345.png)

整

个插入元素的 Golang 实现：

```go
// 由底向上 上浮操作
// k 表示插入节点 在堆数组中的碎银
func (m *MaxHeap) __swim(k int)  {
	// k/2 =》 表示 k 索引位置的父节点的索引
	// 比较插入元素是否大于父节点元素，如果大，交换，否则退出
	// 如果插入元素比父节点元素大，交换位置，然后再以交换后的索引位置，与其父节点在次比较，以此类推
	// k=1 是根节点，因此退出条件必须大于根节点索引
	for k > 1 && m.data[k/2] < m.data[k] {
		m.__swap(k/2, k)
		k /= 2
	}
}

// 插入元素
func (m *MaxHeap) Insert(item int) {
	//  堆元素个数增加1
	m.count++
	//  新元素插入到堆数组
	m.data[m.count] = item
	//  上浮操作，满足堆有序化
	m.__swim(m.count)
}
```



2.  从堆中删除元素 - 自顶向下

**由上至下的堆有序化（下沉） - sink 操作**

删除元素步骤：

- **从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端**
- **减小堆的大小**
- **将刚放入顶端的元素，下沉到合适的位置（sink 操作）**

![image-20211010225847902](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211010225847902.png)



删除堆中最大元素的 Golang 实现：

```go
//  由顶向下  下沉操作
//  k -> 表示要下沉的某个元素，将最后一个叶子节点 与 根节点交换，然后将交换后的根节点下沉
func (m *MaxHeap) __sink(k int) {
	// 2*k 表示 k 的左孩子，是否存在左孩子
	for 2*k <= m.count {
		// j 表示索引 k 的左右孩子中较大者
		// 先初始化成左孩子
		j := 2*k

		// 如果索引 k 的右孩子大，j 表示右孩子的索引
		if j+1 <= m.count && m.data[j+1] > m.data[j] {
			j += 1
		}

		// 然后判断 父节点 与 左右孩子较大者，谁更大，如果 父节点比左右孩子都大，直接退出，否则，交换
		if m.data[k] > m.data[j] {
			break
		}

		m.__swap(k, j)

		k = j
	}
}

// 删除堆中的最大元素，如果堆为空，返回 -1
func (m *MaxHeap) DelMax() int {
	if m.count == 0 {
		fmt.Println("堆为空，无法删除！")
		return -1
	}

	// 取出最大元素
	max := m.data[1]

	// 交换 最后一个元素 与 根元素
	m.__swap(1, m.count)

	// 减少堆元素
	m.count--

	// 将新的根元素下沉
	m.__sink(1)

	return max
}
```



## 最大堆 Golang 完整实现

```go
package lib

import (
	"fmt"
	"math"
)

// 最大堆
type MaxHeap struct {
	// 存放所有元素
	data []int
	// 数组中由多少元素，也就是堆中的元素个数
	count int
}

func MaxHeapInit(capacity int) *MaxHeap {
	data := make([]int, capacity + 1)
	maxHeap := new(MaxHeap)

	maxHeap.data = data
	maxHeap.count = 0

	return maxHeap
}

func (m *MaxHeap) IsEmpty() bool {
	return m.count == 0
}

func (m *MaxHeap) size() int {
	return m.count
}

func (m *MaxHeap) __swap(i, j int) {
	m.data[i], m.data[j] = m.data[j], m.data[i]
}

// 由底向上 上浮操作
// k 表示插入节点 在堆数组中的碎银
func (m *MaxHeap) __swim(k int) {
	// k/2 =》 表示 k 索引位置的父节点的索引
	// 比较插入元素是否大于父节点元素，如果大，交换，否则退出
	// 如果插入元素比父节点元素大，交换位置，然后再以交换后的索引位置，与其父节点在次比较，以此类推
	// k=1 是根节点，因此退出条件必须大于根节点索引
	for k > 1 && m.data[k/2] < m.data[k] {
		m.__swap(k/2, k)
		k /= 2
	}
}

// 插入元素
func (m *MaxHeap) Insert(item int) {
	//  堆元素个数增加1
	m.count++
	//  新元素插入到堆数组
	m.data[m.count] = item
	//  上浮操作，满足堆有序化
	m.__swim(m.count)
}

//  由顶向下  下沉操作
//  k -> 表示要下沉的某个元素，将最后一个叶子节点 与 根节点交换，然后将交换后的根节点下沉
func (m *MaxHeap) __sink(k int) {
	// 2*k 表示 k 的左孩子，是否存在左孩子
	for 2*k <= m.count {
		// j 表示索引 k 的左右孩子中较大者
		// 先初始化成左孩子
		j := 2*k

		// 如果索引 k 的右孩子大，j 表示右孩子的索引
		if j+1 <= m.count && m.data[j+1] > m.data[j] {
			j += 1
		}

		// 然后判断 父节点 与 左右孩子较大者，谁更大，如果 父节点比左右孩子都大，直接退出，否则，交换
		if m.data[k] > m.data[j] {
			break
		}

		m.__swap(k, j)

		k = j
	}
}

// 删除堆中的最大元素，如果堆为空，返回 -1
func (m *MaxHeap) DelMax() int {
	if m.count == 0 {
		fmt.Println("堆为空，无法删除！")
		return -1
	}

	// 取出最大元素
	max := m.data[1]

	// 交换 最后一个元素 与 根元素
	m.__swap(1, m.count)

	// 减少堆元素
	m.count--

	// 将新的根元素下沉
	m.__sink(1)

	return max
}

// 判断最后一行是否满元素
func isPower(value int) bool {
	n := math.Log2(float64(value));

	return (math.Pow(2, n) == float64(value));
}

func (m *MaxHeap) Show() {

	heapHeight := math.Floor(math.Log2(float64(m.count)));
	var (
		// 第一行的 tab 个数
		firstTabs float64
		intervalTabs float64
		currentHeight float64
		i int
		k float64
	)

	for i = 1; i <= m.count; i++ {
		currentHeight = math.Floor(math.Log2(float64(i)));

		// 判断当前行是否是满行
		if ( isPower(i) ) {
			/* print first tabs */
			fmt.Println()
			// 最开始有多少 tab
			firstTabs = math.Pow(2, heapHeight-currentHeight) - 1
			if firstTabs != 0 {
				for k = 0; k < firstTabs; k++ {
					fmt.Print("\t")
				}
			}
			fmt.Print(m.data[i])
		} else {
			// 如果不是满行，只能是最后一行，
			/* print interval tabs */
			intervalTabs = math.Pow(2, heapHeight - currentHeight + 1);
			for k = 0; k < intervalTabs; k++ {
				fmt.Print("\t")
			}
			fmt.Print(m.data[i])
		}
	}

	fmt.Println()
}

func MaxHeapTest() {
	mp := MaxHeapInit(11)
	mp.Insert(62)
	mp.Insert(41)
	mp.Insert(30)
	mp.Insert(28)
	mp.Insert(16)
	mp.Insert(22)
	mp.Insert(13)
	mp.Show()

	fmt.Println()
	fmt.Println(mp.DelMax())
	mp.Show()

	fmt.Println()
	fmt.Println(mp.DelMax())
	mp.Show()

	fmt.Println()
	mp.Insert(29)
	mp.Show()

}
```

输出结果：

```bash
			62
	41				30
28		16		22		13

62

			41
	28				30
13		16		22

41

			30
	28				22
13		16


			30
	28				29
13		16		22
```

