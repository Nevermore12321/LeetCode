# 优先队列（二叉堆）

[toc]



## 优先队列定义

很多应用程序需要处理有序的元素，但不一定需要完全有序，或是不一定要一次就将他们排序。例如，很多情况下我们只需要获取当前最大的元素，然后在添加更多的元素，在获取当前最大的元素，以此类推。

那么这种场景下，只需要两种操作：

- **删除最大元素**
- **插入元素**

满足这种条件的数据类型叫做**优先队列**。

<u>优先队列：出队顺序和入队顺序无关，和优先级有关。</u>
<u>普通队列：先进先出、后进后出。</u>

**优先队列，是一种抽象的数据类型，表示一组值和对这些值的操作。**

### 优先队列的 API

优先队列最重要的操作就是**删除最大元素**和**插入元素**。要实现优先队列，下面的 API 是必不可少的。

- 构造方法：
    - `MaxPQ()` - 创建一个优先队列
    - ``MaxPQ(max int)` - 创建一个初始容量为 max 的优先队列
- 插入元素：
    - `Insert(v)` - 向优先队列中插入元素 v
- 删除元素：
    - `delMax()` - 删除并返回优先队列中的最大值
- 返回最大元素
    - `max()` - 返回优先队列中的最大元素
- 判断空队列
    - `isEmpty()` - 判断队列是否为空
- 队列长度
    - `size()` - 返回优先队列的长度

### 优先队列的调用

【思考】：静态问题，在 N 个元素中选出前 M 个元素

- 使用排序方法的时间复杂度为：$O(N\log {N})$
- 使用优先队列方法的时间复杂度为：$O(N\log {M})$

如果，输入 N 的规模特别的庞大，那么使用排序的方法就会造成很大的耗时，而使用优先队列，会大大降低时间的损耗，提高性能。



## 优先队列的实现

使用二叉堆（binary heap）实现优先队列，是最为经典的。

 ### 二叉堆的定义

![image-20211009143450193](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211009143450193.png)

满足以下条件的，成为二叉堆：

- **任何一个节点都比其父节点小。**
- **必须是一颗完全二叉树。**（完全二叉树，是指从上到下、从左到右的顺序组成的一棵树，也就是最后一层，不够的节点全部集中在左侧）

**当一棵二叉树的每个节点都大于等于它的两个子节点时，称为堆有序。**

**根节点是堆有序的二叉树中的最大节点。**

**二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储。（不适用数组的第一个元素）**



### 二叉堆的分类

1. 最大堆：父节点 > 子节点
2. 最小堆：父节点 < 子节点



### 二叉堆的实现（数组实现）



### 二叉堆数据结构的实现

首先，在一个堆中，如果使用数组来实现二叉堆，那么可以通过数组的索引来找到当前节点的父子节点。

对于位置 k 的节点：

- 父节点：$\lfloor k/2 \rfloor$ （也就是 k/2，不带小数部分）
- 左孩子节点：$ 2 * k$
- 右孩子节点：$2 * k + 1$

注意：一颗大小为 N 的完全二叉树，高度为 $\lfloor \log_2 {N} \rfloor$ 

利用数组中无需指针就可以沿树上下移动的便利，保证了对数复杂的性能。

![image-20211009145319166](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211009145319166.png)



利用上面的二叉堆的特性，可以实现一个二叉堆结构的定义，其 Golang 实现为：

```go
// 最大堆
type MaxHeap struct {
	// 存放所有元素
	data []int
	// 数组中由多少元素，也就是堆中的元素个数
	count int
}

func MaxHeapInit(capacity int) *MaxHeap {
    //  因为 0 号元素不存放
	data := make([]int, capacity + 1)
	maxHeap := new(MaxHeap)

	maxHeap.data = data
	maxHeap.count = 0

	return maxHeap
}

func (m *MaxHeap) IsEmpty() bool {
	return m.count == 0
}

func (m *MaxHeap) size() int {
	return m.count
}
```

### 二叉堆基本操作的实现

堆的有序化，也就是如果插入或者删除元素时，要保持堆的特性，也就是使得父节点比子节点大。

堆有序化，有以下两种情况：

- 当某个节点的优先级上升（或者时堆底加入一个新元素），我们需要由下至上恢复堆的顺序。
- 当某个节点的优先级下降（或者删除最大元素，也就是删除根节点时），我们需要由上至下恢复堆的顺序。



1. 向堆中插入元素 - 底向上升

**由下至上的堆有序化（上浮） - swim 操作**

插入元素，将新元素加到数组末尾，增加堆的大小，

当插入某个元素时，这时候堆的有序化有可能被打破，也就是插入的元素比其父节点要大，因此需要 swim 操作将该元素由下至上找到一个合适的位置：

![](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211010222411345.png)



2. 由上至下的堆有序化（下沉） - sink 操作

![image-20211010225847902](https://raw.githubusercontent.com/Nevermore12321/LeetCode/blog/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95200%E9%A2%98/image-20211010225847902.png)
