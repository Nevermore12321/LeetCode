[toc]

# 选择排序

## 选择排序步骤

1. 找到数组中最小的元素
2. 将该元素与数组的第一个位置交换
3. 在剩下的元素中找到最小的元素
4. 将该元素与数组的第二个位置交换
5. 循环上面步骤，直到整个数组排序


## 选择排序算法


### 选择算法图解

![选择排序图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif?raw=true)


### 选择算法伪代码

```go
SELECTION_SORT(A)
    //  重排 每一个 位置
    for i = 0 to A.length - 1
        //  minIndex 当前排列中 最小的 index
        minIndex = i
        //  找到 后面 没排列 元素中最小的 序列号
        for j = i + 1 to A.length - 1 
            if A[j] < A[minIndex]
                minIndex = j
        // 将 最小的 元素 交换到当前位置
        swap(A[i], A[minindex])
    
```



## 选择算法分析


- **对于长度为N的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。**
    - $N$次交换，很容易证明，因为有$N$个位置。
    - $N^2/2$次比较，因为对于需要交换的每一个位置 $i$ ，都需要与后面的 $N-i$ 个元素比较，因此，相加  $(N-1)+(N-2)+...+2+1=N(N-1)/2 \approx N^2/2$
- **时间复杂度为$O(n^2)$，空间复杂度是 $O(1)$，不稳定。**
    1. 最好情况： 所有元素已经有序，但同样需要每个位置都需要比较一遍，因此需要$O(n^2)$
    2. 最坏情况：同样需要 $O(n^2)$
    3. 空间复杂度：只用到一个额外变量，因此空间复杂度为 $O(1)$
    4. 稳定性：因为所有元素都有可能被交换，因此，不稳定


-----------


选择排序是一种很简单的排序算法，有两个鲜明的特点：
- 运行时间与输入无关
    - 也就是，如果一个有序数组和一个无序数组，排序的时间是一样长的。
- 数据移动是最少的
    - 交换次数和数组的大小是线性关系。


## 选择算法 golang 实现
```go
func SelectionSort(nums []int) {
	var (
		length int = len(nums)
	)

	for i := 0; i < length; i++ {
		minIndex := i
		var j int = i + 1
		for ; j < length; j++ {
			if nums[j] < nums[minIndex] {
				//  元素交换
				minIndex = j
			}
		}
		nums[i], nums[minIndex] = nums[minIndex], nums[i]
	}
}

```


## 选择排序算法优化

### 优化步骤

- 原始的 选择排序 是 每次找到最小值放在 i 的位置
- 优化的 选择排序 是 每次找到最大值和最小值，放在 left 和 right 位置
- 时间总体的复杂度依旧是 $O(n^2)$
- 但是在循环的时候，循环的次数，要比 原始的选择排序 少一半，但是又有一些多余交换和赋值的开销，因此 优化的选择排序 能够缩短不到一半的时间


### 优化选择排序的伪代码
```go
SELECTION_SORT_ADVANCED(A)
    //  从左边，右边同时开始
    left = 0
    right = A.length - 1
    // 如果 left 的值 比 right 的值大，需要交换
    if A[left] > A[right]
        swap(A[left], A[right])
    //  如果 left > right 说明所有元素已经交换
    while left < right
        //  minIndex 当前排列中 最小的 index
        //  maxIndex 当前排列中 最大的 index
        minIndex = left
        maxIndex = right
        //  找到 后面 没排列 元素中最小的 序列号
        for i = left + 1 to right - 1 
            if A[i] < A[minIndex]
                minIndex = i
            if A[i] > A[maxIndex]
                maxIndex = i
        // 将 最小的 元素 交换到当前位置
        swap(A[left], A[minindex])
        swap(A[right], A[maxIndex])
    
```



### 优化后的 golang 实现

```go
func SelectionSortAdvanced(nums []int) {
	var (
		left int = 0
		right int = len(nums) - 1
	)

	//  两边同时开始找，当 left >=  right 停止
	for left < right {
		var (
			minIndex int = left
			maxIndex int = right
		)
		if nums[minIndex] > nums[maxIndex] {
			nums[minIndex], nums[maxIndex] = nums[maxIndex], nums[minIndex]
		}

		//  在 (left, right) 区间内找最小和最大值
		for i := left + 1; i < right; i++ {
			if nums[i] < nums[minIndex] {
				minIndex = i
			} else if nums[i] > nums[maxIndex] {
				maxIndex = i
			}
		}

		//  找到 最大和最小值 后，交换位置到 left 和 right 位置
		nums[left], nums[minIndex] = nums[minIndex], nums[left]
		nums[right], nums[maxIndex] = nums[maxIndex], nums[right]

		// 增大 left ，缩小 right
		left ++
		right --
	}
}
```

### 时间对比
```bash
SelectionSort :
	1000 elements:  0.0009996 seconds 
	100000 elements:  8.0953979 seconds 
SelectSortAdvanced :
	1000 elements:  0 seconds 
	100000 elements:  5.6437957 seconds 
```

可以看到，优化后的选择排序时间，缩减了大概2秒多。


# 插入排序

## 插入排序步骤

**插入排序原理**：
- 类似打牌的时候，摸牌，手里的牌是有序的，每次摸一张新牌，放在手中特定的位置，手中的牌始终是有序的
- 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。



**步骤**：

1. 取 $i$ 从第二个元素开始，该元素前认为已经被排序。$A[0]-A[i-1]$有序
2. 取 $j$ 为 $i$，在已经排序 $A[0]-A[j-1]$ 序列中从后向前扫描；
3. 如果新元素 $A[j]$ 小于 $A[j-1]$ 已排序，将 $A[j]$ 与 $A[j-1]$ 交换位置
4. 重复步骤3，直到找到新元素的位置
5. $i$  继续取下一个新元素 $i++$
6. 重复步骤2~5，直到 $i$ 到达数组的最右端

## 插入排序算法


### 插入排序图解

![插入排序图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif?raw=true)


### 插入排序伪代码
```go
INSERTION_SORT(A)
    // A[0] - A[i-1] 是有序的
    for i = 1 to A.length-1
        // 新元素 A[j] 如果小于前一个元素，就交换位置
        for j=i to 0
            if A[j] < A[j-1]
                swap(A[j], A[j-1])
            else
                break
```


## 插入排序分析

### 插入排序与选择排序比较

**相同点**
- 当前索引左边的所有元素是有序的
- 但他们的最终位置不确定，有可能会被移动

**不同点**
- 插入排序所需的时间取决于输入元素的初始顺序
- 选择排序与数组的有序程度无关
- 例如，一个很大且其中元素已经有序，或接近有序的数组，插入排序要比选择排序快很多，因为插入排序的内层循环可以提前结束。

--------------


### 插入排序特点

**特点1：**
- 对于随机排列的长度为 $N$ 且主键不重复的数组
    - 平均情况下插入排序需要 $N^2/4$ 次比较，以及 $N^2/4$ 次交换
    - 最坏情况下，需要 $N^2/2$ 次比较和 $N^2/2$交换
    - 最好情况下，需要 $N-1$ 次比较和 $0$ 次交换


-------------

**特点2**：

- 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等倒置的数量，小于等于需要交换的数量加上数组的大小再减一


注意：  
**部分有序**：如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个属猪是部分有序的，部分有序数组有下面特点：
- 数组中每个元素距离它的最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确。

**插入排序对部分有序数组很有效，而选择排序与部分有序数组无关。**

**插入排序对于部分有序数组，相较于十大排序算法的其他算法，可能都要快。**




------------


## 插入排序golang实现

```
func InsertionSort(nums []int)  {
	//  i 从第一个元素开始，第0个表示已排序好
	for i := 1; i < len(nums); i++ {
		//  新元素  j ，往前搜索位置
		for j := i; j > 0; j-- {
			if nums[j] < nums[j - 1] {
				nums[j], nums[j - 1] = nums[j - 1], nums[j]
			} else {
				break
			}
		}
	}
}
```


**结果对比：**
```
SelectionSort :
	1000元素，乱序程度 1000:  0.0009994 seconds 
	100000元素，乱序程度 10:  5.2529885 seconds 
	100000元素，乱序程度 100000:  5.2669657 seconds 
SelectionSortAdvanced :
	1000元素，乱序程度 1000:  0 seconds 
	100000元素，乱序程度 10:  4.6893033 seconds 
	100000元素，乱序程度 100000:  4.2545287 seconds 
InsertionSort :
	1000元素，乱序程度 1000:  0 seconds 
	100000元素，乱序程度 10:  0.0009996 seconds 
	100000元素，乱序程度 100000:  3.8907602 seconds 
```

Note: 乱序程度越大，数组越乱，乱序程度越小，数组越接近有序。
- 可以看到，在接近有序的时候，插入排序有明显的提高。
- 对于选择排序，耗时与数组的有序程度无关



## 插入排序优化

### 优化思路
- 要大幅度的提高插入排序的速度，只需要将交换操作改成右移操作。
- 因为一个交换操作，需要三个赋值操作

图解：
```
6 | 8 | 2 | 3 | 1 | 5
      | i | 
  -> 复制 tmp = 2 
  -> i - 1 位置 8 > tmp 后移，一次赋值
  -> i - 2 位置 6 > tmp 后移，一次赋值
  -> tmp 放在 i-2 位置
```

### 优化插入排序的伪代码
```
INSERTION_SORT_ADVANCED(A)
    // A[0] - A[i-1] 是有序的
    for i = 1 to A.length-1
        // 存放新元素的副本
        tmp = A[i]
        // 新元素 A[j] 如果小于前一个元素，就交换位置
        for j=i to A.length-1
            if tmp < A[j-1]
                A[j] = A[j-1]
            else
                break
        // 最终j的位置，就是要插入的位置
        A[j] = tmp
```


### 优化插入排序的golang实现

```
func InsertionSortAdvanced(nums []int) {
	//  i 从第一个元素开始，第0个表示已排序好
	for i := 1; i < len(nums); i++ {
		//  存放 副本，和初始化最终位置的 j
		var (
			j int = i
			tmp int = nums[i]
		)
		//  寻找 tmp 的位置，如果 tmp 小于当前的 j-1 元素，j-1元素就要后移
		for ; j > 0 && tmp < nums[j - 1]; j-- {
			nums[j] = nums[j - 1]
		}

		//  将 tmp 放入到 最终 j 的位置
		nums[j] = tmp
	}
}
```


### 时间对比

```
InsertionSort :
	1000元素，乱序程度 1000:  0.0009987 seconds 
	100000元素，乱序程度 10:  0 seconds 
	100000元素，乱序程度 100000:  4.0666622 seconds 
InsertionSortAdvanced :
	1000元素，乱序程度 1000:  0 seconds 
	100000元素，乱序程度 10:  0.0009995 seconds 
	100000元素，乱序程度 100000:  1.2572706 seconds 

```

可以发现，优化后的插入排序，时间少了很多。由此可见，大量的赋值操作，会极大地浪费时间。




# 冒泡排序



## 冒泡排序步骤

冒泡排序，类似于打擂台，6每一趟都将未排序中的最大值，也就是最厉害的，放到最后位置。


步骤：
1. 从数组的第一个元素开始，取为 $i$ ，依次与相邻的元素比较，
2. 如果 $i$ 的值 大于  $i+1$ , 那么就交换两个值
3. 直到数组结尾，这样就将未排序中的最大值沉底
4. 重复 2-3 步


冒泡排序的步骤解析图解：


![冒泡排序步骤解析](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90.png?raw=true)

## 冒泡排序算法

### 冒泡排序图解

![冒泡排序图解](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif?raw=true)

### 冒泡排序伪代码

```
BUBBLE_SORT(A)
    //  每一趟，最大的沉底，一共需要 n-1 趟
    for i = 0 to A.length - 1
        //  两两比较，如果逆序，则交换，一趟内，需要 n-i-1 次
        for j = 0 to A.length - i - 1
            if A[j] > A[j + 1]
                swap(A[j], A[j + 1])
```


**注意**：
- 上面的伪代码是最基础的冒泡排序，有个问题就是，一旦在某一趟中，其实数组已经有序，而后面的每一趟，还是得继续比较。
- 优化方法：可以控制循环停止的条件：如果某一趟内，没有一次交换，那说明已经全部有序了。

**优化后的伪代码**

```
BUBBLE_SORT(A)
    // 控制 循环停止的flag, true 表示继续，false表示已经排好，停止
    Bool swappedFlag = true
    //  这里的 n 表示需要多少趟
    n = A.length - 1 
    //  每一趟，最大的沉底，一共需要 n-1 趟
    while swappedFlag
        // 默认为 false
        swappedFlag = false
        //  两两比较，如果逆序，则交换，一趟内，需要 n-i-1 次
        for j = 0 to n
            if A[j] > A[j + 1]
                swap(A[j], A[j + 1])
                //  如果有交换，则未排好，设为true
                swappedFlag = true
        // 注意，这趟排好后，进入下一趟
        n++
```


## 冒泡排序分析

**复杂度**：
- 冒泡排序的时间复杂度为：$N^2$
    - 如果原数组有序，最好的时间复杂度是 $N$; - 如果原数组倒序，则最差的时间是：$(N-1)+(N-2)+…+2+1=N(N-1)/2 \approx O(N^2)$;
- 冒泡排序的空间复杂度为：$O(1)$

**稳定性**：

- 冒泡排序是稳定的。
    - 因为在比较过程中，只有后一个元素比前面的元素大时才会对它们交换位置并向上冒出
    - 对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的。



## 冒泡排序golang实现
```
func BubbleSort(nums []int) {
	var (
		swappedFlag bool = true
		n int = len(nums) - 1
	)

	for swappedFlag {
		swappedFlag = false
		for i := 0; i < n; i++ {
			if nums[i] > nums[i + 1] {
				nums[i], nums[i + 1] = nums[i + 1], nums[i]
				swappedFlag = true
			}
		}
		n --
	}
}
```

**冒泡排序的执行时间**

```
BubbleSort :
	1000元素，乱序程度 1000:  0.0010001 seconds 
	100000元素，乱序程度 10:  4.0347989 seconds 
	100000元素，乱序程度 100000:  14.3052065 seconds 
```

可以看到，冒泡排序相较于 选择排序和插入排序，耗时还是很久的，因为冒泡需要大量的交换操作，也就需要大量的赋值操作。



## 冒泡排序优化

### 优化步骤

- 在冒泡排序的最后，有可能有部分序列已经排好序，因此不需要遍历到结尾
- 在每一趟排序时，比较大小时，最后一次交换后的下标，下标后已经排好序
- 因此，下一趟，内层，只需要遍历到下标前的位置即可。

图解:
![优化冒泡排序步骤解析图](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90.png?raw=true)


### 优化冒泡排序的伪代码
```go
BUBBLE_SORT_ADVANCED(A)
    // newN 表示最后一次交换的位置，也就是下一趟，内层遍历到的位置，初始化为 大于0 的任何值即可
    newN = 1
	n = length - 1

    //  每一趟，最大的沉底，一共需要 n-1 趟
    while newN > 0
        // 默认为 0, 控制循环退出，newN = 0 退出循环，所有元素已经排好序
        newN = 0
        //  两两比较，如果逆序，则交换，一趟内，需要 n-i-1 次
        for j = 0 to n
            if A[j] > A[j + 1]
                swap(A[j], A[j + 1])
                //  如果有交换，则设置 newN 下标
                newN = j + 1
        // 注意，这趟排好后，进入下一趟
        n = newN
```



### 优化后的golang实现
```
func BubbleSortAdvanced(nums []int) {
	var (
		newN int = 1
		n int = len(nums) - 1
	)
	
	for newN > 0 {
		for i := 0; i < n; i++ {
			if nums[i] > nums[i + 1] {
				nums[i], nums[i + 1] = nums[i + 1], nums[i]
				newN = i + 1
			}
		}
		n = newN
	}
}
```

### 时间对比
```
BubbleSort :
	1000元素，乱序程度 1000:  0.0009997 seconds 
	100000元素，乱序程度 10:  3.8163931 seconds 
	100000元素，乱序程度 100000:  14.1536126 seconds 
BubbleSortAdvanced :
	1000元素，乱序程度 1000:  0.0009991 seconds 
	100000元素，乱序程度 10:  2.765333 seconds 
	100000元素，乱序程度 100000:  15.4251931 seconds 
```

可以看出，在部分有序的数组中，还是有所提高的，但是在乱序程度比较的数组中，有了更多的时间花费，应该是newN的计算和赋值导致的。



# 希尔排序

## 希尔排序步骤

**对于大规模乱序数组插入排序很慢**，因为它只会交换相邻的元素，因此元素只能一点一点地从数组中一端移动到另一端。

**希尔排序**为了加快速度简单的改进了插入排序，**交换不相邻的元素以对数组的局部进行排序**，并最终用插入排序将局部有序的数组排序。

**步骤**

1. 分组：通过某个增量将数组分成若干个小数组，例如：增量为 4，那么 $A[0],A[4],A[8]...$ 这是一组
2. 组内排序：通过增量分组后的每个小组，用插入排序进行组内排序
3. 重新设置增量间隔
4. 重复 1-3 步


## 希尔排序算法

### 希尔排序图解

利用希尔排序算法的步骤解析:
![希尔排序算法的步骤解析](https://github.com/Nevermore12321/LeetCode/blob/algorithm4/ch02-%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%A7%A3%E6%9E%90.png?raw=true)


### 希尔排序伪代码
```
SHELL_SORT(A)
    //  设置增量，将整个数组分为三组，增量 3*h+1 不能超过 每组个数n/3
    h <- 1
    while h < n/3 
        h <- 3*h+1
    //  组内使用插入排序, 并将增量减小
    while h >= 1
        // 从第一个增量后开始，每次和前一个组内元素比较
        for i=h to A.length - 1
            tmp <- A[i]
            j <- i
            while j >= h and A[j - h] > tmp
                A[j] = A[j - h]
                j <- j-h
            A[j] = tmp
        //  缩小增量，继续分组
        h <- h / 3
                
```

## 希尔排序分析

希尔排序的思想：**使数组中任意间隔为 h 的元素都是有序的。成为 h 有序数组。**

-----------------

希尔排序更高效的原因是**权衡了子数组的规模和有序性。**
- 排序之初每个子数组都很短
- 排序之后子数组都是部分有序的
- 这两种都适合插入排序
- 子数组部分有序的程度取决于递增序列的选择。


------------------

增量: **增量 h 的初始值是数组长度乘以一个常数因子，最小为1**

------------------

和选择排序以及插入排序形成对比的是，**希尔排序也可以用于大型数组，它对任意排序（不一定是随机的，也可以是接近有序的）的数组表现很好。**

希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。

------------------

时间复杂度：
- 首先结论：运行时间复杂度达不到平方级
- 在最坏情况下，比较次数和 $N^{3/2}$ 成正比
- 平均时间复杂度大概在 $O(N^{1.3})$
- **使用递增序列 $1，4，13，40，121，364...$ 的希尔排序所需的比较次数不会超出 $N$ 的若干倍乘以递增序列的长度。**
- 对于中等大小的数组，它的运行时间是可以接受的，代码量很小，且不需要使用额外的内存空间，空间复杂度为 $O(1)$




## 希尔排序golang实现
```go
func ShellSort(nums []int) {
	var (
		n int = len(nums)
		h int = 1
	)

	//  计算增量，分别为 1，4，13，40，121，364....
	for h < n / 3 {
		h = 3 * h + 1
	}

	// 根据增量分组
	for h >= 1 {
		// 从 第一个增量后，开始循环，与前一个 相差 增量h 的元素比较
		for i := h; i < n; i++ {
			tmp := nums[i]
			var j int = i
			for j >= h && nums[j - h] > nums[j] {
				nums[j] = nums[j - h]
                j = j - h
			}
			nums[j] = tmp
		}
		// 缩小 增量，继续分组排序
		h /= 3
	}
}
```


## 希尔排序，插入排序，选择排序的比较
```
SelectionSort :
	1000元素，乱序程度 1000:  0 seconds 
	100000元素，乱序程度 10:  5.3745858 seconds 
	100000元素，乱序程度 100000:  5.814176 seconds 
InsertionSort :
	1000元素，乱序程度 1000:  0 seconds 
	100000元素，乱序程度 10:  0.0009997 seconds 
	100000元素，乱序程度 100000:  4.0538815 seconds 
ShellSort :
	1000元素，乱序程度 1000:  0 seconds 
	100000元素，乱序程度 10:  0.0009996 seconds 
	100000元素，乱序程度 100000:  0.0039971 seconds 
```