# 	**异或的使用及原理**

[toc]

## 异或运算



**异或，是位运算，相异为1，相同为**。符号为 ^，例如 a 异或 b，记为 `a ^ b`

```bash
a ^ b = ?
# 二进制运算
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
```

例如：

```go
a = 10110
b = 00111

a ^ b = 10001
```

异或可以简单理解为**二进制的无进位相加**。



## 异或运算的性质



异或运算的性质有：

1. `0 ^ N = N` - **任何数与 0 异或的结果不变**，都是自己
2. `N ^ N = 0` - 任何数与自己异或的结果，都为0
3. 异或运算**满足交换律和结合律**
    1. 交换律：`a ^ b = b ^ a`
    2. 结合律：`(a ^ b) ^ c = a ^ (b ^ c)`



## 异或运算的应用



### 应用一：交换两个变量



例如：要交换变量 a 和 b 的值，可以使用如下代码：

```go
a = a ^ b
b = a ^ b
c = a ^ b
```

【思考】：这是怎么做到交换了两个变量的值呢？
答：假设变量 a 的值为甲，变量 b 的值为乙，那么上面三行代码的实际效果如下：

```go
a = a ^ b		=> a = 甲 ^ 乙
b = a ^ b		=> b = 甲 ^ 乙 ^ 乙 = 甲 ^ (乙 ^ 乙) = 甲 ^ 0 = 甲
a = a ^ b		=> a = 甲 ^ 乙 ^ 甲 = 乙 ^ (甲 ^ 甲) = 乙 ^ 0 = 乙

至此，交换完成
```

**注意**：**使用异或交换两个变量的前提，就是这两个变量指向的内存不是同一块，如果 a 和 b 指向同一个数，那么上面三行代码就会把 a 和 b 指向的数值抹成 0**。



### 应用二：找到具有奇数个元素的值



**例题1** ：有一个整型数组，其中只有一种数，出现了奇数次，而其他数，都出现了偶数次，找到出现了奇数次的数。
**要求**	：时间复杂度为 $O(n)$，空间复杂度为 $O(1)$

**解答思路**：

​	根据异或的结合律和交换律，将数组中的所有数异或，具有偶数次的数目异或，结果为0，只有奇数次的数目，结果才会本身。例如：

```bash
[2, 1, 3, 1, 3, 1, 3, 2, 1]
# 所有数异或，经过异或的交换律和结合律
(1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3 ^ 3)\
= 0 ^ 0 ^ 3
= 3
```

​	**golang 的代码为**：

```go
func PrintOddTimesNum1(nums []int) {
	var eor int = 0
	
	// 所有元素异或，得到奇数次的数
	for _, v := range nums {
		eor ^= v
	}

	print(eor)

}

func PrintOddTimesNums1Test() {
	nums := []int {2,1,3,1,2,3,1,3,1}

	PrintOddTimesNum1(nums)
}
```

**例题二** ： 有一个整型数组，其中有两个不同的数，出现了奇数次，而其他数，都出现了偶数次，找到出现了奇数次的这两种数。
**要求**	：时间复杂度为 $O(n)$，空间复杂度为 $O(1)$

**解答思路**：

同样使用异或的位运算来解决这道题目。假设出现了奇数次的两个不同的数分别是 a 和 b

- 首先分析，有两种不同的数，出现了奇数次，那么如果将数组中所有的元素进行异或，那么最终的异或结果，就是 `a ^ b`
- 其次，a 和 b 不同，那么 `a ^ b` 一定是非 0 的。
    -  `a ^ b` 表示 a 和 b 的所有不同的 bit 位，例如， `a ^ b` 的结果第八位为 1，那么 a 和 b 的第八位一定不同，也就是一个为 0，一个为 1
    -  a 和 b 的 8 bits 中，一定有某一位不同，那么我们就找到最右边的  `a ^ b` 结果为 1 是第几位。
- 找到 a 和 b 的某一位不同后，将数组中所有这一位上为 1 的数异或，那么就会得到，a 和 b 中的某一个。****
- 再利用  `a ^ b ^ a = b ` 或者 `a ^ b ^ b = a ` 得出另一个 

**golang 代码为：**

```go
func PrintOddTimesNum2(nums []int) {
	var (
		eor1 int = 0
		eor2 int = 0
	)

	// 计算所有元素异或，结果也就是 a^b
	for _, v := range nums {
		eor1 ^= v
	}

	// eor = a ^ b
	// eor != 0
	// eor 必然有一个bit位为 1

	// 找出 a^b 结果最右边为 1 的 bit 位
	// 取反加一在与本身
	rightOne := eor1 & (^eor1 + 1)

	// eor2 表示所有 rightOne 位为 1 的异或的结果，也就是 a 或者 b
	for _, v := range nums {
		if (v & rightOne) == 0 {
			eor2 ^= v
		}
	}

	fmt.Printf("a = %d, b = %d\n", eor2, eor2 ^ eor1)


}


func PrintOddTimesNums2Test() {
	nums := []int {2,1,3,1,2,3,1,3,1,5,4,4,5,5}

	PrintOddTimesNum2(nums)
}
```

注意：**找到某个数最右边的第一个bit位为 1 ，是哪个 bit 位，可以使用 `right = a & (~a + 1)` （取反加一与本身）。**

```bash
a 			 = 1011 0010
~a 		   	 = 0100 1101
~a+1 		 = 0100 1110
a & (~a + 1) = 0000 0010

a 中最右边为 1 的 bit 为 第二位
```

