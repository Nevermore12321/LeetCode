# 排序算法总结



[toc]

## 排序算法分类

十大排序算法，分别通过三个分类来介绍
    - 
- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
    - **初级排序**：时间复杂度为O(n^2)
        1. 选择排序
        2. 冒泡排序
        3. 插入排序
        4. 希尔排序
    - **高级排序**：时间复杂度为O(nlogn)
        1. 快速排序
        2. 归并排序
        3. 堆排序
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。
    - 非比较类排序的时间复杂度为O(n)
        1. 计数排序
        2. 桶排序
        3. 基数排序



## 排序算法评价标准

- **稳定**：如果有相同元素，那么排序后，相同元素的相对位置没有改变
- **不稳定**：如果有相同元素，那么排序后，相同元素的相对位置发生改变
- **时间复杂度**：也就是算法花费时间的增长曲线
- **空间复杂度**：算法的占用的空间




## 排序算法比较

| 排序算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 |
| :--------: | :--------: | :--------: | :--------: | :--------: | :--------: |
| 选择排序 |   $O(n^2)$ 	|	 $O(n^2)$      | $O(n^2)$       | $O(1)$   | 不稳定 |
| 冒泡排序 |    $O(n^2)$    | $O(n^2)$      | $O(n)$         | $O(1)$   | 稳定   |
| 插入排序 |    $O(n^2)$    | $O(n^2)$       | $O(n)$         | $O(1)$   | 稳定   |
| 希尔排序 |  $O(n^{1.3})$  | $O(n^2)$       | $O(n)$         | $O(1)$   | 不稳定 |
|	 快速排序 	| 	$O(n\log(n))$	|	$O(n^2)$	| $O(n\log(n))$ | $O(\log(n))$ |	不稳定	|
| 归并排序 | $O(n\log(n))$ | $O(n\log(n))$ | $O(n\log(n))$ | $O(n)$ | 稳定 |
| 计数排序 | $O(n+k)$ | $O(n+k)$ | $O(n+k)$ | $O(k)$ | 稳定 |
| 桶排序 | $O(n+k)$ | $O(n^2)$ | $O(n)$ | $O(n+k)$ | 稳定 |
| 基数排序 | $O(n*k)$ | $O(n*k)$ | $O(n*k)$ | $O(n+k)$ | 稳定 |




## 对排序算法时间的计算

1. GenerateNearlyOrderedArray 函数
    - 生成一个无序数组
    - 并且能够控制数组的乱序程度
2. SortDuration 函数
    - 对比 1000 个元素的数组 和 100000 个元素的数组，排序算法花费的时间



```go
package utils

import (
	"fmt"
	"math/rand"
	"time"
)

/*
@title    数组生成函数
@description   生成一个近乎有序的数组
@auth	Shaohe Guo
@param     length        int         "数组长度"
@param    swapTimes        int         "交换次数，也就是有序性，越小越有序，如果为0，表示完全有序"
@return		无序数组			[]int		"返回生成的无序数组" 
 */
func GenerateNearlyOrderedArray(length, swapTimes int) []int {
	// 生成有序的数组
	arr := make([]int, length)
	for i := 0; i < length; i++ {
		arr[i] = i
	}

	//  随机交换 swapTimes 次
	rand.Seed(time.Now().UnixNano())
	for i := 0; i < swapTimes; i++ {
		posx := rand.Intn(length)
		posy := rand.Intn(length)
		arr[posx], arr[posy] = arr[posy], arr[posx]
	}

	return arr
}


/*
@title    测试排序算法的时间
@description   随机生成无序数组，并测试排序算法时间
@auth	Shaohe Guo
@param     mySort        int         "排序算法的回调函数"
@param    SortName        int         "排序算法名称"
*/
func SortDuration(mySort func([]int), SortName string) {
	tinyArr := GenerateNearlyOrderedArray(1000, 1000)
	hugeArr := GenerateNearlyOrderedArray(100000, 10000)

	fmt.Println(SortName, ":")

	curTime := time.Now()
	mySort(tinyArr)
	durTime := time.Now().Sub(curTime).Seconds()
	fmt.Printf("\t1000 elements:  %v seconds \n", durTime)

	curTime = time.Now()
	mySort(hugeArr)
	durTime = time.Now().Sub(curTime).Seconds()
	fmt.Printf("\t100000 elements:  %v seconds \n", durTime)

}


```